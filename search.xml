<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PowerDesigner(2)-把PowerDesigner里面的表导出Excel]]></title>
    <url>%2F2017%2F09%2F11%2FPowerDesigner-2%2F</url>
    <content type="text"><![CDATA[PS:选中tablesctrl + shift +x 然后运行以下脚本 Option ExplicitDim rowsNumrowsNum = 0‘—————————————————————————–‘ Main function‘—————————————————————————–‘ Get the current active modelDim ModelSet Model = ActiveModelIf (Model Is Nothing) Or (Not Model.IsKindOf(PdPDM.cls_Model)) ThenMsgBox “The current model is not an PDM model.”Else‘ Get the tables collection‘创建EXCEL APPdim beginrowDIM EXCEL, SHEET, SHEETLISTset EXCEL = CREATEOBJECT(“Excel.Application”)EXCEL.workbooks.add(-4167)’添加工作表EXCEL.workbooks(1).sheets(1).name =”表结构”set SHEET = EXCEL.workbooks(1).sheets(“表结构”) EXCEL.workbooks(1).sheets.addEXCEL.workbooks(1).sheets(1).name =”目录”set SHEETLIST = EXCEL.workbooks(1).sheets(“目录”)ShowTableList Model,SHEETLIST ShowProperties Model, SHEET,SHEETLIST EXCEL.workbooks(1).Sheets(2).SelectEXCEL.visible = true‘设置列宽和自动换行sheet.Columns(1).ColumnWidth = 20sheet.Columns(2).ColumnWidth = 20sheet.Columns(3).ColumnWidth = 20sheet.Columns(4).ColumnWidth = 40sheet.Columns(5).ColumnWidth = 10sheet.Columns(6).ColumnWidth = 10sheet.Columns(1).WrapText =truesheet.Columns(2).WrapText =truesheet.Columns(4).WrapText =true‘不显示网格线EXCEL.ActiveWindow.DisplayGridlines = False End If‘—————————————————————————–‘ Show properties of tables‘—————————————————————————–Sub ShowProperties(mdl, sheet,SheetList)‘ Show tables of the current model/packagerowsNum=0beginrow = rowsNum+1Dim rowIndexrowIndex=3‘ For each tableoutput “begin”Dim tabFor Each tab In mdl.tablesShowTable tab,sheet,rowIndex,sheetListrowIndex = rowIndex +1Nextif mdl.tables.count &gt; 0 thensheet.Range(“A” &amp; beginrow + 1 &amp; “:A” &amp; rowsNum).Rows.Groupend ifoutput “end”End Sub‘—————————————————————————–‘ Show table properties‘—————————————————————————–Sub ShowTable(tab, sheet,rowIndex,sheetList)If IsObject(tab) ThenDim rangFlagrowsNum = rowsNum + 1‘ Show propertiesOutput “================================”sheet.cells(rowsNum, 1) =tab.namesheet.cells(rowsNum, 1).HorizontalAlignment=3sheet.cells(rowsNum, 2) = tab.code‘sheet.cells(rowsNum, 5).HorizontalAlignment=3‘sheet.cells(rowsNum, 6) = “”‘sheet.cells(rowsNum, 7) = “表说明”sheet.cells(rowsNum, 3) = tab.comment‘sheet.cells(rowsNum, 8).HorizontalAlignment=3sheet.Range(sheet.cells(rowsNum, 3),sheet.cells(rowsNum, 7)).Merge‘设置超链接，从目录点击表名去查看表结构‘字段中文名 字段英文名 字段类型 注释 是否主键 是否非空 默认值sheetList.Hyperlinks.Add sheetList.cells(rowIndex,2), “”,”表结构”&amp;”!B”&amp;rowsNumrowsNum = rowsNum + 1sheet.cells(rowsNum, 1) = “字段中文名”sheet.cells(rowsNum, 2) = “字段英文名”sheet.cells(rowsNum, 3) = “字段类型”sheet.cells(rowsNum, 4) = “注释”sheet.cells(rowsNum, 5) = “是否主键”sheet.cells(rowsNum, 6) = “是否非空”sheet.cells(rowsNum, 7) = “默认值”‘设置边框sheet.Range(sheet.cells(rowsNum-1, 1),sheet.cells(rowsNum, 7)).Borders.LineStyle = “1”‘sheet.Range(sheet.cells(rowsNum-1, 4),sheet.cells(rowsNum, 9)).Borders.LineStyle = “1”‘字体为10号sheet.Range(sheet.cells(rowsNum-1, 1),sheet.cells(rowsNum, 7)).Font.Size=10Dim col ‘ running columnDim colsNumcolsNum = 0for each col in tab.columnsrowsNum = rowsNum + 1colsNum = colsNum + 1sheet.cells(rowsNum, 1) = col.name‘sheet.cells(rowsNum, 3) = “”‘sheet.cells(rowsNum, 4) = col.namesheet.cells(rowsNum, 2) = col.codesheet.cells(rowsNum, 3) = col.datatypesheet.cells(rowsNum, 4) = col.commentIf col.Primary = true Thensheet.cells(rowsNum, 5) = “Y”Elsesheet.cells(rowsNum, 5) = “ “End IfIf col.Mandatory = true Thensheet.cells(rowsNum, 6) = “Y”Elsesheet.cells(rowsNum, 6) = “ “End Ifsheet.cells(rowsNum, 7) = col.defaultvaluenextsheet.Range(sheet.cells(rowsNum-colsNum+1,1),sheet.cells(rowsNum,7)).Borders.LineStyle = “3”‘sheet.Range(sheet.cells(rowsNum-colsNum+1,4),sheet.cells(rowsNum,9)).Borders.LineStyle = “3”sheet.Range(sheet.cells(rowsNum-colsNum+1,1),sheet.cells(rowsNum,7)).Font.Size = 10rowsNum = rowsNum + 2 Output “FullDescription: “ + tab.NameEnd If End Sub‘—————————————————————————–‘ Show List Of Table‘—————————————————————————–Sub ShowTableList(mdl, SheetList)‘ Show tables of the current model/packageDim rowsNorowsNo=1‘ For each tableoutput “begin”SheetList.cells(rowsNo, 1) = “主题”SheetList.cells(rowsNo, 2) = “表中文名”SheetList.cells(rowsNo, 3) = “表英文名”SheetList.cells(rowsNo, 4) = “表说明”rowsNo = rowsNo + 1SheetList.cells(rowsNo, 1) = mdl.nameDim tabFor Each tab In mdl.tablesIf IsObject(tab) ThenrowsNo = rowsNo + 1SheetList.cells(rowsNo, 1) = “”SheetList.cells(rowsNo, 2) = tab.nameSheetList.cells(rowsNo, 3) = tab.codeSheetList.cells(rowsNo, 4) = tab.commentEnd IfNextSheetList.Columns(1).ColumnWidth = 20SheetList.Columns(2).ColumnWidth = 20SheetList.Columns(3).ColumnWidth = 30SheetList.Columns(4).ColumnWidth = 60output “end”End Sub]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>PowerDesigner</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[23种设计模式]]></title>
    <url>%2F2017%2F09%2F06%2F23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、设计模式的分类总体来说设计模式分为三大类：创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。其实还有两类：并发型模式和线程池模式。用一个图片来整体描述一下： 二、设计模式的六大原则1、开闭原则（Open Close Principle）开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。2、里氏代换原则（Liskov Substitution Principle）里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科3、依赖倒转原则（Dependence Inversion Principle）这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。4、接口隔离原则（Interface Segregation Principle）这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。5、迪米特法则（最少知道原则）（Demeter Principle）为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。6、合成复用原则（Composite Reuse Principle）原则是尽量使用合成/聚合的方式，而不是使用继承。 三、Java的23中设计模式从这一块开始，我们详细介绍Java中23种设计模式的概念，应用场景等情况，并结合他们的特点及设计模式的原则进行分析。1、工厂方法模式（Factory Method）工厂方法模式分为三种：11、普通工厂模式，就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。首先看下关系图： 举例如下：（我们举一个发送邮件和短信的例子）首先，创建二者的共同接口： [java] view plaincopypublic interface Sender { public void Send();} 其次，创建实现类： [java] view plaincopypublic class MailSender implements Sender { @Override public void Send() { System.out.println(“this is mailsender!”); }} [java] view plaincopypublic class SmsSender implements Sender { @Override public void Send() { System.out.println(&quot;this is sms sender!&quot;); } } 最后，建工厂类： [java] view plaincopypublic class SendFactory { public Sender produce(String type) { if (&quot;mail&quot;.equals(type)) { return new MailSender(); } else if (&quot;sms&quot;.equals(type)) { return new SmsSender(); } else { System.out.println(&quot;请输入正确的类型!&quot;); return null; } } } 我们来测试下： public class FactoryTest { public static void main(String[] args) { SendFactory factory = new SendFactory(); Sender sender = factory.produce(&quot;sms&quot;); sender.Send(); } } 输出：this is sms sender!22、多个工厂方法模式，是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。关系图： 将上面的代码做下修改，改动下SendFactory类就行，如下： [java] view plaincopypublic class SendFactory { public Sender produceMail(){ return new MailSender(); } public Sender produceSms(){ return new SmsSender(); } } 测试类如下： [java] view plaincopypublic class FactoryTest { public static void main(String[] args) { SendFactory factory = new SendFactory(); Sender sender = factory.produceMail(); sender.Send(); } } 输出：this is mailsender!33、静态工厂方法模式，将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。 [java] view plaincopypublic class SendFactory { public static Sender produceMail(){ return new MailSender(); } public static Sender produceSms(){ return new SmsSender(); } } [java] view plaincopypublic class FactoryTest { public static void main(String[] args) { Sender sender = SendFactory.produceMail(); sender.Send(); } } 输出：this is mailsender!总体来说，工厂模式适合：凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。在以上的三种模式中，第一种如果传入的字符串有误，不能正确创建对象，第三种相对于第二种，不需要实例化工厂类，所以，大多数情况下，我们会选用第三种——静态工厂方法模式。2、抽象工厂模式（Abstract Factory）工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。因为抽象工厂不太好理解，我们先看看图，然后就和代码，就比较容易理解。 请看例子： [java] view plaincopypublic interface Sender { public void Send();} 两个实现类： [java] view plaincopypublic class MailSender implements Sender { @Override public void Send() { System.out.println(“this is mailsender!”); }} [java] view plaincopypublic class SmsSender implements Sender { @Override public void Send() { System.out.println(&quot;this is sms sender!&quot;); } } 两个工厂类： [java] view plaincopypublic class SendMailFactory implements Provider { @Override public Sender produce(){ return new MailSender(); } } [java] view plaincopypublic class SendSmsFactory implements Provider{ @Override public Sender produce() { return new SmsSender(); } } 在提供一个接口： [java] view plaincopypublic interface Provider { public Sender produce();} 测试类： [java] view plaincopypublic class Test { public static void main(String[] args) { Provider provider = new SendMailFactory(); Sender sender = provider.produce(); sender.Send(); } } 其实这个模式的好处就是，如果你现在想增加一个功能：发及时信息，则只需做一个实现类，实现Sender接口，同时做一个工厂类，实现Provider接口，就OK了，无需去改动现成的代码。这样做，拓展性较好！3、单例模式（Singleton）单例对象（Singleton）是一种常用的设计模式。在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。这样的模式有几个好处：1、某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。2、省去了new操作符，降低了系统内存的使用频率，减轻GC压力。3、有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（比如一个军队出现了多个司令员同时指挥，肯定会乱成一团），所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程。首先我们写一个简单的单例类： [java] view plaincopypublic class Singleton { /* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */ private static Singleton instance = null; /* 私有构造方法，防止被实例化 */ private Singleton() { } /* 静态工程方法，创建实例 */ public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } /* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */ public Object readResolve() { return instance; } } 这个类可以满足基本要求，但是，像这样毫无线程安全保护的类，如果我们把它放入多线程的环境下，肯定就会出现问题了，如何解决？我们首先会想到对getInstance方法加synchronized关键字，如下： [java] view plaincopypublic static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } 但是，synchronized关键字锁住的是这个对象，这样的用法，在性能上会有所下降，因为每次调用getInstance()，都要对对象上锁，事实上，只有在第一次创建对象的时候需要加锁，之后就不需要了，所以，这个地方需要改进。我们改成下面这个： [java] view plaincopypublic static Singleton getInstance() { if (instance == null) { synchronized (instance) { if (instance == null) { instance = new Singleton(); } } } return instance; } 似乎解决了之前提到的问题，将synchronized关键字加在了内部，也就是说当调用的时候是不需要加锁的，只有在instance为null，并创建对象的时候才需要加锁，性能有一定的提升。但是，这样的情况，还是有可能有问题的，看下面的情况：在Java指令中创建对象和赋值操作是分开进行的，也就是说instance = new Singleton();语句是分两步执行的。但是JVM并不保证这两个操作的先后顺序，也就是说有可能JVM会为新的Singleton实例分配空间，然后直接赋值给instance成员，然后再去初始化这个Singleton实例。这样就可能出错了，我们以A、B两个线程为例：a&gt;A、B线程同时进入了第一个if判断b&gt;A首先进入synchronized块，由于instance为null，所以它执行instance = new Singleton();c&gt;由于JVM内部的优化机制，JVM先画出了一些分配给Singleton实例的空白内存，并赋值给instance成员（注意此时JVM没有开始初始化这个实例），然后A离开了synchronized块。d&gt;B进入synchronized块，由于instance此时不是null，因此它马上离开了synchronized块并将结果返回给调用该方法的程序。e&gt;此时B线程打算使用Singleton实例，却发现它没有被初始化，于是错误发生了。所以程序还是有可能发生错误，其实程序在运行过程是很复杂的，从这点我们就可以看出，尤其是在写多线程环境下的程序更有难度，有挑战性。我们对该程序做进一步优化： [java] view plaincopyprivate static class SingletonFactory{ private static Singleton instance = new Singleton(); } public static Singleton getInstance(){ return SingletonFactory.instance; } 实际情况是，单例模式使用内部类来维护单例的实现，JVM内部的机制能够保证当一个类被加载的时候，这个类的加载过程是线程互斥的。这样当我们第一次调用getInstance的时候，JVM能够帮我们保证instance只被创建一次，并且会保证把赋值给instance的内存初始化完毕，这样我们就不用担心上面的问题。同时该方法也只会在第一次调用的时候使用互斥机制，这样就解决了低性能问题。这样我们暂时总结一个完美的单例模式： [java] view plaincopypublic class Singleton { /* 私有构造方法，防止被实例化 */ private Singleton() { } /* 此处使用一个内部类来维护单例 */ private static class SingletonFactory { private static Singleton instance = new Singleton(); } /* 获取实例 */ public static Singleton getInstance() { return SingletonFactory.instance; } /* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */ public Object readResolve() { return getInstance(); } } 其实说它完美，也不一定，如果在构造函数中抛出异常，实例将永远得不到创建，也会出错。所以说，十分完美的东西是没有的，我们只能根据实际情况，选择最适合自己应用场景的实现方法。也有人这样实现：因为我们只需要在创建类的时候进行同步，所以只要将创建和getInstance()分开，单独为创建加synchronized关键字，也是可以的： [java] view plaincopypublic class SingletonTest { private static SingletonTest instance = null; private SingletonTest() { } private static synchronized void syncInit() { if (instance == null) { instance = new SingletonTest(); } } public static SingletonTest getInstance() { if (instance == null) { syncInit(); } return instance; } } 考虑性能的话，整个程序只需创建一次实例，所以性能也不会有什么影响。补充：采用”影子实例”的办法为单例对象的属性同步更新 [java] view plaincopypublic class SingletonTest { private static SingletonTest instance = null; private Vector properties = null; public Vector getProperties() { return properties; } private SingletonTest() { } private static synchronized void syncInit() { if (instance == null) { instance = new SingletonTest(); } } public static SingletonTest getInstance() { if (instance == null) { syncInit(); } return instance; } public void updateProperties() { SingletonTest shadow = new SingletonTest(); properties = shadow.getProperties(); } } 通过单例模式的学习告诉我们：1、单例模式理解起来简单，但是具体实现起来还是有一定的难度。2、synchronized关键字锁定的是对象，在用的时候，一定要在恰当的地方使用（注意需要使用锁的对象和过程，可能有的时候并不是整个对象及整个过程都需要锁）。到这儿，单例模式基本已经讲完了，结尾处，笔者突然想到另一个问题，就是采用类的静态方法，实现单例模式的效果，也是可行的，此处二者有什么不同？首先，静态类不能实现接口。（从类的角度说是可以的，但是那样就破坏了静态了。因为接口中不允许有static修饰的方法，所以即使实现了也是非静态的）其次，单例可以被延迟初始化，静态类一般在第一次加载是初始化。之所以延迟加载，是因为有些类比较庞大，所以延迟加载有助于提升性能。再次，单例类可以被继承，他的方法可以被覆写。但是静态类内部方法都是static，无法被覆写。最后一点，单例类比较灵活，毕竟从实现上只是一个普通的Java类，只要满足单例的基本需求，你可以在里面随心所欲的实现一些其它功能，但是静态类不行。从上面这些概括中，基本可以看出二者的区别，但是，从另一方面讲，我们上面最后实现的那个单例模式，内部就是用一个静态类来实现的，所以，二者有很大的关联，只是我们考虑问题的层面不同罢了。两种思想的结合，才能造就出完美的解决方案，就像HashMap采用数组+链表来实现一样，其实生活中很多事情都是这样，单用不同的方法来处理问题，总是有优点也有缺点，最完美的方法是，结合各个方法的优点，才能最好的解决问题！4、建造者模式（Builder）工厂类模式提供的是创建单个类的模式，而建造者模式则是将各种产品集中起来进行管理，用来创建复合对象，所谓复合对象就是指某个类具有不同的属性，其实建造者模式就是前面抽象工厂模式和最后的Test结合起来得到的。我们看一下代码：还和前面一样，一个Sender接口，两个实现类MailSender和SmsSender。最后，建造者类如下： [java] view plaincopypublic class Builder { private List&lt;Sender&gt; list = new ArrayList&lt;Sender&gt;(); public void produceMailSender(int count){ for(int i=0; i&lt;count; i++){ list.add(new MailSender()); } } public void produceSmsSender(int count){ for(int i=0; i&lt;count; i++){ list.add(new SmsSender()); } } } 测试类： [java] view plaincopypublic class Test { public static void main(String[] args) { Builder builder = new Builder(); builder.produceMailSender(10); } } 从这点看出，建造者模式将很多功能集成到一个类里，这个类可以创造出比较复杂的东西。所以与工程模式的区别就是：工厂模式关注的是创建单个产品，而建造者模式则关注创建符合对象，多个部分。因此，是选择工厂模式还是建造者模式，依实际情况而定。5、原型模式（Prototype）原型模式虽然是创建型的模式，但是与工程模式没有关系，从名字即可看出，该模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。本小结会通过对象的复制，进行讲解。在Java中，复制对象是通过clone()实现的，先创建一个原型类： [java] view plaincopypublic class Prototype implements Cloneable { public Object clone() throws CloneNotSupportedException { Prototype proto = (Prototype) super.clone(); return proto; } } 很简单，一个原型类，只需要实现Cloneable接口，覆写clone方法，此处clone方法可以改成任意的名称，因为Cloneable接口是个空接口，你可以任意定义实现类的方法名，如cloneA或者cloneB，因为此处的重点是super.clone()这句话，super.clone()调用的是Object的clone()方法，而在Object类中，clone()是native的，具体怎么实现，我会在另一篇文章中，关于解读Java中本地方法的调用，此处不再深究。在这儿，我将结合对象的浅复制和深复制来说一下，首先需要了解对象深、浅复制的概念：浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。此处，写一个深浅复制的例子： [java] view plaincopypublic class Prototype implements Cloneable, Serializable { private static final long serialVersionUID = 1L; private String string; private SerializableObject obj; /* 浅复制 */ public Object clone() throws CloneNotSupportedException { Prototype proto = (Prototype) super.clone(); return proto; } /* 深复制 */ public Object deepClone() throws IOException, ClassNotFoundException { /* 写入当前对象的二进制流 */ ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(this); /* 读出二进制流产生的新对象 */ ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); return ois.readObject(); } public String getString() { return string; } public void setString(String string) { this.string = string; } public SerializableObject getObj() { return obj; } public void setObj(SerializableObject obj) { this.obj = obj; } } class SerializableObject implements Serializable { private static final long serialVersionUID = 1L;} 要实现深复制，需要采用流的形式读入当前对象的二进制输入，再写出二进制数据对应的对象。我们接着讨论设计模式，上篇文章我讲完了5种创建型模式，这章开始，我将讲下7种结构型模式：适配器模式、装饰模式、代理模式、外观模式、桥接模式、组合模式、享元模式。其中对象的适配器模式是各种模式的起源，我们看下面的图： 适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。首先，我们来看看类的适配器模式，先看类图： 核心思想就是：有一个Source类，拥有一个方法，待适配，目标接口时Targetable，通过Adapter类，将Source的功能扩展到Targetable里，看代码：[java] view plaincopypublic class Source { public void method1() { System.out.println(&quot;this is original method!&quot;); } }[java] view plaincopypublic interface Targetable { /* 与原类中的方法相同 */ public void method1(); /* 新类的方法 */ public void method2(); }[java] view plaincopypublic class Adapter extends Source implements Targetable { @Override public void method2() { System.out.println(&quot;this is the targetable method!&quot;); } }Adapter类继承Source类，实现Targetable接口，下面是测试类：[java] view plaincopypublic class AdapterTest { public static void main(String[] args) { Targetable target = new Adapter(); target.method1(); target.method2(); } }输出：this is original method!this is the targetable method!这样Targetable接口的实现类就具有了Source类的功能。对象的适配器模式基本思路和类的适配器模式相同，只是将Adapter类作修改，这次不继承Source类，而是持有Source类的实例，以达到解决兼容性的问题。看图： 只需要修改Adapter类的源码即可：[java] view plaincopypublic class Wrapper implements Targetable { private Source source; public Wrapper(Source source){ super(); this.source = source; } @Override public void method2() { System.out.println(&quot;this is the targetable method!&quot;); } @Override public void method1() { source.method1(); } }测试类：[java] view plaincopypublic class AdapterTest { public static void main(String[] args) { Source source = new Source(); Targetable target = new Wrapper(source); target.method1(); target.method2(); } }输出与第一种一样，只是适配的方法不同而已。第三种适配器模式是接口的适配器模式，接口的适配器是这样的：有时我们写的一个接口中有多个抽象方法，当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，因为并不是所有的方法都是我们需要的，有时只需要某一些，此处为了解决这个问题，我们引入了接口的适配器模式，借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法，而我们不和原始的接口打交道，只和该抽象类取得联系，所以我们写一个类，继承该抽象类，重写我们需要的方法就行。看一下类图： 这个很好理解，在实际开发中，我们也常会遇到这种接口中定义了太多的方法，以致于有时我们在一些实现类中并不是都需要。看代码：[java] view plaincopypublic interface Sourceable { public void method1(); public void method2(); }抽象类Wrapper2：[java] view plaincopypublic abstract class Wrapper2 implements Sourceable{ public void method1(){} public void method2(){} }[java] view plaincopypublic class SourceSub1 extends Wrapper2 { public void method1(){ System.out.println(“the sourceable interface’s first Sub1!”); }}[java] view plaincopypublic class SourceSub2 extends Wrapper2 { public void method2(){ System.out.println(“the sourceable interface’s second Sub2!”); }}[java] view plaincopypublic class WrapperTest { public static void main(String[] args) { Sourceable source1 = new SourceSub1(); Sourceable source2 = new SourceSub2(); source1.method1(); source1.method2(); source2.method1(); source2.method2(); } }测试输出：the sourceable interface’s first Sub1!the sourceable interface’s second Sub2!达到了我们的效果！ 讲了这么多，总结一下三种适配器模式的应用场景：类的适配器模式：当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。对象的适配器模式：当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在Wrapper类的方法中，调用实例的方法就行。接口的适配器模式：当不希望实现一个接口中所有的方法时，可以创建一个抽象类Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可。7、装饰模式（Decorator）顾名思义，装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例，关系图如下： Source类是被装饰类，Decorator类是一个装饰类，可以为Source类动态的添加一些功能，代码如下：[java] view plaincopypublic interface Sourceable { public void method();}[java] view plaincopypublic class Source implements Sourceable { @Override public void method() { System.out.println(&quot;the original method!&quot;); } }[java] view plaincopypublic class Decorator implements Sourceable { private Sourceable source; public Decorator(Sourceable source){ super(); this.source = source; } @Override public void method() { System.out.println(&quot;before decorator!&quot;); source.method(); System.out.println(&quot;after decorator!&quot;); } }测试类：[java] view plaincopypublic class DecoratorTest { public static void main(String[] args) { Sourceable source = new Source(); Sourceable obj = new Decorator(source); obj.method(); } }输出：before decorator!the original method!after decorator!装饰器模式的应用场景：1、需要扩展一个类的功能。2、动态的为一个对象增加功能，而且还能动态撤销。（继承不能做到这一点，继承的功能是静态的，不能动态增删。）缺点：产生过多相似的对象，不易排错！8、代理模式（Proxy）其实每个模式名称就表明了该模式的作用，代理模式就是多一个代理类出来，替原对象进行一些操作，比如我们在租房子的时候回去找中介，为什么呢？因为你对该地区房屋的信息掌握的不够全面，希望找一个更熟悉的人去帮你做，此处的代理就是这个意思。再如我们有的时候打官司，我们需要请律师，因为律师在法律方面有专长，可以替我们进行操作，表达我们的想法。先来看看关系图： 根据上文的阐述，代理模式就比较容易的理解了，我们看下代码：[java] view plaincopypublic interface Sourceable { public void method();}[java] view plaincopypublic class Source implements Sourceable { @Override public void method() { System.out.println(&quot;the original method!&quot;); } }[java] view plaincopypublic class Proxy implements Sourceable { private Source source; public Proxy(){ super(); this.source = new Source(); } @Override public void method() { before(); source.method(); atfer(); } private void atfer() { System.out.println(&quot;after proxy!&quot;); } private void before() { System.out.println(&quot;before proxy!&quot;); } }测试类：[java] view plaincopypublic class ProxyTest { public static void main(String[] args) { Sourceable source = new Proxy(); source.method(); } }输出：before proxy!the original method!after proxy!代理模式的应用场景：如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法：1、修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。2、就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。使用代理模式，可以将功能划分的更加清晰，有助于后期维护！9、外观模式（Facade）外观模式是为了解决类与类之家的依赖关系的，像spring一样，可以将类和类之间的关系配置到配置文件中，而外观模式就是将他们的关系放在一个Facade类中，降低了类类之间的耦合度，该模式中没有涉及到接口，看下类图：（我们以一个计算机的启动过程为例） 我们先看下实现类：[java] view plaincopypublic class CPU { public void startup(){ System.out.println(&quot;cpu startup!&quot;); } public void shutdown(){ System.out.println(&quot;cpu shutdown!&quot;); } }[java] view plaincopypublic class Memory { public void startup(){ System.out.println(&quot;memory startup!&quot;); } public void shutdown(){ System.out.println(&quot;memory shutdown!&quot;); } }[java] view plaincopypublic class Disk { public void startup(){ System.out.println(&quot;disk startup!&quot;); } public void shutdown(){ System.out.println(&quot;disk shutdown!&quot;); } }[java] view plaincopypublic class Computer { private CPU cpu; private Memory memory; private Disk disk; public Computer(){ cpu = new CPU(); memory = new Memory(); disk = new Disk(); } public void startup(){ System.out.println(&quot;start the computer!&quot;); cpu.startup(); memory.startup(); disk.startup(); System.out.println(&quot;start computer finished!&quot;); } public void shutdown(){ System.out.println(&quot;begin to close the computer!&quot;); cpu.shutdown(); memory.shutdown(); disk.shutdown(); System.out.println(&quot;computer closed!&quot;); } }User类如下：[java] view plaincopypublic class User { public static void main(String[] args) { Computer computer = new Computer(); computer.startup(); computer.shutdown(); } }输出：start the computer!cpu startup!memory startup!disk startup!start computer finished!begin to close the computer!cpu shutdown!memory shutdown!disk shutdown!computer closed!如果我们没有Computer类，那么，CPU、Memory、Disk他们之间将会相互持有实例，产生关系，这样会造成严重的依赖，修改一个类，可能会带来其他类的修改，这不是我们想要看到的，有了Computer类，他们之间的关系被放在了Computer类里，这样就起到了解耦的作用，这，就是外观模式！10、桥接模式（Bridge）桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化。桥接的用意是：将抽象化与实现化解耦，使得二者可以独立变化，像我们常用的JDBC桥DriverManager一样，JDBC进行连接数据库的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不用动，原因就是JDBC提供统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了。我们来看看关系图： 实现代码：先定义接口：[java] view plaincopypublic interface Sourceable { public void method();}分别定义两个实现类：[java] view plaincopypublic class SourceSub1 implements Sourceable { @Override public void method() { System.out.println(&quot;this is the first sub!&quot;); } }[java] view plaincopypublic class SourceSub2 implements Sourceable { @Override public void method() { System.out.println(&quot;this is the second sub!&quot;); } }定义一个桥，持有Sourceable的一个实例：[java] view plaincopypublic abstract class Bridge { private Sourceable source; public void method(){ source.method(); } public Sourceable getSource() { return source; } public void setSource(Sourceable source) { this.source = source; } }[java] view plaincopypublic class MyBridge extends Bridge { public void method(){ getSource().method(); }}测试类：[java] view plaincopypublic class BridgeTest { public static void main(String[] args) { Bridge bridge = new MyBridge(); /*调用第一个对象*/ Sourceable source1 = new SourceSub1(); bridge.setSource(source1); bridge.method(); /*调用第二个对象*/ Sourceable source2 = new SourceSub2(); bridge.setSource(source2); bridge.method(); } }output：this is the first sub!this is the second sub!这样，就通过对Bridge类的调用，实现了对接口Sourceable的实现类SourceSub1和SourceSub2的调用。接下来我再画个图，大家就应该明白了，因为这个图是我们JDBC连接的原理，有数据库学习基础的，一结合就都懂了。 11、组合模式（Composite）组合模式有时又叫部分-整体模式在处理类似树形结构的问题时比较方便，看看关系图： 直接来看代码：[java] view plaincopypublic class TreeNode { private String name; private TreeNode parent; private Vector&lt;TreeNode&gt; children = new Vector&lt;TreeNode&gt;(); public TreeNode(String name){ this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } public TreeNode getParent() { return parent; } public void setParent(TreeNode parent) { this.parent = parent; } //添加孩子节点 public void add(TreeNode node){ children.add(node); } //删除孩子节点 public void remove(TreeNode node){ children.remove(node); } //取得孩子节点 public Enumeration&lt;TreeNode&gt; getChildren(){ return children.elements(); } }[java] view plaincopypublic class Tree { TreeNode root = null; public Tree(String name) { root = new TreeNode(name); } public static void main(String[] args) { Tree tree = new Tree(&quot;A&quot;); TreeNode nodeB = new TreeNode(&quot;B&quot;); TreeNode nodeC = new TreeNode(&quot;C&quot;); nodeB.add(nodeC); tree.root.add(nodeB); System.out.println(&quot;build the tree finished!&quot;); } }使用场景：将多个对象组合在一起进行操作，常用于表示树形结构中，例如二叉树，数等。12、享元模式（Flyweight）享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。 FlyWeightFactory负责创建和管理享元单元，当一个客户端请求时，工厂需要检查当前对象池中是否有符合条件的对象，如果有，就返回已经存在的对象，如果没有，则创建一个新对象，FlyWeight是超类。一提到共享池，我们很容易联想到Java里面的JDBC连接池，想想每个连接的特点，我们不难总结出：适用于作共享的一些个对象，他们有一些共有的属性，就拿数据库连接池来说，url、driverClassName、username、password及dbname，这些属性对于每个连接来说都是一样的，所以就适合用享元模式来处理，建一个工厂类，将上述类似属性作为内部数据，其它的作为外部数据，在方法调用时，当做参数传进来，这样就节省了空间，减少了实例的数量。看个例子： 看下数据库连接池的代码：[java] view plaincopypublic class ConnectionPool { private Vector&lt;Connection&gt; pool; /*公有属性*/ private String url = &quot;jdbc:mysql://localhost:3306/test&quot;; private String username = &quot;root&quot;; private String password = &quot;root&quot;; private String driverClassName = &quot;com.mysql.jdbc.Driver&quot;; private int poolSize = 100; private static ConnectionPool instance = null; Connection conn = null; /*构造方法，做一些初始化工作*/ private ConnectionPool() { pool = new Vector&lt;Connection&gt;(poolSize); for (int i = 0; i &lt; poolSize; i++) { try { Class.forName(driverClassName); conn = DriverManager.getConnection(url, username, password); pool.add(conn); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } } } /* 返回连接到连接池 */ public synchronized void release() { pool.add(conn); } /* 返回连接池中的一个数据库连接 */ public synchronized Connection getConnection() { if (pool.size() &gt; 0) { Connection conn = pool.get(0); pool.remove(conn); return conn; } else { return null; } } } 通过连接池的管理，实现了数据库连接的共享，不需要每一次都重新创建连接，节省了数据库重新创建的开销，提升了系统的性能！本章讲解了7种结构型模式，因为篇幅的问题，剩下的11种行为型模式，本章是关于设计模式的最后一讲，会讲到第三种设计模式——行为型模式，共11种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。这段时间一直在写关于设计模式的东西，终于写到一半了，写博文是个很费时间的东西，因为我得为读者负责，不论是图还是代码还是表述，都希望能尽量写清楚，以便读者理解，我想不论是我还是读者，都希望看到高质量的博文出来，从我本人出发，我会一直坚持下去，不断更新，源源动力来自于读者朋友们的不断支持，我会尽自己的努力，写好每一篇文章！希望大家能不断给出意见和建议，共同打造完美的博文！ 先来张图，看看这11中模式的关系：第一类：通过父类与子类的关系进行实现。第二类：两个类之间。第三类：类的状态。第四类：通过中间类 13、策略模式（strategy）策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。需要设计一个接口，为一系列实现类提供统一的方法，多个实现类实现该接口，设计一个抽象类（可有可无，属于辅助类），提供辅助函数，关系图如下： 图中ICalculator提供同意的方法，AbstractCalculator是辅助类，提供辅助方法，接下来，依次实现下每个类：首先统一接口：[java] view plaincopypublic interface ICalculator { public int calculate(String exp);}辅助类：[java] view plaincopypublic abstract class AbstractCalculator { public int[] split(String exp,String opt){ String array[] = exp.split(opt); int arrayInt[] = new int[2]; arrayInt[0] = Integer.parseInt(array[0]); arrayInt[1] = Integer.parseInt(array[1]); return arrayInt; } }三个实现类：[java] view plaincopypublic class Plus extends AbstractCalculator implements ICalculator { @Override public int calculate(String exp) { int arrayInt[] = split(exp,&quot;\\+&quot;); return arrayInt[0]+arrayInt[1]; } }[java] view plaincopypublic class Minus extends AbstractCalculator implements ICalculator { @Override public int calculate(String exp) { int arrayInt[] = split(exp,&quot;-&quot;); return arrayInt[0]-arrayInt[1]; } }[java] view plaincopypublic class Multiply extends AbstractCalculator implements ICalculator { @Override public int calculate(String exp) { int arrayInt[] = split(exp,&quot;\\*&quot;); return arrayInt[0]*arrayInt[1]; } }简单的测试类：[java] view plaincopypublic class StrategyTest { public static void main(String[] args) { String exp = &quot;2+8&quot;; ICalculator cal = new Plus(); int result = cal.calculate(exp); System.out.println(result); } }输出：10策略模式的决定权在用户，系统本身提供不同算法的实现，新增或者删除算法，对各种算法做封装。因此，策略模式多用在算法决策系统中，外部用户只需要决定用哪个算法即可。14、模板方法模式（Template Method）解释一下模板方法模式，就是指：一个抽象类中，有一个主方法，再定义1…n个方法，可以是抽象的，也可以是实际的方法，定义一个类，继承该抽象类，重写抽象方法，通过调用抽象类，实现对子类的调用，先看个关系图： 就是在AbstractCalculator类中定义一个主方法calculate，calculate()调用spilt()等，Plus和Minus分别继承AbstractCalculator类，通过对AbstractCalculator的调用实现对子类的调用，看下面的例子：[java] view plaincopypublic abstract class AbstractCalculator { /*主方法，实现对本类其它方法的调用*/ public final int calculate(String exp,String opt){ int array[] = split(exp,opt); return calculate(array[0],array[1]); } /*被子类重写的方法*/ abstract public int calculate(int num1,int num2); public int[] split(String exp,String opt){ String array[] = exp.split(opt); int arrayInt[] = new int[2]; arrayInt[0] = Integer.parseInt(array[0]); arrayInt[1] = Integer.parseInt(array[1]); return arrayInt; } }[java] view plaincopypublic class Plus extends AbstractCalculator { @Override public int calculate(int num1,int num2) { return num1 + num2; } }测试类：[java] view plaincopypublic class StrategyTest { public static void main(String[] args) { String exp = &quot;8+8&quot;; AbstractCalculator cal = new Plus(); int result = cal.calculate(exp, &quot;\\+&quot;); System.out.println(result); } }我跟踪下这个小程序的执行过程：首先将exp和”\+”做参数，调用AbstractCalculator类里的calculate(String,String)方法，在calculate(String,String)里调用同类的split()，之后再调用calculate(int ,int)方法，从这个方法进入到子类中，执行完return num1 + num2后，将值返回到AbstractCalculator类，赋给result，打印出来。正好验证了我们开头的思路。15、观察者模式（Observer）包括这个模式在内的接下来的四个模式，都是类和类之间的关系，不涉及到继承，学的时候应该 记得归纳，记得本文最开始的那个图。观察者模式很好理解，类似于邮件订阅和RSS订阅，当我们浏览一些博客或wiki时，经常会看到RSS图标，就这的意思是，当你订阅了该文章，如果后续有更新，会及时通知你。其实，简单来讲就一句话：当一个对象变化时，其它依赖该对象的对象都会收到通知，并且随着变化！对象之间是一种一对多的关系。先来看看关系图： 我解释下这些类的作用：MySubject类就是我们的主对象，Observer1和Observer2是依赖于MySubject的对象，当MySubject变化时，Observer1和Observer2必然变化。AbstractSubject类中定义着需要监控的对象列表，可以对其进行修改：增加或删除被监控对象，且当MySubject变化时，负责通知在列表内存在的对象。我们看实现代码：一个Observer接口：[java] view plaincopypublic interface Observer { public void update();}两个实现类：[java] view plaincopypublic class Observer1 implements Observer { @Override public void update() { System.out.println(&quot;observer1 has received!&quot;); } }[java] view plaincopypublic class Observer2 implements Observer { @Override public void update() { System.out.println(&quot;observer2 has received!&quot;); } }Subject接口及实现类：[java] view plaincopypublic interface Subject { /*增加观察者*/ public void add(Observer observer); /*删除观察者*/ public void del(Observer observer); /*通知所有的观察者*/ public void notifyObservers(); /*自身的操作*/ public void operation(); }[java] view plaincopypublic abstract class AbstractSubject implements Subject { private Vector&lt;Observer&gt; vector = new Vector&lt;Observer&gt;(); @Override public void add(Observer observer) { vector.add(observer); } @Override public void del(Observer observer) { vector.remove(observer); } @Override public void notifyObservers() { Enumeration&lt;Observer&gt; enumo = vector.elements(); while(enumo.hasMoreElements()){ enumo.nextElement().update(); } } }[java] view plaincopypublic class MySubject extends AbstractSubject { @Override public void operation() { System.out.println(&quot;update self!&quot;); notifyObservers(); } } 测试类：[java] view plaincopypublic class ObserverTest { public static void main(String[] args) { Subject sub = new MySubject(); sub.add(new Observer1()); sub.add(new Observer2()); sub.operation(); } }输出：update self!observer1 has received!observer2 has received! 这些东西，其实不难，只是有些抽象，不太容易整体理解，建议读者：根据关系图，新建项目，自己写代码（或者参考我的代码）,按照总体思路走一遍，这样才能体会它的思想，理解起来容易！16、迭代子模式（Iterator）顾名思义，迭代器模式就是顺序访问聚集中的对象，一般来说，集合中非常常见，如果对集合类比较熟悉的话，理解本模式会十分轻松。这句话包含两层意思：一是需要遍历的对象，即聚集对象，二是迭代器对象，用于对聚集对象进行遍历访问。我们看下关系图： 这个思路和我们常用的一模一样，MyCollection中定义了集合的一些操作，MyIterator中定义了一系列迭代操作，且持有Collection实例，我们来看看实现代码：两个接口：[java] view plaincopypublic interface Collection { public Iterator iterator(); /*取得集合元素*/ public Object get(int i); /*取得集合大小*/ public int size(); }[java] view plaincopypublic interface Iterator { //前移 public Object previous(); //后移 public Object next(); public boolean hasNext(); //取得第一个元素 public Object first(); }两个实现：[java] view plaincopypublic class MyCollection implements Collection { public String string[] = {&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;}; @Override public Iterator iterator() { return new MyIterator(this); } @Override public Object get(int i) { return string[i]; } @Override public int size() { return string.length; } }[java] view plaincopypublic class MyIterator implements Iterator { private Collection collection; private int pos = -1; public MyIterator(Collection collection){ this.collection = collection; } @Override public Object previous() { if(pos &gt; 0){ pos--; } return collection.get(pos); } @Override public Object next() { if(pos&lt;collection.size()-1){ pos++; } return collection.get(pos); } @Override public boolean hasNext() { if(pos&lt;collection.size()-1){ return true; }else{ return false; } } @Override public Object first() { pos = 0; return collection.get(pos); } }测试类：[java] view plaincopypublic class Test { public static void main(String[] args) { Collection collection = new MyCollection(); Iterator it = collection.iterator(); while(it.hasNext()){ System.out.println(it.next()); } } }输出：A B C D E此处我们貌似模拟了一个集合类的过程，感觉是不是很爽？其实JDK中各个类也都是这些基本的东西，加一些设计模式，再加一些优化放到一起的，只要我们把这些东西学会了，掌握好了，我们也可以写出自己的集合类，甚至框架！17、责任链模式（Chain of Responsibility）接下来我们将要谈谈责任链模式，有多个对象，每个对象持有对下一个对象的引用，这样就会形成一条链，请求在这条链上传递，直到某一对象决定处理该请求。但是发出者并不清楚到底最终那个对象会处理该请求，所以，责任链模式可以实现，在隐瞒客户端的情况下，对系统进行动态的调整。先看看关系图： Abstracthandler类提供了get和set方法，方便MyHandle类设置和修改引用对象，MyHandle类是核心，实例化后生成一系列相互持有的对象，构成一条链。[java] view plaincopypublic interface Handler { public void operator();}[java] view plaincopypublic abstract class AbstractHandler { private Handler handler; public Handler getHandler() { return handler; } public void setHandler(Handler handler) { this.handler = handler; } }[java] view plaincopypublic class MyHandler extends AbstractHandler implements Handler { private String name; public MyHandler(String name) { this.name = name; } @Override public void operator() { System.out.println(name+&quot;deal!&quot;); if(getHandler()!=null){ getHandler().operator(); } } }[java] view plaincopypublic class Test { public static void main(String[] args) { MyHandler h1 = new MyHandler(&quot;h1&quot;); MyHandler h2 = new MyHandler(&quot;h2&quot;); MyHandler h3 = new MyHandler(&quot;h3&quot;); h1.setHandler(h2); h2.setHandler(h3); h1.operator(); } }输出：h1deal!h2deal!h3deal!此处强调一点就是，链接上的请求可以是一条链，可以是一个树，还可以是一个环，模式本身不约束这个，需要我们自己去实现，同时，在一个时刻，命令只允许由一个对象传给另一个对象，而不允许传给多个对象。 18、命令模式（Command）命令模式很好理解，举个例子，司令员下令让士兵去干件事情，从整个事情的角度来考虑，司令员的作用是，发出口令，口令经过传递，传到了士兵耳朵里，士兵去执行。这个过程好在，三者相互解耦，任何一方都不用去依赖其他人，只需要做好自己的事儿就行，司令员要的是结果，不会去关注到底士兵是怎么实现的。我们看看关系图： Invoker是调用者（司令员），Receiver是被调用者（士兵），MyCommand是命令，实现了Command接口，持有接收对象，看实现代码：[java] view plaincopypublic interface Command { public void exe();}[java] view plaincopypublic class MyCommand implements Command { private Receiver receiver; public MyCommand(Receiver receiver) { this.receiver = receiver; } @Override public void exe() { receiver.action(); } }[java] view plaincopypublic class Receiver { public void action(){ System.out.println(“command received!”); }}[java] view plaincopypublic class Invoker { private Command command; public Invoker(Command command) { this.command = command; } public void action(){ command.exe(); } }[java] view plaincopypublic class Test { public static void main(String[] args) { Receiver receiver = new Receiver(); Command cmd = new MyCommand(receiver); Invoker invoker = new Invoker(cmd); invoker.action(); } }输出：command received!这个很哈理解，命令模式的目的就是达到命令的发出者和执行者之间解耦，实现请求和执行分开，熟悉Struts的同学应该知道，Struts其实就是一种将请求和呈现分离的技术，其中必然涉及命令模式的思想！其实每个设计模式都是很重要的一种思想，看上去很熟，其实是因为我们在学到的东西中都有涉及，尽管有时我们并不知道，其实在Java本身的设计之中处处都有体现，像AWT、JDBC、集合类、IO管道或者是Web框架，里面设计模式无处不在。因为我们篇幅有限，很难讲每一个设计模式都讲的很详细，不过我会尽我所能，尽量在有限的空间和篇幅内，把意思写清楚了，更好让大家明白。本章不出意外的话，应该是设计模式最后一讲了，首先还是上一下上篇开头的那个图： 本章讲讲第三类和第四类。19、备忘录模式（Memento）主要目的是保存一个对象的某个状态，以便在适当的时候恢复对象，个人觉得叫备份模式更形象些，通俗的讲下：假设有原始类A，A中有各种属性，A可以决定需要备份的属性，备忘录类B是用来存储A的一些内部状态，类C呢，就是一个用来存储备忘录的，且只能存储，不能修改等操作。做个图来分析一下： Original类是原始类，里面有需要保存的属性value及创建一个备忘录类，用来保存value值。Memento类是备忘录类，Storage类是存储备忘录的类，持有Memento类的实例，该模式很好理解。直接看源码：[java] view plaincopypublic class Original { private String value; public String getValue() { return value; } public void setValue(String value) { this.value = value; } public Original(String value) { this.value = value; } public Memento createMemento(){ return new Memento(value); } public void restoreMemento(Memento memento){ this.value = memento.getValue(); } }[java] view plaincopypublic class Memento { private String value; public Memento(String value) { this.value = value; } public String getValue() { return value; } public void setValue(String value) { this.value = value; } }[java] view plaincopypublic class Storage { private Memento memento; public Storage(Memento memento) { this.memento = memento; } public Memento getMemento() { return memento; } public void setMemento(Memento memento) { this.memento = memento; } }测试类：[java] view plaincopypublic class Test { public static void main(String[] args) { // 创建原始类 Original origi = new Original(&quot;egg&quot;); // 创建备忘录 Storage storage = new Storage(origi.createMemento()); // 修改原始类的状态 System.out.println(&quot;初始化状态为：&quot; + origi.getValue()); origi.setValue(&quot;niu&quot;); System.out.println(&quot;修改后的状态为：&quot; + origi.getValue()); // 回复原始类的状态 origi.restoreMemento(storage.getMemento()); System.out.println(&quot;恢复后的状态为：&quot; + origi.getValue()); } }输出：初始化状态为：egg修改后的状态为：niu恢复后的状态为：egg简单描述下：新建原始类时，value被初始化为egg，后经过修改，将value的值置为niu，最后倒数第二行进行恢复状态，结果成功恢复了。其实我觉得这个模式叫“备份-恢复”模式最形象。20、状态模式（State）核心思想就是：当对象的状态改变时，同时改变其行为，很好理解！就拿QQ来说，有几种状态，在线、隐身、忙碌等，每个状态对应不同的操作，而且你的好友也能看到你的状态，所以，状态模式就两点：1、可以通过改变状态来获得不同的行为。2、你的好友能同时看到你的变化。看图： State类是个状态类，Context类可以实现切换，我们来看看代码： [java] view plaincopypackage com.xtfggef.dp.state; /** 状态类的核心类 2012-12-1 @author erqing */public class State { private String value; public String getValue() { return value; } public void setValue(String value) { this.value = value; } public void method1(){ System.out.println(&quot;execute the first opt!&quot;); } public void method2(){ System.out.println(&quot;execute the second opt!&quot;); }}[java] view plaincopypackage com.xtfggef.dp.state; /** 状态模式的切换类 2012-12-1 @author erqing */public class Context { private State state; public Context(State state) { this.state = state; } public State getState() { return state; } public void setState(State state) { this.state = state; } public void method() { if (state.getValue().equals(&quot;state1&quot;)) { state.method1(); } else if (state.getValue().equals(&quot;state2&quot;)) { state.method2(); } }}测试类： [java] view plaincopypublic class Test { public static void main(String[] args) { State state = new State(); Context context = new Context(state); //设置第一种状态 state.setValue(&quot;state1&quot;); context.method(); //设置第二种状态 state.setValue(&quot;state2&quot;); context.method(); } }输出： execute the first opt!execute the second opt!根据这个特性，状态模式在日常开发中用的挺多的，尤其是做网站的时候，我们有时希望根据对象的某一属性，区别开他们的一些功能，比如说简单的权限控制等。21、访问者模式（Visitor）访问者模式把数据结构和作用于结构上的操作解耦合，使得操作集合可相对自由地演化。访问者模式适用于数据结构相对稳定算法又易变化的系统。因为访问者模式使得算法操作增加变得容易。若系统数据结构对象易于变化，经常有新的数据对象增加进来，则不适合使用访问者模式。访问者模式的优点是增加操作很容易，因为增加操作意味着增加新的访问者。访问者模式将有关行为集中到一个访问者对象中，其改变不影响系统数据结构。其缺点就是增加新的数据结构很困难。—— From 百科简单来说，访问者模式就是一种分离对象数据结构与行为的方法，通过这种分离，可达到为一个被访问者动态添加新的操作而无需做其它的修改的效果。简单关系图： 来看看原码：一个Visitor类，存放要访问的对象， [java] view plaincopypublic interface Visitor { public void visit(Subject sub);}[java] view plaincopypublic class MyVisitor implements Visitor { @Override public void visit(Subject sub) { System.out.println(&quot;visit the subject：&quot;+sub.getSubject()); } }Subject类，accept方法，接受将要访问它的对象，getSubject()获取将要被访问的属性，[java] view plaincopypublic interface Subject { public void accept(Visitor visitor); public String getSubject();}[java] view plaincopypublic class MySubject implements Subject { @Override public void accept(Visitor visitor) { visitor.visit(this); } @Override public String getSubject() { return &quot;love&quot;; } }测试： [java] view plaincopypublic class Test { public static void main(String[] args) { Visitor visitor = new MyVisitor(); Subject sub = new MySubject(); sub.accept(visitor); } }输出：visit the subject：love 该模式适用场景：如果我们想为一个现有的类增加新功能，不得不考虑几个事情：1、新功能会不会与现有功能出现兼容性问题？2、以后会不会再需要添加？3、如果类不允许修改代码怎么办？面对这些问题，最好的解决方法就是使用访问者模式，访问者模式适用于数据结构相对稳定的系统，把数据结构和算法解耦，22、中介者模式（Mediator）中介者模式也是用来降低类类之间的耦合的，因为如果类类之间有依赖关系的话，不利于功能的拓展和维护，因为只要修改一个对象，其它关联的对象都得进行修改。如果使用中介者模式，只需关心和Mediator类的关系，具体类类之间的关系及调度交给Mediator就行，这有点像spring容器的作用。先看看图： User类统一接口，User1和User2分别是不同的对象，二者之间有关联，如果不采用中介者模式，则需要二者相互持有引用，这样二者的耦合度很高，为了解耦，引入了Mediator类，提供统一接口，MyMediator为其实现类，里面持有User1和User2的实例，用来实现对User1和User2的控制。这样User1和User2两个对象相互独立，他们只需要保持好和Mediator之间的关系就行，剩下的全由MyMediator类来维护！基本实现： [java] view plaincopypublic interface Mediator { public void createMediator(); public void workAll();}[java] view plaincopypublic class MyMediator implements Mediator { private User user1; private User user2; public User getUser1() { return user1; } public User getUser2() { return user2; } @Override public void createMediator() { user1 = new User1(this); user2 = new User2(this); } @Override public void workAll() { user1.work(); user2.work(); } }[java] view plaincopypublic abstract class User { private Mediator mediator; public Mediator getMediator(){ return mediator; } public User(Mediator mediator) { this.mediator = mediator; } public abstract void work(); }[java] view plaincopypublic class User1 extends User { public User1(Mediator mediator){ super(mediator); } @Override public void work() { System.out.println(&quot;user1 exe!&quot;); } }[java] view plaincopypublic class User2 extends User { public User2(Mediator mediator){ super(mediator); } @Override public void work() { System.out.println(&quot;user2 exe!&quot;); } }测试类： [java] view plaincopypublic class Test { public static void main(String[] args) { Mediator mediator = new MyMediator(); mediator.createMediator(); mediator.workAll(); } }输出： user1 exe!user2 exe!23、解释器模式（Interpreter）解释器模式是我们暂时的最后一讲，一般主要应用在OOP开发中的编译器的开发中，所以适用面比较窄。 Context类是一个上下文环境类，Plus和Minus分别是用来计算的实现，代码如下： [java] view plaincopypublic interface Expression { public int interpret(Context context);}[java] view plaincopypublic class Plus implements Expression { @Override public int interpret(Context context) { return context.getNum1()+context.getNum2(); } }[java] view plaincopypublic class Minus implements Expression { @Override public int interpret(Context context) { return context.getNum1()-context.getNum2(); } }[java] view plaincopypublic class Context { private int num1; private int num2; public Context(int num1, int num2) { this.num1 = num1; this.num2 = num2; } public int getNum1() { return num1; } public void setNum1(int num1) { this.num1 = num1; } public int getNum2() { return num2; } public void setNum2(int num2) { this.num2 = num2; } }[java] view plaincopypublic class Test { public static void main(String[] args) { // 计算9+2-8的值 int result = new Minus().interpret((new Context(new Plus() .interpret(new Context(9, 2)), 8))); System.out.println(result); } }最后输出正确的结果：3。 基本就这样，解释器模式用来做各种各样的解释器，如正则表达式等的解释器等等！设计模式基本就这么大概讲完了，总体感觉有点简略，的确，这么点儿篇幅，不足以对整个23种设计模式做全面的阐述，此处读者可将它作为一个理论基础去学习，通过这四篇博文，先基本有个概念，虽然我讲的有些简单，但基本都能说明问题及他们的特点，如果对哪一个感兴趣，可以继续深入研究.]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发四]]></title>
    <url>%2F2017%2F09%2F05%2F%E5%B9%B6%E5%8F%91%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[Java高并发，如何解决，什么方式解决对于我们开发的网站，如果网站的访问量非常大的话，那么我们就需要考虑相关的并发访问问题了。而并发问题是绝大部分的程序员头疼的问题， 但话又说回来了，既然逃避不掉，那我们就坦然面对吧~今天就让我们一起来研究一下常见的并发和同步吧。 为了更好的理解并发和同步，我们需要先明白两个重要的概念:同步和异步 1、同步和异步的区别和联系 所谓同步，可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是出于阻塞的，只有接收到 返回的值或消息后才往下执行其它的命令。 异步，执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回 值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。 同步在一定程度上可以看做是单线程，这个线程请求一个方法后就待这个方法给他回复，否则他不往下执行(死心眼)。 异步在一定程度上可以看做是多线程的(废话，一个线程怎么叫异步)，请求一个方法后，就不管了，继续执行其他的方法。 同步就是一件事，一件事情一件事的做。 异步就是，做一件事情，不引响做其他事情。 例如：吃饭和说话，只能一件事一件事的来，因为只有一张嘴。 但吃饭和听音乐是异步的，因为，听音乐并不引响我们吃饭。 对于Java程序员而言，我们会经常听到同步关键字synchronized，假如这个同步的监视对象是类的话，那么如果当一个对象 访问类里面的同步方法的话，那么其它的对象如果想要继续访问类里面的这个同步方法的话，就会进入阻塞，只有等前一个对象 执行完该同步方法后当前对象才能够继续执行该方法。这就是同步。相反，如果方法前没有同步关键字修饰的话，那么不同的对象 可以在同一时间访问同一个方法，这就是异步。 在补充一下(脏数据和不可重复读的相关概念): 脏数据 脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是脏数据(Dirty Data)，依据脏数据所做的操作可能是不正确的。 不可重复读 不可重复读是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读 2、如何处理并发和同步 今天讲的如何处理并发和同同步问题主要是通过锁机制。 我们需要明白，锁机制有两个层面。 一种是代码层次上的，如java中的同步锁，典型的就是同步关键字synchronized，这里我不在做过多的讲解， 感兴趣的可以参考:http://www.cnblogs.com/xiohao/p/4151408.html 另外一种是数据库层次上的，比较典型的就是悲观锁和乐观锁。这里我们重点讲解的就是悲观锁（传统的物理锁）和乐观锁。 悲观锁(Pessimistic Locking): 悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自 外部系统的事务处理）修改持保守态度，因此， 在整个数据处理过程中，将数据处于锁定状态。 悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能 真正保证数据访问的排他性，否则，即使在本系统 中实现了加锁机制，也无法保证外部系 统不会修改数据）。 一个典型的倚赖数据库的悲观锁调用： select * from account where name=”Erica” for update 这条 sql 语句锁定了 account 表中所有符合检索条件（ name=”Erica” ）的记录。 本次事务提交之前（事务提交时会释放事务过程中的锁），外界无法修改这些记录。 Hibernate 的悲观锁，也是基于数据库的锁机制实现。 下面的代码实现了对查询记录的加锁： String hqlStr =&quot;from TUser as user where user.name=&apos;Erica&apos;&quot;; Query query = session.createQuery(hqlStr); query.setLockMode(&quot;user&quot;,LockMode.UPGRADE); // 加锁 List userList = query.list();// 执行查询，获取数据 query.setLockMode 对查询语句中，特定别名所对应的记录进行加锁（我们为 TUser 类指定了一个别名 “user” ），这里也就是对 返回的所有 user 记录进行加锁。 观察运行期 Hibernate 生成的 SQL 语句： select tuser0_.id as id, tuser0_.name as name, tuser0_.group_id as group_id, tuser0_.user_type as user_type, tuser0_.sex as sex from t_user tuser0_ where (tuser0_.name=&apos;Erica&apos; ) for update 这里 Hibernate 通过使用数据库的 for update 子句实现了悲观锁机制。 Hibernate 的加锁模式有： Ø LockMode.NONE ： 无锁机制。 Ø LockMode.WRITE ： Hibernate 在 Insert 和 Update 记录的时候会自动获取 Ø LockMode.READ ： Hibernate 在读取记录的时候会自动获取。 以上这三种锁机制一般由 Hibernate 内部使用，如 Hibernate 为了保证 Update 过程中对象不会被外界修改，会在 save 方法实现中自动为目标对象加上 WRITE 锁。 Ø LockMode.UPGRADE ：利用数据库的 for update 子句加锁。 Ø LockMode. UPGRADE_NOWAIT ： Oracle 的特定实现，利用 Oracle 的 for update nowait 子句实现加锁。 上面这两种锁机制是我们在应用层较为常用的，加锁一般通过以下方法实现： Criteria.setLockMode Query.setLockMode Session.lock 注意，只有在查询开始之前（也就是 Hiberate 生成 SQL 之前）设定加锁，才会 真正通过数据库的锁机制进行加锁处理，否则，数据已经通过不包含 for update 子句的 Select SQL 加载进来，所谓数据库加锁也就无从谈起。 为了更好的理解select... for update的锁表的过程，本人将要以mysql为例，进行相应的讲解 1、要测试锁定的状况，可以利用MySQL的Command Mode ，开二个视窗来做测试。 表的基本结构如下: 表中内容如下: 开启两个测试窗口，在其中一个窗口执行select * from ta for update0 然后在另外一个窗口执行update操作如下图: 等到一个窗口commit后的图片如下: 到这里，悲观锁机制你应该了解一些了吧~ 需要注意的是for update要放到mysql的事务中，即begin和commit中，否者不起作用。 至于是锁住整个表还是锁住选中的行，请参考: http://www.cnblogs.com/xiohao/p/4385768.html 至于hibernate中的悲观锁使用起来比较简单，这里就不写demo了~感兴趣的自己查一下就ok了~ 乐观锁(Optimistic Locking): 相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依 靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之 而来的就是数据库 性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。 如一个金融系统，当某个操作员读取用户的数据，并在读出的用户数 据的基础上进 行修改时（如更改用户帐户余额），如果采用悲观锁机制，也就意味着整个操作过 程中（从操作员读出数据、开始修改直至提交修改结果的全 过程，甚至还包括操作 员中途去煮咖啡的时间），数据库记录始终处于加锁状态，可以想见，如果面对几 百上千个并发，这样的情况将导致怎样的后果。 乐 观锁机制在一定程度上解决了这个问题。 乐观锁，大多是基于数据版本 Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通 过为数据库表增加一个 “version” 字段来 实现。 读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提 交数据的版本数据与数据 库表对应记录的当前版本信息进行比对，如果提交的数据 版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。对于上面修改用户帐户信息 的例子而言，假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。操作员 A 此时将其读出 （ version=1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。 2 在操作员 A 操作的过程中，操作员 B 也读入此用户信息（ version=1 ），并 从其帐 户余额中扣除 $20 （ $100-$20 ）。 3 操作员 A 完成了修改工作，将数据版本号加一（ version=2 ），连同帐户扣 除后余额（ balance=$50 ），提交 至数据库更新，此时由于提交数据版本大 于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。 4 操作员 B 完成了操作，也将版本号加一 （ version=2 ）试图向数据库提交数 据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的 数据版本号为 2 ，数据库记录当前版 本也为 2 ，不满足 “ 提交版本必须大于记 录当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。 这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作 员 A 的操作结果的可能。 从上面的例子可以看出，乐观锁机制避免了长事务中的数据库加锁开销（操作员 A 和操作员 B 操作过程中，都没有对数据库数据加锁），大大提升了大并发量下的系 统整体性能表现。 需要注意的是，乐观锁机制往往基于系统中的数据存储 逻辑，因此也具备一定的局 限性，如在上例中，由于乐观锁机制是在我们的系统中实现，来自外部系统的用户 余额更新操作不受我们系统的控制，因此可能 会造成脏数据被更新到数据库中。在 系统设计阶段，我们应该充分考虑到这些情况出现的可能性，并进行相应调整（如 将乐观锁策略在数据库存储过程中实 现，对外只开放基于此存储过程的数据更新途 径，而不是将数据库表直接对外公开）。 Hibernate 在其数据访问引擎中内置了乐观锁实现。如果不用考虑外 部系统对数 据库的更新操作，利用 Hibernate 提供的透明化乐观锁实现，将大大提升我们的 生产力。 User.hbm.xml 复制代码&lt;?xml version=”1.0”?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC “-//Hibernate/Hibernate Mapping DTD 3.0//EN” “http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&quot;&gt; &lt;class name=&quot;User&quot; table=&quot;user&quot; optimistic-lock=&quot;version&quot; &gt; &lt;id name=&quot;id&quot;&gt; &lt;generator class=&quot;native&quot; /&gt; &lt;/id&gt; &lt;!--version标签必须跟在id标签后面--&gt; &lt;version column=&quot;version&quot; name=&quot;version&quot; /&gt; &lt;property name=&quot;userName&quot;/&gt; &lt;property name=&quot;password&quot;/&gt; &lt;/class&gt; 复制代码注意 version 节点必须出现在 ID 节点之后。这里我们声明了一个 version 属性，用于存放用户的版本信息，保存在 User 表的version中optimistic-lock 属性有如下可选取值：Ø none无乐观锁Ø version通过版本机制实现乐观锁Ø dirty通过检查发生变动过的属性实现乐观锁Ø all通过检查所有属性实现乐观锁其中通过 version 实现的乐观锁机制是 Hibernate 官方推荐的乐观锁实现，同时也是 Hibernate 中，目前唯一在数据对象脱离 Session 发生修改的情况下依然有效的锁机制。因此，一般情况下，我们都选择 version 方式作为 Hibernate 乐观锁实现机制。 2 ． 配置文件hibernate.cfg.xml和UserTest测试类 hibernate.cfg.xml 复制代码&lt;!DOCTYPE hibernate-configuration PUBLIC “-//Hibernate/Hibernate Configuration DTD 3.0//EN” “http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd&quot;&gt; &lt;!-- 指定数据库方言 如果使用jbpm的话，数据库方言只能是InnoDB--&gt; &lt;property name=&quot;dialect&quot;&gt;org.hibernate.dialect.MySQL5InnoDBDialect&lt;/property&gt; &lt;!-- 根据需要自动创建数据表 --&gt; &lt;property name=&quot;hbm2ddl.auto&quot;&gt;update&lt;/property&gt; &lt;!-- 显示Hibernate持久化操作所生成的SQL --&gt; &lt;property name=&quot;show_sql&quot;&gt;true&lt;/property&gt; &lt;!-- 将SQL脚本进行格式化后再输出 --&gt; &lt;property name=&quot;format_sql&quot;&gt;false&lt;/property&gt; &lt;property name=&quot;current_session_context_class&quot;&gt;thread&lt;/property&gt; &lt;!-- 导入映射配置 --&gt; &lt;property name=&quot;connection.url&quot;&gt;jdbc:mysql:///user&lt;/property&gt; &lt;property name=&quot;connection.username&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;connection.password&quot;&gt;123456&lt;/property&gt; &lt;property name=&quot;connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;mapping resource=&quot;com/xiaohao/test/User.hbm.xml&quot; /&gt; 复制代码UserTest.java 复制代码package com.xiaohao.test; import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration; public class UserTest { public static void main(String[] args) { Configuration conf=new Configuration().configure(); SessionFactory sf=conf.buildSessionFactory(); Session session=sf.getCurrentSession(); Transaction tx=session.beginTransaction();// User user=new User(“小浩”,”英雄”);// session.save(user);// session.createSQLQuery(“insert into user(userName,password) value(‘张英雄16’,’123’)”)// .executeUpdate(); User user=(User) session.get(User.class, 1); user.setUserName(“221”);// session.save(user); System.out.println(&quot;恭喜您，用户的数据插入成功了哦~~&quot;); tx.commit(); } }复制代码每次对 TUser 进行更新的时候，我们可以发现，数据库中的 version 都在递增。 下面我们将要通过乐观锁来实现一下并发和同步的测试用例: 这里需要使用两个测试类，分别运行在不同的虚拟机上面，以此来模拟多个用户同时操作一张表,同时其中一个测试类需要模拟长事务 UserTest.java 复制代码package com.xiaohao.test; import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration; public class UserTest { public static void main(String[] args) { Configuration conf=new Configuration().configure(); SessionFactory sf=conf.buildSessionFactory(); Session session=sf.openSession();// Session session2=sf.openSession(); User user=(User) session.createQuery(“ from User user where user=5”).uniqueResult();// User user2=(User) session.createQuery(“ from User user where user=5”).uniqueResult(); System.out.println(user.getVersion());// System.out.println(user2.getVersion()); Transaction tx=session.beginTransaction(); user.setUserName(“101”); tx.commit(); System.out.println(user.getVersion()); // System.out.println(user2.getVersion());// System.out.println(user.getVersion()==user2.getVersion());// Transaction tx2=session2.beginTransaction();// user2.setUserName(“4468”);// tx2.commit(); } }复制代码 UserTest2.java 复制代码package com.xiaohao.test; import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration; public class UserTest2 { public static void main(String[] args) throws InterruptedException { Configuration conf=new Configuration().configure(); SessionFactory sf=conf.buildSessionFactory(); Session session=sf.openSession();// Session session2=sf.openSession(); User user=(User) session.createQuery(“ from User user where user=5”).uniqueResult(); Thread.sleep(10000);// User user2=(User) session.createQuery(“ from User user where user=5”).uniqueResult(); System.out.println(user.getVersion());// System.out.println(user2.getVersion()); Transaction tx=session.beginTransaction(); user.setUserName(“100”); tx.commit(); System.out.println(user.getVersion()); // System.out.println(user2.getVersion());// System.out.println(user.getVersion()==user2.getVersion());// Transaction tx2=session2.beginTransaction();// user2.setUserName(“4468”);// tx2.commit(); } }复制代码 操作流程及简单讲解: 首先启动UserTest2.java测试类，在执行到Thread.sleep(10000);这条语句的时候，当前线程会进入睡眠状态。在10秒钟之内 启动UserTest这个类，在到达10秒的时候，我们将会在UserTest.java中抛出下面的异常: 复制代码Exception in thread “main” org.hibernate.StaleObjectStateException: Row was updated or deleted by another transaction (or unsaved-value mapping was incorrect): [com.xiaohao.test.User#5] at org.hibernate.persister.entity.AbstractEntityPersister.check(AbstractEntityPersister.java:1932) at org.hibernate.persister.entity.AbstractEntityPersister.update(AbstractEntityPersister.java:2576) at org.hibernate.persister.entity.AbstractEntityPersister.updateOrInsert(AbstractEntityPersister.java:2476) at org.hibernate.persister.entity.AbstractEntityPersister.update(AbstractEntityPersister.java:2803) at org.hibernate.action.EntityUpdateAction.execute(EntityUpdateAction.java:113) at org.hibernate.engine.ActionQueue.execute(ActionQueue.java:273) at org.hibernate.engine.ActionQueue.executeActions(ActionQueue.java:265) at org.hibernate.engine.ActionQueue.executeActions(ActionQueue.java:185) at org.hibernate.event.def.AbstractFlushingEventListener.performExecutions(AbstractFlushingEventListener.java:321) at org.hibernate.event.def.DefaultFlushEventListener.onFlush(DefaultFlushEventListener.java:51) at org.hibernate.impl.SessionImpl.flush(SessionImpl.java:1216) at org.hibernate.impl.SessionImpl.managedFlush(SessionImpl.java:383) at org.hibernate.transaction.JDBCTransaction.commit(JDBCTransaction.java:133) at com.xiaohao.test.UserTest2.main(UserTest2.java:21)复制代码 UserTest2代码将在 tx.commit() 处抛出 StaleObjectStateException 异 常，并指出版本检查失败，当前事务正在试图提交一个过期数据。通过捕捉这个异常，我 们就可以在乐观锁校验失败时进行相应处理 3、常见并发同步案例分析 案例一:订票系统案例，某航班只有一张机票，假定有1w个人打开你的网站来订票，问你如何解决并发问题(可扩展到任何高并发网站要考虑 的并发读写问题) 问题，1w个人来访问，票没出去前要保证大家都能看到有票，不可能一个人在看到票的时候别人就不能看了。到底谁能抢到，那得看这个人的“运气”（网 络快慢等） 其次考虑的问题，并发，1w个人同时点击购买，到底谁能成交？总共只有一张票。 首先我们容易想到和并发相关的几个方案 ： 锁同步同步更多指的是应用程序的层面，多个线程进来，只能一个一个的访问，java中指的是syncrinized关键字。锁也有2个层面，一个是java中谈到的对 象锁，用于线程同步；另外一个层面是数据库的锁；如果是分布式的系统，显然只能利用数据库端的锁来实现。 假定我们采用了同步机制或者数据库物理锁机制，如何保证1w个人还能同时看到有票，显然会牺牲性能，在高并发网站中是不可取的。使用hibernate后我们 提出了另外一个概念：乐观锁、悲观锁（即传统的物理锁）； 采用乐观锁即可解决此问题。乐观锁意思是不锁定表的情况下，利用业务的控制来解决并发问题，这样即保证数据的并发可读性又保证保存数据的排他性，保 证性能的同时解决了并发带来的脏数据问题。 hibernate中如何实现乐观锁： 前提：在现有表当中增加一个冗余字段，version版本号, long类型 原理： 1）只有当前版本号》=数据库表版本号，才能提交 2）提交成功后，版本号version ++ 实现很简单：在ormapping增加一属性optimistic-lock=”version”即可，以下是样例片段 案例二、股票交易系统、银行系统，大数据量你是如何考虑的 首先，股票交易系统的行情表，每几秒钟就有一个行情记录产生，一天下来就有（假定行情3秒一个） 股票数量×20×60*6 条记录，一月下来这个表记录数 量多大？ oracle中一张表的记录数超过100w后 查询性能就很差了，如何保证系统性能？ 再比如，中国移动有上亿的用户量，表如何设计？把所有用于存在于一个表么？ 所以，大数量的系统，必须考虑表拆分-（表名字不一样，但是结构完全一样），通用的几种方式：（视情况而定） 1）按业务分，比如 手机号的表，我们可以考虑 130开头的作为一个表，131开头的另外一张表 以此类推 2）利用oracle的表拆分机制做分表 3）如果是交易系统，我们可以考虑按时间轴拆分，当日数据一个表，历史数据弄到其它表。这里历史数据的报表和查询不会影响当日交易。 当然，表拆分后我们的应用得做相应的适配。单纯的or-mapping也许就得改动了。比如部分业务得通过存储过程等 此外，我们还得考虑缓存 这里的缓存，指的不仅仅是hibernate，hibernate本身提供了一级二级缓存。这里的缓存独立于应用，依然是内存的读取，假如我们能减少数据库频繁的访 问，那对系统肯定大大有利的。比如一个电子商务系统的商品搜索，如果某个关键字的商品经常被搜，那就可以考虑这部分商品列表存放到缓存（内存中 去），这样不用每次访问数据库，性能大大增加。 简单的缓存大家可以理解为自己做一个hashmap，把常访问的数据做一个key，value是第一次从数据库搜索出来的值，下次访问就可以从map里读取，而不 读数据库；专业些的目前有独立的缓存框架比如memcached 等，可独立部署成一个缓存服务器。 4、常见的提高高并发下访问的效率的手段 首先要了解高并发的的瓶颈在哪里？ 1、可能是服务器网络带宽不够 2.可能web线程连接数不够 3.可能数据库连接查询上不去。 根据不同的情况，解决思路也不同。 像第一种情况可以增加网络带宽，DNS域名解析分发多台服务器。 负载均衡，前置代理服务器nginx、apache等等 数据库查询优化，读写分离，分表等等 最后复制一些在高并发下面需要常常需要处理的内容: 尽量使用缓存，包括用户缓存，信息缓存等，多花点内存来做缓存，可以大量减少与数据库的交互，提高性能。 用jprofiler等工具找出性能瓶颈，减少额外的开销。 优化数据库查询语句，减少直接使用hibernate等工具的直接生成语句（仅耗时较长的查询做优化）。 优化数据库结构，多做索引，提高查询效率。 统计的功能尽量做缓存，或按每天一统计或定时统计相关报表，避免需要时进行统计的功能。 能使用静态页面的地方尽量使用，减少容器的解析（尽量将动态内容生成静态html来显示）。 解决以上问题后，使用服务器集群来解决单台的瓶颈问题。 java高并发，如何解决，什么方式解决之前我将高并发的解决方法误认为是线程或者是队列可以解决，因为高并发的时候是有很多用户在访问，导致出现系统数据不正确、丢失数据现象，所以想到 的是用队列解决，其实队列解决的方式也可以处理，比如我们在竞拍商品、转发评论微博或者是秒杀商品等，同一时间访问量特别大，队列在此起到特别的作用，将 所有请求放入队列，以毫秒计时单位，有序的进行，从而不会出现数据丢失系统数据不正确的情况。 今天我经过查资料，高并发的解决方法有俩种: 一种是使用缓存、另一种是使用生成静态页面；还有就是从最基础的地方优化我们写代码减少不必要的资源浪费：( 1.不要频繁的new对象,对于在整个应用中只需要存在一个实例的类使用单例模式.对于String的连接操作,使用StringBuffer或者StringBuilder.对于utility类型的类通过静态方法来访问。 避免使用错误的方式,如Exception可以控制方法推出,但是Exception要保留stacktrace消耗性能,除非必要不要使用 instanceof做条件判断,尽量使用比的条件判断方式.使用JAVA中效率高的类,比如ArrayList比Vector性能好。) 首先缓存技术我一直没有使用过，我觉得应该是在用户请求时将数据保存在缓存中，下次请求时会检测缓存中是否有数据存在，防止多次请求服务器，导致服务器性能降低，严重导致服务器崩溃，这只是我自己的理解，详细的资料还是需要在网上收集； 使用生成静态页面我想大家应该不模式，我们见过很多网站当在请求的时候页面的后最已经变了，如“http://developer.51cto.com/art/201207/348766.htm”该页面其实是一个服务器请求地址，在转换成htm后，访问速度将提升，因为静态页面不带有服务器组件；在这里我就多多介绍一下： 一、什么是页面静态化： 简 单的说，我们如果访问一个链接 ,服务器对应的模块会处理这个请求，转到对应的jsp界面，最后生成我们想要看到的数据。这其中的缺点是显而易见的：因为每次请求服务器都会进行处理，如 果有太多的高并发请求，那么就会加重应用服务器的压力，弄不好就把服务器 搞down 掉了。那么如何去避免呢？如果我们把对 test.do 请求后的结果保存成一个 html 文件，然后每次用户都去访问 ,这样应用服务器的压力不就减少了？ 那么静态页面从哪里来呢？总不能让我们每个页面都手动处理吧？这里就牵涉到我们要讲解的内容了，静态页面生成方案… 我们需要的是自动的生成静态页面，当用户访问 ,会自动生成 test.html ,然后显示给用户。 二、下面我们在简单介绍一下要想掌握页面静态化方案应该掌握的知识点： 1、 基础- URL Rewrite 什么是 URL Rewrite 呢 ? URL 重写。用一个简单的例子来说明问题：输入网址 ,但是实际上访问的却是 abc.com/test.action,那我们就可以说 URL 被重写了。这项技术应用广泛，有许多开源的工具可以实现这个功能。 2、 基础- Servlet web.xml 如果你还不知道 web.xml 中一个请求和一个 servlet 是如何匹配到一起的，那么请搜索一下 servlet 的文档。这可不是乱说呀，有很多人就认为 /xyz/*.do 这样的匹配方式能有效。 如果你还不知道怎么编写一个 servlet ,那么请搜索一下如何编写 servlet.这可不是说笑呀，在各种集成工具漫天飞舞的今天，很多人都不会去从零编写一个 servlet了。 三、基本的方案介绍 其中，对于 URL Rewriter的部分，可以使用收费或者开源的工具来实现，如果 url不是特别的复杂，可以考虑在 servlet 中实现，那么就是下面这个样子： 总 结：其实我们在开发中都很少考虑这种问题，直接都是先将功能实现，当一个程序员在干到1到2年，就会感觉光实现功能不是最主要的，安全性能、质量等等才是 一个开发人员最该关心的。今天我所说的是高并发。我的解决思路是：1、采用分布式应用设计2、分布式缓存数据库3、代码优化 Java高并发的例子：😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈ 具体情况是这样： 通过java和数据库，自己实现序列自动增长。实现代码大致如下： id_table表结构, 主要字段： id_name varchar2(16); id_val number(16,0); id_prefix varchar2(4); 复制代码//操作DB public synchronized String nextStringValue(String id){ SqlSession sqlSess = SqlSessionUtil.getSqlSession(); sqlSess.update(“update id_table set id_val = id_val + 1 where id_name=”+id); Map map = sqlSess.getOne(“select id_name, id_prefix, id_val from id_table where id_name=”+ id); BigDecimal val = (BigDecimal) map.get(“id_val”); //id_val是具体数字，rePack主要是统一返回固定长度的字符串；如：Y0000001, F0000001, T0000001等 String idValue = rePack(val, map); return idValue; } //公共方法public class IdHelpTool{ public static String getNextStringValue(String idName){ return getXX().nextStringValue(idName); }}复制代码具体使用者，都是通过类似这种方式：IdHelpTool.getNextStringValue(“PAY_LOG”);来调用。 问题： （1） 当出现并发时， 有时会获取重复的ID； （2） 由于服务器做了相关一些设置，有时调用这个方法，好像还会导致超时。 为了解决问题(1), 考虑过在方法getNextStringValue上，也加上synchronized ， 同步关键字过多，会不会更导致超时？ 跪求大侠提供个解决问题的大概思路！！！ 😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈ 解决思路一： 1、推荐 https://github.com/adyliu/idcenter2、可以通过第三方redis来实现。 解决思路一： 1、出现重复ID，是因为脏读了，并发的时候不加 synchronized 比如会出现问题 2、但是加了 synchronized ，性能急剧下降了，本身 java 就是多线程的，你把它单线程使用，不是明智的选择，同时，如果分布式部署的时候，加了 synchronized 也无法控制并发 3、调用这个方法，出现超时的情况，说明你的并发已经超过了数据库所能处理的极限，数据库无限等待导致超时 基于上面的分析，建议采用线程池的方案，支付宝的单号就是用的线程池的方案进行的。 数据库 update 不是一次加1，而是一次加几百甚至上千，然后取到的这 1000个序号，放在线程池里慢慢分配即可，能应付任意大的并发，同时保证数据库没任何压力。 😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈😁✈]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发concurrent(三)]]></title>
    <url>%2F2017%2F09%2F03%2F%E5%B9%B6%E5%8F%91concurrent-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[并发编程 ：Concurrent ( 下 ) 下面就是并发相关lock，一些原子类。 锁 Lock java.util.concurrent.locks.Lock 是一个类似于 synchronized 块的线程同步机制。但是 Lock 比 synchronized 块更加灵活、精细。 Java Lock 例子 既然 Lock 是一个接口，在你的程序里需要使用它的实现类之一来使用它。以下是一个简单示例： Lock lock = new ReentrantLock(); lock.lock(); //critical section lock.unlock(); 首先创建了一个 Lock 对象。之后调用了它的 lock() 方法。这时候这个 lock 实例就被锁住啦。任何其他再过来调用 lock() 方法的线程将会被阻塞住，直到锁定 lock 实例的线程调用了 unlock() 方法。最后 unlock() 被调用了，lock 对象解锁了，其他线程可以对它进行锁定了。 Java Lock 实现 java.util.concurrent.locks 包提供了以下对 Lock 接口的实现类： ReentrantLock Lock 和 synchronized 代码块的主要不同点 一个 Lock 对象和一个 synchronized 代码块之间的主要不同点是： synchronized 代码块不能够保证进入访问等待的线程的先后顺序。你不能够传递任何参数给一个 synchronized 代码块的入口。因此，对于 synchronized 代码块的访问等待设置超时时间是不可能的事情。synchronized 块必须被完整地包含在单个方法里。而一个 Lock 对象可以把它的 lock() 和 unlock() 方法的调用放在不同的方法里。 Lock 的方法 Lock 接口具有以下主要方法： lock()lockInterruptibly()tryLock()tryLock(long timeout, TimeUnit timeUnit)unlock() lock() 将 Lock 实例锁定。如果该 Lock 实例已被锁定，调用 lock() 方法的线程将会阻塞，直到 Lock 实例解锁。 lockInterruptibly() 方法将会被调用线程锁定，除非该线程被打断。此外，如果一个线程在通过这个方法来锁定 Lock 对象时进入阻塞等待，而它被打断了的话，该线程将会退出这个方法调用。 tryLock() 方法试图立即锁定 Lock 实例。如果锁定成功，它将返回 true，如果 Lock 实例已被锁定该方法返回 false。这一方法永不阻塞。tryLock(long timeout, TimeUnit timeUnit) 的工作类似于 tryLock() 方法，除了它在放弃锁定 Lock 之前等待一个给定的超时时间之外。 unlock() 方法对 Lock 实例解锁。一个 Lock 实现将只允许锁定了该对象的线程来调用此方法。其他(没有锁定该 Lock 对象的线程)线程对 unlock() 方法的调用将会抛一个未检查异常(RuntimeException)。 读写锁 ReadWriteLock java.util.concurrent.locks.ReadWriteLock 读写锁是一种先进的线程锁机制。它能够允许多个线程在同一时间对某特定资源进行读取，但同一时间内只能有一个线程对其进行写入。 读写锁的理念在于多个线程能够对一个共享资源进行读取，而不会导致并发问题。并发问题的发生场景在于对一个共享资源的读和写操作的同时进行，或者多个写操作并发进行。 本节只讨论 Java 内置 ReadWriteLock。如果你想了解 ReadWriteLock 背后的实现原理，请参考我的《Java 并发指南》主题中的《读写锁》小节。 ReadWriteLock 锁规则 一个线程在对受保护资源在读或者写之前对 ReadWriteLock 锁定的规则如下： 读锁：如果没有任何写操作线程锁定 ReadWriteLock，并且没有任何写操作线程要求一个写锁(但还没有获得该锁)。因此，可以有多个读操作线程对该锁进行锁定。写锁：如果没有任何读操作或者写操作。因此，在写操作的时候，只能有一个线程对该锁进行锁定。 ReadWriteLock 实现 ReadWriteLock 是个接口，如果你想用它的话就得去使用它的实现类之一。java.util.concurrent.locks 包提供了 ReadWriteLock 接口的以下实现类： ReentrantReadWriteLock ReadWriteLock 代码示例 以下是 ReadWriteLock 的创建以及如何使用它进行读、写锁定的简单示例代码： ReadWriteLock readWriteLock = new ReentrantReadWriteLock(); readWriteLock.readLock().lock(); // multiple readers can enter this section // if not locked for writing, and not writers waiting // to lock for writing. readWriteLock.readLock().unlock(); readWriteLock.writeLock().lock(); // only one writer can enter this section, // and only if no threads are currently reading. readWriteLock.writeLock().unlock(); 注意如何使用 ReadWriteLock 对两种锁实例的持有。一个对读访问进行保护，一个队写访问进行保护。 原子性布尔 AtomicBoolean AtomicBoolean 类为我们提供了一个可以用原子方式进行读和写的布尔值，它还拥有一些先进的原子性操作，比如 compareAndSet()。AtomicBoolean 类位于 java.util.concurrent.atomic 包，完整类名是为 java.util.concurrent.atomic.AtomicBoolean。本小节描述的 AtomicBoolean 是 Java 8 版本里的，而不是它第一次被引入的 Java 5 版本。 AtomicBoolean 背后的设计理念在我的《Java 并发指南》主题的《比较和交换》小节有解释。 创建一个 AtomicBoolean 你可以这样创建一个 AtomicBoolean： AtomicBoolean atomicBoolean = new AtomicBoolean(); 以上示例新建了一个默认值为 false 的 AtomicBoolean。如果你想要为 AtomicBoolean 实例设置一个显式的初始值，那么你可以将初始值传给 AtomicBoolean 的构造子： AtomicBoolean atomicBoolean = new AtomicBoolean(true); 获取 AtomicBoolean 的值 你可以通过使用 get() 方法来获取一个 AtomicBoolean 的值。示例如下： AtomicBoolean atomicBoolean = new AtomicBoolean(true); boolean value = atomicBoolean.get(); 以上代码执行后 value 变量的值将为 true。 设置 AtomicBoolean 的值 你可以通过使用 set() 方法来设置一个 AtomicBoolean 的值。示例如下： AtomicBoolean atomicBoolean = new AtomicBoolean(true); atomicBoolean.set(false); 以上代码执行后 AtomicBoolean 的值为 false。 交换 AtomicBoolean 的值 你可以通过 getAndSet() 方法来交换一个 AtomicBoolean 实例的值。getAndSet() 方法将返回 AtomicBoolean 当前的值，并将为 AtomicBoolean 设置一个新值。示例如下： AtomicBoolean atomicBoolean = new AtomicBoolean(true); boolean oldValue = atomicBoolean.getAndSet(false); 以上代码执行后 oldValue 变量的值为 true，atomicBoolean 实例将持有 false 值。代码成功将 AtomicBoolean 当前值 ture 交换为 false。 比较并设置 AtomicBoolean 的值 compareAndSet() 方法允许你对 AtomicBoolean 的当前值与一个期望值进行比较，如果当前值等于期望值的话，将会对 AtomicBoolean 设定一个新值。compareAndSet() 方法是原子性的，因此在同一时间之内有单个线程执行它。因此 compareAndSet() 方法可被用于一些类似于锁的同步的简单实现。以下是一个 compareAndSet() 示例： AtomicBoolean atomicBoolean = new AtomicBoolean(true); boolean expectedValue = true;boolean newValue = false; boolean wasNewValueSet = atomicBoolean.compareAndSet( expectedValue, newValue); 本示例对 AtomicBoolean 的当前值与 true 值进行比较，如果相等，将 AtomicBoolean 的值更新为 false。 原子性整型 AtomicInteger AtomicInteger 类为我们提供了一个可以进行原子性读和写操作的 int 变量，它还包含一系列先进的原子性操作，比如 compareAndSet()。AtomicInteger 类位于 java.util.concurrent.atomic 包，因此其完整类名为 java.util.concurrent.atomic.AtomicInteger。本小节描述的 AtomicInteger 是 Java 8 版本里的，而不是它第一次被引入的 Java 5 版本。 AtomicInteger 背后的设计理念在我的《Java 并发指南》主题的《比较和交换》小节有解释。 创建一个 AtomicInteger 创建一个 AtomicInteger 示例如下： AtomicInteger atomicInteger = new AtomicInteger(); 本示例将创建一个初始值为 0 的 AtomicInteger。如果你想要创建一个给定初始值的 AtomicInteger，你可以这样： AtomicInteger atomicInteger = new AtomicInteger(123); 本示例将 123 作为参数传给 AtomicInteger 的构造子，它将设置 AtomicInteger 实例的初始值为 123。 获取 AtomicInteger 的值 你可以使用 get() 方法获取 AtomicInteger 实例的值。示例如下： AtomicInteger atomicInteger = new AtomicInteger(123); int theValue = atomicInteger.get(); 设置 AtomicInteger 的值 你可以通过 set() 方法对 AtomicInteger 的值进行重新设置。以下是 AtomicInteger.set() 示例： AtomicInteger atomicInteger = new AtomicInteger(123); atomicInteger.set(234); 以上示例创建了一个初始值为 123 的 AtomicInteger，而在第二行将其值更新为 234。 比较并设置 AtomicInteger 的值 AtomicInteger 类也通过了一个原子性的 compareAndSet() 方法。这一方法将 AtomicInteger 实例的当前值与期望值进行比较，如果二者相等，为 AtomicInteger 实例设置一个新值。AtomicInteger.compareAndSet() 代码示例： AtomicInteger atomicInteger = new AtomicInteger(123); int expectedValue = 123;int newValue = 234;atomicInteger.compareAndSet(expectedValue, newValue); 本示例首先新建一个初始值为 123 的 AtomicInteger 实例。然后将 AtomicInteger 与期望值 123 进行比较，如果相等，将 AtomicInteger 的值更新为 234。 增加 AtomicInteger 值 AtomicInteger 类包含有一些方法，通过它们你可以增加 AtomicInteger 的值，并获取其值。这些方法如下： addAndGet()getAndAdd()getAndIncrement()incrementAndGet() 第一个 addAndGet() 方法给 AtomicInteger 增加了一个值，然后返回增加后的值。getAndAdd() 方法为 AtomicInteger 增加了一个值，但返回的是增加以前的 AtomicInteger 的值。具体使用哪一个取决于你的应用场景。以下是这两种方法的示例： AtomicInteger atomicInteger = new AtomicInteger(); System.out.println(atomicInteger.getAndAdd(10));System.out.println(atomicInteger.addAndGet(10)); 本示例将打印出 0 和 20。例子中，第二行拿到的是加 10 之前的 AtomicInteger 的值。加 10 之前的值是 0。第三行将 AtomicInteger 的值再加 10，并返回加操作之后的值。该值现在是为 20。你当然也可以使用这俩方法为 AtomicInteger 添加负值。结果实际是一个减法操作。getAndIncrement() 和 incrementAndGet() 方法类似于 getAndAdd() 和 addAndGet()，但每次只将 AtomicInteger 的值加 1。 减小 AtomicInteger 的值 AtomicInteger 类还提供了一些减小 AtomicInteger 的值的原子性方法。这些方法是： decrementAndGet()getAndDecrement() decrementAndGet() 将 AtomicInteger 的值减一，并返回减一后的值。getAndDecrement() 也将 AtomicInteger 的值减一，但它返回的是减一之前的值。 原子性长整型 AtomicLong AtomicLong 类为我们提供了一个可以进行原子性读和写操作的 long 变量，它还包含一系列先进的原子性操作，比如 compareAndSet()AtomicLong 类位于 java.util.concurrent.atomic 包，因此其完整类名为 java.util.concurrent.atomic.AtomicLong。本小节描述的 AtomicLong 是 Java 8 版本里的，而不是它第一次被引入的 Java 5 版本。 AtomicLong 背后的设计理念在我的《Java 并发指南》主题的《比较和交换》小节有解释。 创建一个 AtomicLong 创建一个 AtomicLong 如下： AtomicLong atomicLong = new AtomicLong(); 将创建一个初始值为 0 的 AtomicLong。如果你想创建一个指定初始值的 AtomicLong，可以： AtomicLong atomicLong = new AtomicLong(123); 本示例将 123 作为参数传递给 AtomicLong 的构造子，后者将 AtomicLong 实例的初始值设置为 123。 获取 AtomicLong 的值 你可以通过 get() 方法获取 AtomicLong 的值。AtomicLong.get() 示例： AtomicLong atomicLong = new AtomicLong(123); long theValue = atomicLong.get(); 设置 AtomicLong 的值 你可以通过 set() 方法设置 AtomicLong 实例的值。一个 AtomicLong.set() 的示例： AtomicLong atomicLong = new AtomicLong(123); atomicLong.set(234); 本示例新建了一个初始值为 123 的 AtomicLong，第二行将其值设置为 234。 比较并设置 AtomicLong 的值 AtomicLong 类也有一个原子性的 compareAndSet() 方法。这一方法将 AtomicLong 实例的当前值与一个期望值进行比较，如果两种相等，为 AtomicLong 实例设置一个新值。AtomicLong.compareAndSet() 使用示例： AtomicLong atomicLong = new AtomicLong(123); long expectedValue = 123;long newValue = 234;atomicLong.compareAndSet(expectedValue, newValue); 本示例新建了一个初始值为 123 的 AtomicLong。然后将 AtomicLong 的当前值与期望值 123 进行比较，如果相等的话，AtomicLong 的新值将变为 234。 增加 AtomicLong 值 AtomicLong 具备一些能够增加 AtomicLong 的值并返回自身值的方法。这些方法如下： addAndGet()getAndAdd()getAndIncrement()incrementAndGet() 第一个方法 addAndGet() 将 AtomicLong 的值加一个数字，并返回增加后的值。第二个方法 getAndAdd() 也将 AtomicLong 的值加一个数字，但返回的是增加前的 AtomicLong 的值。具体使用哪一个取决于你自己的场景。示例如下： AtomicLong atomicLong = new AtomicLong(); System.out.println(atomicLong.getAndAdd(10));System.out.println(atomicLong.addAndGet(10)); 本示例将打印出 0 和 20。例子中，第二行拿到的是加 10 之前的 AtomicLong 的值。加 10 之前的值是 0。第三行将 AtomicLong 的值再加 10，并返回加操作之后的值。该值现在是为 20。你当然也可以使用这俩方法为 AtomicLong 添加负值。结果实际是一个减法操作。getAndIncrement() 和 incrementAndGet() 方法类似于 getAndAdd() 和 addAndGet()，但每次只将 AtomicLong 的值加 1。 减小 AtomicLong 的值 AtomicLong 类还提供了一些减小 AtomicLong 的值的原子性方法。这些方法是： decrementAndGet()getAndDecrement() decrementAndGet() 将 AtomicLong 的值减一，并返回减一后的值。getAndDecrement() 也将 AtomicLong 的值减一，但它返回的是减一之前的值。 原子性引用型 AtomicReference AtomicReference 提供了一个可以被原子性读和写的对象引用变量。原子性的意思是多个想要改变同一个 AtomicReference 的线程不会导致 AtomicReference 处于不一致的状态。AtomicReference 还有一个 compareAndSet() 方法，通过它你可以将当前引用于一个期望值(引用)进行比较，如果相等，在该 AtomicReference 对象内部设置一个新的引用。 创建一个 AtomicReference 创建 AtomicReference 如下： AtomicReference atomicReference = new AtomicReference(); 如果你需要使用一个指定引用创建 AtomicReference，可以： String initialReference = “the initially referenced string”;AtomicReference atomicReference = new AtomicReference(initialReference); 创建泛型 AtomicReference 你可以使用 Java 泛型来创建一个泛型 AtomicReference。示例： AtomicReference atomicStringReference = new AtomicReference(); 你也可以为泛型 AtomicReference 设置一个初始值。示例： String initialReference = “the initially referenced string”;AtomicReference atomicStringReference = new AtomicReference(initialReference); 获取 AtomicReference 引用 你可以通过 AtomicReference 的 get() 方法来获取保存在 AtomicReference 里的引用。如果你的 AtomicReference 是非泛型的，get() 方法将返回一个 Object 类型的引用。如果是泛型化的，get() 将返回你创建 AtomicReference 时声明的那个类型。先来看一个非泛型的 AtomicReference get() 示例： AtomicReference atomicReference = new AtomicReference(“first value referenced”); String reference = (String) atomicReference.get(); 注意如何对 get() 方法返回的引用强制转换为 String。泛型化的 AtomicReference 示例： AtomicReference atomicReference = new AtomicReference(“first value referenced”); String reference = atomicReference.get(); 编译器知道了引用的类型，所以我们无需再对 get() 返回的引用进行强制转换了。 设置 AtomicReference 引用 你可以使用 get() 方法对 AtomicReference 里边保存的引用进行设置。如果你定义的是一个非泛型 AtomicReference，set() 将会以一个 Object 引用作为参数。如果是泛型化的 AtomicReference，set() 方法将只接受你定义给的类型。AtomicReference set() 示例： new AtomicReference(); atomicReference.set(“New object referenced”); 这个看起来非泛型和泛型化的没啥区别。真正的区别在于编译器将对你能够设置给一个泛型化的 AtomicReference 参数类型进行限制。 比较并设置 AtomicReference 引用 AtomicReference 类具备了一个很有用的方法：compareAndSet()。compareAndSet() 可以将保存在 AtomicReference 里的引用于一个期望引用进行比较，如果两个引用是一样的(并非 equals() 的相等，而是 == 的一样)，将会给 AtomicReference 实例设置一个新的引用。 如果 compareAndSet() 为 AtomicReference 设置了一个新的引用，compareAndSet() 将返回 true。否则 compareAndSet() 返回 false。AtomicReference compareAndSet() 示例： String initialReference = “initial value referenced”; AtomicReference atomicStringReference = new AtomicReference(initialReference); String newReference = “new value referenced”;boolean exchanged = atomicStringReference.compareAndSet(initialReference, newReference);System.out.println(“exchanged: “ + exchanged); exchanged = atomicStringReference.compareAndSet(initialReference, newReference);System.out.println(“exchanged: “ + exchanged); 本示例创建了一个带有一个初始引用的泛型化的 AtomicReference。之后两次调用 comparesAndSet()来对存储值和期望值进行对比，如果二者一致，为 AtomicReference 设置一个新的引用。第一次比较，存储的引用(initialReference)和期望的引用(initialReference)一致，所以一个新的引用(newReference)被设置给 AtomicReference，compareAndSet() 方法返回 true。第二次比较时，存储的引用(newReference)和期望的引用(initialReference)不一致，因此新的引用没有被设置给 AtomicReference，compareAndSet() 方法返回 false。]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发编程之 NIO]]></title>
    <url>%2F2017%2F09%2F01%2FNIO%2F</url>
    <content type="text"><![CDATA[Java 并发编程之 NIO 问题来源 在传统的架构中，对于客户端的每一次请求，服务器都会创建一个新的线程或者利用线程池复用去处理用户的一个请求，然后返回给用户结果，这样做在高并发的情况下会存在非常严重的性能问题：对于用户的每一次请求都创建一个新的线程是需要一定内存的，同时线程之间频繁的上下文切换也是一个很大的开销。 p.s: 本文涉及的完整实例代码都可以在我的GitHub上面下载。 什么是Selector NIO的核心就是Selector，读懂了Selector就理解了异步机制的实现原理，下面先来简单的介绍一下什么是Selector。现在对于客户端的每一次请求到来时我们不再立即创建一个线程进行处理，相反以epool为例子当一个事件准备就绪之后通过回调机制将描述符加入到阻塞队列中，下面只需要通过遍历阻塞队列对相应的事件进行处理就行了，通过这种回调机制整个过程都不需要对于每一个请求都去创建一个线程去单独处理。上面的解释还是有些抽象，下面我会通过具体的代码实例来解释，在这之前我们先来了解一下NIO中两个基础概念Buffer和Channel。 如果大家对于多路IO复用比如select/epool完全陌生的话，建议先读一下我的这篇Linux下的五种IO模型 :-) Buffer 以ByteBuffer为例子，我们可以通过ByteBuffer.allocate(n)来分配n个字节的缓冲区，对于缓冲区有四个重要的属性： capacity，缓冲区的容量，也就是我们上面指定的n。position，当前指针指向的位置。mark，前一个位置，这里我们下面再解释。limit，最大能读取或者写入的位置。 如上图所示，Buffer实际上也是分为两种，一种用于写数据，一种用于读取数据。 put 通过直接阅读ByteBuffer源码可以清晰看出put方法是把一个byte变量x放到缓冲区中去，同时position加1： public ByteBuffer put(byte x) { hb[ix(nextPutIndex())] = x; return this;}final int nextPutIndex() { if (position &gt;= limit) throw new BufferOverflowException(); return position++;} get get方法是从缓冲区中读取一个字节，同时position加一： public byte get() { return hb[ix(nextGetIndex())];}final int nextGetIndex() { if (position &gt;= limit) throw new BufferUnderflowException(); return position++;} flip 如果我们想将buffer从写数据的情况变成读数据的情况，可以直接使用flip方法： public final Buffer flip() { limit = position; position = 0; mark = -1; return this;} mark和reset mark是记住当前的位置用的，也就是保存position的值： public final Buffer mark() { mark = position; return this;} 如果我们在对缓冲区读写之前就调用了mark方法，那么以后当position位置变化之后，想回到之前的位置可以调用reset会将mark的值重新赋给position： public final Buffer reset() { int m = mark; if (m &lt; 0) throw new InvalidMarkException(); position = m; return this;} Channel 利用NIO，当我们读取数据的时候，会先从buffer加载到channel，而写入数据的时候，会先入到channel然后通过channel转移到buffer中去。channel给我们提供了两个方法：通过channel.read(buffer)可以将channel中的数据写入到buffer中，而通过channel.write(buffer)则可以将buffer中的数据写入到到channel中。 Channel的话分为四种： FileChannel从文件中读写数据。DatagramChannel以UDP的形式从网络中读写数据。SocketChannel以TCP的形式从网络中读写数据。ServerSocketChannel允许你监听TCP连接。 因为今天我们的重点是Selector，所以来看一下SocketChannel的用法。在下面的代码利用SocketChannel模拟了一个简单的server-client程序。 WebServer的代码如下，和传统的sock程序并没有太多的差异，只是我们引入了buffer和channel的概念： ServerSocketChannel ssc = ServerSocketChannel.open();ssc.socket().bind(new InetSocketAddress(“127.0.0.1”, 5000));SocketChannel socketChannel = ssc.accept();ByteBuffer readBuffer = ByteBuffer.allocate(128);socketChannel.read(readBuffer);readBuffer.flip();while (readBuffer.hasRemaining()) { System.out.println((char)readBuffer.get());}socketChannel.close();ssc.close(); WebClient的代码如下： SocketChannel socketChannel = null;socketChannel = SocketChannel.open();socketChannel.connect(new InetSocketAddress(“127.0.0.1”, 5000));ByteBuffer writeBuffer = ByteBuffer.allocate(128);writeBuffer.put(“hello world”.getBytes());writeBuffer.flip();socketChannel.write(writeBuffer);socketChannel.close(); Scatter / Gather 在上面的client程序中，我们也可以同时将多个buffer中的数据放入到一个数组后然后统一放入到channel后传递给服务器： ByteBuffer buffer1 = ByteBuffer.allocate(128);ByteBuffer buffer2 = ByteBuffer.allocate(16);buffer1.put(“hello “.getBytes());buffer2.put(“world”.getBytes());buffer1.flip();buffer2.flip();ByteBuffer[] bufferArray = {buffer1, buffer2};socketChannel.write(bufferArray); Selector 通过使用selector，我们可以通过一个线程来同时管理多个channel，省去了创建线程以及线程之间进行上下文切换的开销。 创建一个selector 通过调用selector类的静态方法open我们就可以创建一个selector对象： Selector selector = Selector.open(); 注册channel 为了保证selector能够监听多个channel，我们需要将channel注册到selector当中： channel.configureBlocking(false);SelectionKey key = channel.register(selector, SelectionKey.OP_READ); 我们可以监听四种事件： SelectionKey.OP_CONNECT：当客户端的尝试连接到服务器SelectionKey.OP_ACCEPT：当服务器接受来自客户端的请求SelectionKey.OP_READ：当服务器可以从channel中读取数据SelectionKey.OP_WRITE：当服务器可以向channel中写入数据 对SelectorKey调用channel方法可以得到key对应的channel: Channel channel = key.channel(); 而key自身感兴趣的监听事件也可以通过interestOps来获得： int interestSet = selectionKey.interestOps(); 对selector调用selectedKeys()方法我们可以得到注册的所有key： Set selectedKeys = selector.selectedKeys(); 实战 服务器的代码如下： ServerSocketChannel ssc = ServerSocketChannel.open();ssc.socket().bind(new InetSocketAddress(“127.0.0.1”, 5000));ssc.configureBlocking(false);Selector selector = Selector.open();ssc.register(selector, SelectionKey.OP_ACCEPT);ByteBuffer readBuff = ByteBuffer.allocate(128);ByteBuffer writeBuff = ByteBuffer.allocate(128);writeBuff.put(“received”.getBytes());writeBuff.flip(); // make buffer ready for readingwhile (true) { selector.select(); Set keys = selector.selectedKeys(); Iterator it = keys.iterator(); while (it.hasNext()) { SelectionKey key = it.next(); it.remove(); if (key.isAcceptable()) { SocketChannel socketChannel = ssc.accept(); socketChannel.configureBlocking(false); socketChannel.register(selector, SelectionKey.OP_READ); } else if (key.isReadable()) { SocketChannel socketChannel = (SocketChannel) key.channel(); readBuff.clear(); // make buffer ready for writing socketChannel.read(readBuff); readBuff.flip(); // make buffer ready for reading System.out.println(new String(readBuff.array())); key.interestOps(SelectionKey.OP_WRITE); } else if (key.isWritable()) { writeBuff.rewind(); // sets the position back to 0 SocketChannel socketChannel = (SocketChannel) key.channel(); socketChannel.write(writeBuff); key.interestOps(SelectionKey.OP_READ); } }} 客户端程序的代码如下，各位读者可以同时在终端下面多开几个程序来同时模拟多个请求，而对于多个客户端的程序我们的服务器始终只用一个线程来处理多个请求。一个很常见的应用场景就是多个用户同时往服务器上传文件，对于每一个上传请求我们不在单独去创建一个线程去处理，同时利用Executor/Future我们也可以不用阻塞在IO操作中而是立即返回用户结果。 SocketChannel socketChannel = SocketChannel.open();socketChannel.connect(new InetSocketAddress(“127.0.0.1”, 5000));ByteBuffer writeBuffer = ByteBuffer.allocate(32);ByteBuffer readBuffer = ByteBuffer.allocate(32);writeBuffer.put(“hello”.getBytes());writeBuffer.flip(); // make buffer ready for readingwhile (true) { writeBuffer.rewind(); // sets the position back to 0 socketChannel.write(writeBuffer); // hello readBuffer.clear(); // make buffer ready for writing socketChannel.read(readBuffer); // recieved}]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间观念]]></title>
    <url>%2F2017%2F08%2F26%2F%E6%97%B6%E9%97%B4%E8%A7%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[时间的概念因为我们不知道，究竟什么对我们最重要，所以，每件事都花不少时间，盲目行动，浪费时间。有些人看到我们每一件事都做， 所以，他们期望我们什么都做。每一件事都做让我们非常忙碌，所以，我们没有时间去考虑，究竟什么对我们重要。怎么去规划时间，管理时间，不让时间管理我们。时间，在我们人生中是最珍贵的，所以，我们要高效率利用它。 1.大家可能问时间有什么意义？ 我废话少说，大家想象五年后的你?然后我们把这个5年倒回来看看。 What you are doing in 5 years? 你可能长叹一口气，……yes?（哈哈） 我的回答可能是：拥有一家大数据，物联网相关的公司正在运营（这是自己的一个痴心妄想，也踏上这条路的初心，哈哈）。那么第四年，公司已经成熟，有固定的客户，业务，稳定业绩。第三年，公司逐步进入正轨，走上成熟，走过重重浴火，终于要变成小鸟，凤凰就不敢了。第二年，公司刚刚成立不久，正是瓶颈期，为业务种种发愁。第一年，公司注册，团队组建完成，公司选址等等准备完成。 这个只是的简单想法，只是为了举例让读者明白罢了。 2.个人的处理事情的原则（可以给大家参考），我分为五类 ①重要紧急②重要不紧急③紧急不重要（委托授权）④不重要不紧急 符永坤（富伊克fuyk） 著]]></content>
      <categories>
        <category>职业知识</category>
      </categories>
      <tags>
        <tag>职业修养</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[致即将毕业的我]]></title>
    <url>%2F2017%2F08%2F26%2F%E8%87%B4%E6%AF%95%E4%B8%9A%E7%9A%84%E8%87%AA%E5%B7%B1%2F</url>
    <content type="text"><![CDATA[面临毕业的自己，听师兄师姐们的侃侃而谈，自己也担忧起了自己的就业前程，毕业就是失业。所以自己也有了面临就业的临危感，俗话说祸起 乃于萧蔷也。归根结底是自己的问题，我的座右铭是：世上无难事，只要肯登攀。机会是留给有准备的人，此时的我又激情澎湃了。所以埋头学习了起来。拿起笔学习有关职业方面知识。 1.1准备职业人定位 1.1.1那么什么是职业人? 人力资源专家胡斌曾把人分为：“没人经营的人”，“别人经营的人”，“自我经营的人”和“经营别人的人”四种。职业人属于那个范畴相信大家已有所思 既然进入企业，职业人必须按企业对员工的标准要求自己，这是职业人基本素质。 1.2由院校人向企业人转变 在学校时的几个特点： 》可以与喜欢的人在一起，自己选择性。 》可以喜形于色。 》考试通过就OK，分数比什么都重要，而且闭卷考试（不可以其他辅助完成）。 》事情自己做的，成绩当然归功于自己 》喜欢做“与众不同的人” 》自由性强 》。。。。。。。。。。。大家可以集思广益 所以我们必须转变思想，向企业，社会转型》 ①个人--团队导向 在学校中，以自我为中心的模式不适合于企业，个人的成功必须与整体的成功结合才有意义。一荣俱荣，一损俱损，重个性 转变到重标准；以个人衡量到集体衡量；独创到协作；独行到合作。 ②情感--职业导向 情绪化是学生显著的特征之一，职业场格格不入的，注重游戏规则，个人好恶不能左右于你。 ③思维--行为导向 学生学习，重在开发智力，学习知识，往往都是3思维的训练。这也是和企业有很大的不同，转变也就必不可少了。 思维至上转变到产品至上；想到就行转到做到才行，而且要做到最好；理论家转变到实干家；注重思考，分析。 ⑤个人资源--组织资源 1.2.1企业目标 企业需要对客户负责，对社会负责，对投资者负责，对员工负责。 联想公司对员工要求，也是招聘人才的要求： 1.知识，是基础。 2.人际交往。团队合作和团队精神，现代企业非常注重。 3.责任感。对自己所做的事情负责 4.能力，知识不等于能力，能力取决于个人执行力等等。 5.敬业。干一行爱一行，真正爱自己的工作，不是爱一行，干一行。企业不花钱养废人。]]></content>
      <categories>
        <category>职业知识</category>
      </categories>
      <tags>
        <tag>职业修养</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux（一）]]></title>
    <url>%2F2017%2F08%2F25%2FLinux%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[先说明本文：图片没有贴出，大家认真阅读不影响 一 ：为什么学Linux Linux的历史发展大家可以百度一些，了解了解就ok,学利用一切可以利用的资源； 1.Linux的特点： 第一： 免费开源，了解它的发展就知道为什么开源了，一款完全的免费的操作系统，都可以下载它的源码，没有什么限制。 第二： 模块化程度高。 Linux 的 内核 设计 分成 进程 管理、 内存 管理、进程 间 通信、 虚拟 文件 系统、 网络 5 部分， 其 采用 的 模块 机制 使得 用户 可以 根据 实际 需要， 在 内核 中 插入 或 移走 模块， 这使 得 内核 可以 被 高度 的 剪裁 定制， 以 方便 在 不同 的 场景 下 使用。 . 第三： 广泛 的 硬件 支持。 得 益于 其 免费 开源 的 特点， 有 大批 程序员 不断 地 向 Linux 社区 提供 代码， 使得 Linux 有着 异常 丰富 的 设备 驱动 资源， 对 主流 硬件 的 支持 极好， 而且 几乎 能 运行 在 所有 流行 的 处理器 上。 第四： 安全 稳定。 Linux 采取 了 很多 安全 技术 措施， 包括 读写 权限 控制、 带 保护 的 子系统、 审计 跟踪、 核心 授权 等， 这 为 网络 环境 中的 用户 提供 了 安全保障。 实际 上有 很多 运行 Linux 的 服务器 可以 持续 运行 长达 数年 而 无须 重 启， 依然 可以 性能 良好 地 提供 服务， 其 安全 稳定性 已经 在各 个领域 得到 了 广泛 的 证实。 第五： 多用户， 多任务。 多用户 是指 系统 资源 可以 同时 被 不同 的 用户 使用， 每个 用户 对 自己的 资源 有 特定 的 权限， 互不 影响。 多任务 是 现代化 计算机的 主要 特点， 指的 是 计算 机能 同时 运行 多个 程序， 且 程序 之间 彼此 独立， Linux 内核 负责 调度 每个 进程， 使之 平等 地 访问 处理器。 由于 CPU 处理 速度 极快， 从 用户 的 角度 来看 所有 的 进程 好像 在 并行 运行。 第六： 良好 的 可移植性。 Linux 中 95% 以上 的 代码 都是 用 C 语言 编写 的， 由于 C 语言 是一 种 机器 无关 的 高级 语言， 是 可 移植 的， 因此 Linux 系统 也是 移植的 1.2Linux优点： 稳定、免费或者花费少 安全性高 多任务，多用户 耗资源少 由于内核小，所以它可以支持多种电子产品，如：Android手机、PDA等 1.3安装（建议初学者可以以下） 在安装Linux系统之前，先来了解windows系统结构，windows系统一般是安装在C盘系统盘，同样Linux也有类似的系统盘（/根分区），Linux通常分区为（根分区/、swap分区），Linux系统以文件的存储方式，所有的文件都是存储在某个目录下的，类似于windows的文件夹。对于文件系统的属性来说，windows文件系统类型一般是ntfs、fat32等，而Linux文件系统类型则为ext2、ext3、ext4等（文件系统：是操作系统用于明确磁盘或分区上的文件的方法和数据结构，文件系统由三部分组成：与文件管理有关软件、被管理文件以及实施文件管理所需数据结构。）安装 Linux系统是每一个初学者的第一个门槛。在这个过程中间，最大的困惑莫过于给硬盘进行分区。虽然现在各种发行版本的 Linux 已经提供了友好的图形交互界面，但是很多人还是感觉无从下手。这其中的原因主要是不清楚 Linux 的分区规定。就好比如果我们了解了windows分区的规则，系统盘C、数据盘D等，就很好分区了。在 Linux 中规定，每一个硬盘设备最多只能有 4个主分区（其中包含扩展分区）构成，任何一个扩展分区都要占用一个主分区号码，也就是在一个硬盘中，主分区和扩展分区一共最多是 4 个。下面正式来安装Linux系统，安装系统前需要准备如下软件： VMware workstation 10.0（可以百度一下）CentOS 5.8 x86_i386.i或redhat（Linux官网下载） 说明：可能随时间更新版本可能安装有一定差异，不过换汤不换药，相信我们这些IT男的头脑这so easy。 1. 3. 1 安装 前 的 规划 可能会有读者正计划学习Linux 而苦恼于 不知道 使用 哪一个 发行 版， 其实 所有 的 发行 版 不管 是 RedHat、 CentOS 还是 Ubuntu， 其内 核 都是 来自 Linux 内核 官 网（ www. kernel. org）， 不同 发行 版 之间 的 差别 在于 软件 管理 的 不同， 所以 不管 使用 哪一个 发行 版， 只要 理解 其 原理 之后， 各类 发行 版 的 区别 其实 不大。 当然 对于 初学者 来说， 拥有 广泛 的 学习 资源 也是 很重 要的。 由于 RedHat 公司 进行 了 大力 商业 推广， 且 得 益于 其 成熟 的 认证 体系， 因此 使用 RedHat 的 用户 比较 多， 同时， 它 还有 丰富 的 相关 技术 文档， 以及 活跃 的 社区， 所以 作为 入门 学习， 可以 使用 RedHat。 不过年来，CentOS 发展 也 很 迅猛， 这个 发行 版 和 RedHat 几乎 完全 一样， 而且 在 某些方面 还 比 RedHat 略胜一筹， 所以 在 本书 中 后面 的 所有 内容 中将 主要 使用 版本 为 5. 5 的 CentOS， 小部分 涉及 RedHat 的 内容 也 将 采用 5. 5 版本。 有 读者 可能 会 考虑 在 一台 计算 机上 安装 多个 操作系统， 比如说 在 自己的 家用 计算 机上 安装 Windows 用于 娱乐 和 日常 应用 或 Windows 环境 下 的 开发 等， 另外 再 安装 Linux 系统 用于 学习。 在 这种 情况下， 最简单 的 安装 方法 是 先 安装 Windows， 后 安装 Linux， 这样 开机 的 时候 就 自动 出现 操作系统 选择 条， 可以 根据 实际需要 选择 进入 不同 的 操作系统。 由于 Linux 对 系统 的 需求 并不 高， 所以 几乎 所有 计算机 都可以 安装， 但是 考虑到 入门 学习 Linux 需要 用到 图形 界面， 所以 建议 最好 不要 低于 以下 配置： CPU， P- 3 800MHz； 内存， 1GB； 硬盘， 40GB。 在 安装 Linux 的 过程中， 必须 要有 的 两个 分区 为 根 分区（/） 和 swap 分区（ 交换 分区）， 当然 还有 一些 其他 的 分区 可以 独立 出来， 比如说/ boot 分区、/ var 分区 等。 另外， 这里 介绍 几个 概念， 便于 大家 理解 后面 即将 出现 的 一些 专业 词汇。 什么 是 交换 分区？ 交换 分区 是一 个 特殊 的 分区， 它的 作用 相当于 Windows 下 的 虚拟 内存， 这个 分区 的 大小 一般 设置 为 物理 内存 的 两倍， 但是 不管 物理 内存 有 多大， 交换 分区 建议 不要 超过 8GB， 因为 大于 8GB 的 交换 分区 其实 并没有 多大 实际意义。 什么 是 Grub？ Grub 是一 个 系统 引导 工具， 通过 它可 以 加载 内核， 从而 在 安装 Linux 的 过程中， 必须 要有 的 两个 分区 为 根 分区（/） 和 swap 分区（ 交换 分区）， 当然 还有 一些 其他 的 分区 可以 独立 出来， 比如说/ boot 分区、/ var 分区 等。 另外， 这里 介绍 几个 概念， 便于 大家 理解 后面 即将 出现 的 一些 专业 词汇。 什么 是 交换 分区？ 交换 分区 是一 个 特殊 的 分区， 它的 作用 相当于 Windows 下 的 虚拟 内存， 这个 分区 的 大小 一般 设置 为 物理 内存 的 两倍， 但是 不管 物理 内存 有 多大， 交换 分区 建议 不要 超过 8GB， 因为 大于 8GB 的 交换 分区 其实 并没有 多大 实际意义。 什么 是 Grub？ Grub 是一 个 系统 引导 工具， 通过 它可 以 加载 内核， 从而 引导 系统 启动。 什么 是/ boot 分区？/ boot 分区 用于 放置 Linux 启动 所 用到 的 文件， 如 kernel 和 initrd 文件。 什么 是 DHCP？ DHCP 是 Dynamic Host Configuration Protocol 的 简写， 中文 称为 动态 主机 配置 协议。 在 TCP/ IP 网络 中， 每 台 主机 都 需要 有 IP 地址 才能 与其 他 主机 通信， 在 一个 大规模 的 网络 中， 如果 由 管理员 手动 地 对 每一 台 主机 进行 IP 地址 配置 是 不现实 的。 由此 也就 产生了 DHCP 协议， 可用 它来 2 安装 RedHat 本节 将 演示 安装 RedHat 系统 的 过程， 使 用到 的 版本 是 RedHat 5. 5。 大家 可以 先到 网上 下载 RedHat 5. 5 操作系统 的 ISO 文件， 然后 刻成 光盘 再 安装。 当然 不要 忘记 在 计算机 的 主 板 中 设置 从 光驱 启动， 也可以 使用 虚拟 机 软件 通过 安装 虚拟 机 的 方式 模拟 安装 过程。 计算机 从 光盘 启动 后， 首先 会 显示 如图 1- 1 所示 界面（ 注意 看 英文 提示）。 如果 想 使用 图形 界面 安装 直接 按 回车 键 即可， 或者 在 10 秒 之内 不做 任何 输入， 这样 也会 默认 进入 图形 安装 模式。 如果 想用 字符 模式 安装， 需要 输入 linux text， 然后 按 回车 键。 如果 计算机 的 内存 过小， 安装 程序 会 检测 到 因 内存 不足 而无 法 进入 图形 安装 模式， 转而 进入 字符 安装 模式。 安装图解如下：第一步，新建虚拟机如下图： 第二步，选择相关选项，如下图： 第三步选择“稍后安装操作系统”，如下图: 第四步，选择客户机操作系统类型如下图： 第五步，设置虚拟机硬盘大小为20G，最低不能小于5G，如下图 第六步，虚拟机新建完成，如下图： 第七步，修改虚拟机内存为512M，并添加ISO镜像，如下图： 自此，虚拟机新建完成，接下来点击“启动此虚拟机”进行Linux系统安装，Linux系统安装图解如下：第一步，进入安装界面，直接按Enter回车键即可。 第二步，光盘检测，选择SKIP跳过。 第三步，选择安装过程中的语言，初学者可以选择“简体中文”。 第四步，选择初始化整个硬盘，清除所有数据。 第五步，选择分区方式为“自定义分区“。 点击“新建“-首先创建一个swap交换分区，大小为物理内存的2倍（1024M）。 第六步，继续创建分区，选择“新建“，然后创建根分区/，如下图选择，大小为剩余所有空间即可。 第七步，默认点击下一步，同时默认DHCP配置，时钟选择上海，去掉UTC勾，点击下一步。 第八步，设置root密码，至少六位，点击下一步。 第九步，系统安装包选择，这里选择“现在定制“。 第十步，系统安装包选择，左侧选择“开发“—-右侧选择”开发工具“和“开发库”，语言选择“支持中文“，其他一概不选择。 安装完毕会提示“reboot“，直接回车即可。 .]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发concurrent(二)]]></title>
    <url>%2F2017%2F08%2F07%2F%E5%B9%B6%E5%8F%91concurrent-2%2F</url>
    <content type="text"><![CDATA[并发编程 ：Concurrent ( 中 ) 一般并发，多线程都会结合线程池的使用，所以本篇说说相关线程池。 执行器服务 ExecutorService java.util.concurrent.ExecutorService 接口表示一个异步执行机制，使我们能够在后台执行任务。因此一个 ExecutorService 很类似于一个线程池。实际上，存在于 java.util.concurrent 包里的 ExecutorService 实现就是一个线程池实现。 ExecutorService 例子 以下是一个简单的 ExecutorService 例子： ExecutorService executorService = Executors.newFixedThreadPool(10); executorService.execute(new Runnable() { public void run() { System.out.println(“Asynchronous task”); }}); executorService.shutdown(); 首先使用 newFixedThreadPool() 工厂方法创建一个 ExecutorService。这里创建了一个十个线程执行任务的线程池。然后，将一个 Runnable 接口的匿名实现类传递给 execute() 方法。这将导致 ExecutorService 中的某个线程执行该 Runnable。 任务委派 下图说明了一个线程是如何将一个任务委托给一个 ExecutorService 去异步执行的： 一个线程将一个任务委派给一个 ExecutorService 去异步执行。 一旦该线程将任务委派给 ExecutorService，该线程将继续它自己的执行，独立于该任务的执行。 ExecutorService 实现 既然 ExecutorService 是个接口，如果你想用它的话就得去使用它的实现类之一。 java.util.concurrent 包提供了 ExecutorService 接口的以下实现类： ThreadPoolExecutorScheduledThreadPoolExecutor 创建一个 ExecutorService ExecutorService 的创建依赖于你使用的具体实现。但是你也可以使用 Executors 工厂类来创建 ExecutorService 实例。 以下是几个创建 ExecutorService 实例的例子： ExecutorService executorService1 = Executors.newSingleThreadExecutor(); ExecutorService executorService2 = Executors.newFixedThreadPool(10); ExecutorService executorService3 = Executors.newScheduledThreadPool(10); ExecutorService 使用 有几种不同的方式来将任务委托给 ExecutorService 去执行： execute(Runnable)submit(Runnable)submit(Callable)invokeAny(…)invokeAll(…) 接下来我们挨个看一下这些方法。 execute(Runnable) execute(Runnable) 方法要求一个 java.lang.Runnable 对象，然后对它进行异步执行。以下是使用 ExecutorService 执行一个 Runnable 的示例： ExecutorService executorService = Executors.newSingleThreadExecutor(); executorService.execute(new Runnable() { public void run() { System.out.println(“Asynchronous task”); }}); executorService.shutdown(); 没有办法得知被执行的 Runnable 的执行结果。如果有需要的话你得使用一个 Callable(以下将做介绍)。 submit(Runnable) submit(Runnable) 方法也要求一个 Runnable 实现类，但它返回一个 Future 对象。这个 Future 对象可以用来检查 Runnable 是否已经执行完毕。以下是 ExecutorService submit() 示例： Future future = executorService.submit(new Runnable() { public void run() { System.out.println(“Asynchronous task”); }}); future.get(); //returns null if the task has finished correctly. submit(Callable) submit(Callable) 方法类似于 submit(Runnable) 方法，除了它所要求的参数类型之外。Callable 实例除了它的 call() 方法能够返回一个结果之外和一个 Runnable 很相像。Runnable.run() 不能够返回一个结果。Callable 的结果可以通过 submit(Callable) 方法返回的 Future 对象进行获取。 以下是一个 ExecutorService Callable 示例： Future future = executorService.submit(new Callable(){ public Object call() throws Exception { System.out.println(“Asynchronous Callable”); return “Callable Result”; }}); System.out.println(“future.get() = “ + future.get()); 以上代码输出： Asynchronous Callablefuture.get() = Callable Result invokeAny() invokeAny() 方法要求一系列的 Callable 或者其子接口的实例对象。调用这个方法并不会返回一个 Future，但它返回其中一个 Callable 对象的结果。无法保证返回的是哪个 Callable 的结果 – 只能表明其中一个已执行结束。 如果其中一个任务执行结束(或者抛了一个异常)，其他 Callable 将被取消。以下是示例代码： ExecutorService executorService = Executors.newSingleThreadExecutor(); Set]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[whystudyIT]]></title>
    <url>%2F2017%2F08%2F07%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B5%B0%E4%B8%8A%E8%BF%99%E8%B7%AF%2F</url>
    <content type="text"></content>
      <categories>
        <category>关于我</category>
      </categories>
      <tags>
        <tag>story</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexoStudy]]></title>
    <url>%2F2017%2F08%2F05%2FhexoStudy%2F</url>
    <content type="text"><![CDATA[前提准备 NodeJSgit确保安装这两个才可以继续。 安装Hexo打开git $ npm install -g hexo部署Hexo在任何想要放置Hexo的文件夹下建立名为Hexo的文件夹，在此文件夹中右键打开Git Bash $ hexo initHexo会自动建立所有博客需要的文件 $ hexo g$ hexo s输入上面的命令就可以在本地看到初始化的博客啦，浏览器中输入localhost:4000以上就完成了博客的本地调试了，下面需要将本地的博客放到github中去，利用github pages 的免费空间存放你的博客，而且别人也可以访问你的博客。 配置和使用github首先需要注册github（废话。。划掉），然后登录github，点击右上角你的头像，再点击Settings，进入设置页面。点击侧栏的SSH and GPG keys,可以查看你是否有本机的SSH密匙。如果没有，说明并没有设置SSH密匙。 检查SSH keys的设置先不管github的网页，回到本机，打开Git Bash。输入： $ cd ~/. ssh 检查本机的ssh密钥如果提示：No such file or directory 说明你是第一次使用git。 生成新的SSH Key：继续输入： $ ssh-keygen -t rsa -C “邮件地址@youremail.com”Generating public/private rsa key pair.Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt;系统会要求你输入密码，输入就好，只是这里的输入是不显示占位符的。 Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;Enter same passphrase again:&lt;再次输入加密串&gt;完成后就会提示你的密匙文件所在的位置，打开id_rsa.pub文件，复制所有，回到github网页，点击New SSH key,粘贴到key文本框中，点击add key就可以了。 测试SSH连接输入下面的命令，git@github.com不用修改。 $ ssh -T git@github.com会有这样的反馈： The authenticity of host ‘github.com (207.97.227.239)’ can’t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)?输入yes，就会看到： Hi Dulmcat! You’ve successfully authenticated, but GitHub does not provide shell access.到这里就代表已经正确的连接到github了。 设置用户信息但还有一些个人信息还是需要继续完善下的，Git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的。 $ git config –global user.name “cnfeat”//用户名$ git config –global user.email “cnfeat@gmail.com”//填写自己的邮箱若有问题，从头再来一遍，或者到GitHub help中寻找解决方案。 使用GitHub pages 建立网页与GitHub建立好链接之后，就可以方便的使用它提供的Pages服务。但pages服务每个ID只有一个，大小也只有300M，但作为博客站，已经足够了。 建立仓库登录GitHub后，点击那个大大的绿色New repository按钮，新建一个仓库：Repository name：dulmcat.github.ioDescription (optional): 嗯。。括号里都说了是可选的，就随便吧，可填可不填。注意！！ 这里的Repository name必须是你的github用户名.github.io，否则就不是一个github pages而只是单纯的一个仓库了。点击Create Repository 完成创建。 上传hexo到github pages上传前，需要将Hexo和github想关联起来，在Hexo的配置文件_config.yml文件中,拉到最下面，修改配置文件： deploy: type: git repository: https://github.com/Dulmcat/Dulmcat.github.io branch: master这里的repository填写的是你的github pages所在库（就是上面刚建好的那个）的地址。这里有个坑，关于type的填写，有说应该是github的，有说是git的，我在两个月前的配置文件type写的github，写这篇文章时发现出错了，这才发现好像是作者在3.0之后改为了git，大家在安装Hexo时可以输入命令hexo-v查看Hexo的版本。在3.0之后需要另外安装hexo-deployer-git。 $ npm install hexo-deployer-git –save然后 $ hexo d这里可能会要求填写密码，填了就好。然后在浏览器中输入https://dulmcat.github.io 就可以看到你的博客啦一个在线的博客就这样建好了当然这是我的…要输入 你的github用户名.github.io]]></content>
      <categories>
        <category>hexo建博小结</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程 ：Concurrent （一）]]></title>
    <url>%2F2017%2F08%2F05%2F%E5%B9%B6%E5%8F%91concurrent%2F</url>
    <content type="text"><![CDATA[并发编程 ：Concurrent ( 上 ) 最近工作中用到并发相关知识，所以趁机复习一些相关知识，知识确定要间断复习，温故而知新不说，至少让你记忆加深。 java.util.concurrent – Java 并发工具包 阻塞队列 BlockingQueue java.util.concurrent 包里的 BlockingQueue 接口表示一个线程安放入和提取实例的队列。本小节我将给你演示如何使用这个 BlockingQueue。本节不会讨论如何在 Java 中实现一个你自己的 BlockingQueue。如果你对那个感兴趣，参考《Java 并发指南》 BlockingQueue 用法 BlockingQueue 通常用于一个线程生产对象，而另外一个线程消费这些对象的场景。下图是对这个原理的阐述： 一个线程往里边放，另外一个线程从里边取的一个 BlockingQueue。 一个线程将会持续生产新对象并将其插入到队列之中，直到队列达到它所能容纳的临界点。也就是说，它是有限的。如果该阻塞队列到达了其临界点，负责生产的线程将会在往里边插入新对象时发生阻塞。它会一直处于阻塞之中，直到负责消费的线程从队列中拿走一个对象。负责消费的线程将会一直从该阻塞队列中拿出对象。如果消费线程尝试去从一个空的队列中提取对象的话，这个消费线程将会处于阻塞之中，直到一个生产线程把一个对象丢进队列。 BlockingQueue 的方法 BlockingQueue 具有 4 组不同的方法用于插入、移除以及对队列中的元素进行检查。如果请求的操作不能得到立即执行的话，每个方法的表现也不同。这些方法如下： 四组不同的行为方式解释： 抛异常：如果试图的操作无法立即执行，抛一个异常。特定值：如果试图的操作无法立即执行，返回一个特定的值(常常是 true / false)。阻塞：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行。超时：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功(典型的是 true / false)。 无法向一个 BlockingQueue 中插入 null。如果你试图插入 null，BlockingQueue 将会抛出一个 NullPointerException。 可以访问到 BlockingQueue 中的所有元素，而不仅仅是开始和结束的元素。比如说，你将一个对象放入队列之中以等待处理，但你的应用想要将其取消掉。那么你可以调用诸如 remove(o) 方法来将队列之中的特定对象进行移除。但是这么干效率并不高(译者注：基于队列的数据结构，获取除开始或结束位置的其他对象的效率不会太高)，因此你尽量不要用这一类的方法，除非你确实不得不那么做。 BlockingQueue 的实现 BlockingQueue 是个接口，你需要使用它的实现之一来使用 BlockingQueue。java.util.concurrent 具有以下 BlockingQueue 接口的实现(Java 6)： ArrayBlockingQueueDelayQueueLinkedBlockingQueuePriorityBlockingQueueSynchronousQueue Java 中使用 BlockingQueue 的例子 这里是一个 Java 中使用 BlockingQueue 的示例。本示例使用的是 BlockingQueue 接口的 ArrayBlockingQueue 实现。 首先，BlockingQueueExample 类分别在两个独立的线程中启动了一个 Producer 和 一个 Consumer。 Producer 向一个共享的 BlockingQueue 中注入字符串，而 Consumer 则会从中把它们拿出来。 public class BlockingQueueExample { public static void main(String[] args) throws Exception { BlockingQueue queue = new ArrayBlockingQueue(1024); Producer producer = new Producer(queue); Consumer consumer = new Consumer(queue); new Thread(producer).start(); new Thread(consumer).start(); Thread.sleep(4000); } } 以下是 Producer 类。注意它在每次 put() 调用时是如何休眠一秒钟的。这将导致 Consumer 在等待队列中对象的时候发生阻塞。 public class Producer implements Runnable{ protected BlockingQueue queue = null; public Producer(BlockingQueue queue) { this.queue = queue; } public void run() { try { queue.put(&quot;1&quot;); Thread.sleep(1000); queue.put(&quot;2&quot;); Thread.sleep(1000); queue.put(&quot;3&quot;); } catch (InterruptedException e) { e.printStackTrace(); } } } 以下是 Consumer 类。它只是把对象从队列中抽取出来，然后将它们打印到 System.out。 public class Consumer implements Runnable{ protected BlockingQueue queue = null; public Consumer(BlockingQueue queue) { this.queue = queue; } public void run() { try { System.out.println(queue.take()); System.out.println(queue.take()); System.out.println(queue.take()); } catch (InterruptedException e) { e.printStackTrace(); } } } 数组阻塞队列 ArrayBlockingQueue ArrayBlockingQueue 类实现了 BlockingQueue 接口。 ArrayBlockingQueue 是一个有界的阻塞队列，其内部实现是将对象放到一个数组里。有界也就意味着，它不能够存储无限多数量的元素。它有一个同一时间能够存储元素数量的上限。你可以在对其初始化的时候设定这个上限，但之后就无法对这个上限进行修改了(译者注：因为它是基于数组实现的，也就具有数组的特性：一旦初始化，大小就无法修改)。 ‘ArrayBlockingQueue 内部以 FIFO(先进先出)的顺序对元素进行存储。队列中的头元素在所有元素之中是放入时间最久的那个，而尾元素则是最短的那个。 以下是在使用 ArrayBlockingQueue 的时候对其初始化的一个示例： BlockingQueue queue = new ArrayBlockingQueue(1024); queue.put(“1”); Object object = queue.take(); 以下是使用了 Java 泛型的一个 BlockingQueue 示例。注意其中是如何对 String 元素放入和提取的： BlockingQueue queue = new ArrayBlockingQueue(1024); queue.put(“1”); String string = queue.take(); 延迟队列 DelayQueue DelayQueue 实现了 BlockingQueue 接口。DelayQueue 对元素进行持有直到一个特定的延迟到期。注入其中的元素必须实现 java.util.concurrent.Delayed 接口，该接口定义： public interface Delayed extends Comparable&lt;Delayed&lt; { public long getDelay(TimeUnit timeUnit); } DelayQueue 将会在每个元素的 getDelay() 方法返回的值的时间段之后才释放掉该元素。如果返回的是 0 或者负值，延迟将被认为过期，该元素将会在 DelayQueue 的下一次 take 被调用的时候被释放掉。传递给 getDelay 方法的 getDelay 实例是一个枚举类型，它表明了将要延迟的时间段。 TimeUnit 枚举将会取以下值： DAYSHOURSMINUTESSECONDSMILLISECONDSMICROSECONDSNANOSECONDS 正如你所看到的，Delayed 接口也继承了 java.lang.Comparable 接口，这也就意味着 Delayed 对象之间可以进行对比。这个可能在对 DelayQueue 队列中的元素进行排序时有用，因此它们可以根据过期时间进行有序释放。以下是使用 DelayQueue 的例子： public class DelayQueueExample { public static void main(String[] args) { DelayQueue queue = new DelayQueue(); Delayed element1 = new DelayedElement(); queue.put(element1); Delayed element2 = queue.take(); } } DelayedElement 是我所创建的一个 DelayedElement 接口的实现类，它不在 Java.util.concurrent 包里。你需要自行创建你自己的 Delayed 接口的实现以使用 DelayQueue 类。 链阻塞队列 LinkedBlockingQueue LinkedBlockingQueue 类实现了 BlockingQueue 接口。 LinkedBlockingQueue 内部以一个链式结构(链接节点)对其元素进行存储。如果需要的话，这一链式结构可以选择一个上限。如果没有定义上限，将使用 Integer.MAX_VALUE 作为上限。 LinkedBlockingQueue 内部以 FIFO(先进先出)的顺序对元素进行存储。队列中的头元素在所有元素之中是放入时间最久的那个，而尾元素则是最短的那个。 以下是 LinkedBlockingQueue 的初始化和使用示例代码： BlockingQueue unbounded = new LinkedBlockingQueue();BlockingQueue bounded = new LinkedBlockingQueue(1024); bounded.put(“Value”); String value = bounded.take(); 具有优先级的阻塞队列 PriorityBlockingQueue PriorityBlockingQueue 类实现了 BlockingQueue 接口。 PriorityBlockingQueue 是一个无界的并发队列。它使用了和类 java.util.PriorityQueue 一样的排序规则。你无法向这个队列中插入 null 值。所有插入到 PriorityBlockingQueue 的元素必须实现 java.lang.Comparable 接口。因此该队列中元素的排序就取决于你自己的 Comparable 实现。注意 PriorityBlockingQueue 对于具有相等优先级(compare() == 0)的元素并不强制任何特定行为。 同时注意，如果你从一个 PriorityBlockingQueue 获得一个 Iterator 的话，该 Iterator 并不能保证它对元素的遍历是以优先级为序的。 以下是使用 PriorityBlockingQueue 的示例： BlockingQueue queue = new PriorityBlockingQueue(); //String implements java.lang.Comparable queue.put(&quot;Value&quot;); String value = queue.take(); 同步队列 SynchronousQueue SynchronousQueue 类实现了 BlockingQueue 接口。 SynchronousQueue 是一个特殊的队列，它的内部同时只能够容纳单个元素。如果该队列已有一元素的话，试图向队列中插入一个新元素的线程将会阻塞，直到另一个线程将该元素从队列中抽走。同样，如果该队列为空，试图向队列中抽取一个元素的线程将会阻塞，直到另一个线程向队列中插入了一条新的元素。 据此，把这个类称作一个队列显然是夸大其词了。它更多像是一个汇合点。 阻塞双端队列 BlockingDeque java.util.concurrent 包里的 BlockingDeque 接口表示一个线程安放入和提取实例的双端队列。本小节我将给你演示如何使用 BlockingDeque。BlockingDeque 类是一个双端队列，在不能够插入元素时，它将阻塞住试图插入元素的线程；在不能够抽取元素时，它将阻塞住试图抽取的线程。deque(双端队列) 是 “Double Ended Queue” 的缩写。因此，双端队列是一个你可以从任意一端插入或者抽取元素的队列。 BlockingDeque 的使用 在线程既是一个队列的生产者又是这个队列的消费者的时候可以使用到 BlockingDeque。如果生产者线程需要在队列的两端都可以插入数据，消费者线程需要在队列的两端都可以移除数据，这个时候也可以使用 BlockingDeque。 一个 BlockingDeque – 线程在双端队列的两端都可以插入和提取元素。 一个线程生产元素，并把它们插入到队列的任意一端。如果双端队列已满，插入线程将被阻塞，直到一个移除线程从该队列中移出了一个元素。如果双端队列为空，移除线程将被阻塞，直到一个插入线程向该队列插入了一个新元素。 BlockingDeque 的方法 BlockingDeque 具有 4 组不同的方法用于插入、移除以及对双端队列中的元素进行检查。如果请求的操作不能得到立即执行的话，每个方法的表现也不同。这些方法如下： 四组不同的行为方式解释： 抛异常：如果试图的操作无法立即执行，抛一个异常。特定值：如果试图的操作无法立即执行，返回一个特定的值(常常是 true / false)。阻塞：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行。超时：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功(典型的是 true / false)。 BlockingDeque 继承自 BlockingQueue BlockingDeque 接口继承自 BlockingQueue 接口。 这就意味着你可以像使用一个 BlockingQueue 那样使用 BlockingDeque。如果你这么干的话，各种插入方法将会把新元素添加到双端队列的尾端，而移除方法将会把双端队列的首端的元素移除。正如 BlockingQueue 接口的插入和移除方法一样。 以下是 BlockingDeque 对 BlockingQueue 接口的方法的具体内部实现： BlockingDeque 的实现 既然 BlockingDeque 是一个接口，那么你想要使用它的话就得使用它的众多的实现类的其中一个。java.util.concurrent 包提供了以下 BlockingDeque 接口的实现类： LinkedBlockingDeque BlockingDeque 代码示例 以下是如何使用 BlockingDeque 方法的一个简短代码示例： BlockingDeque deque = new LinkedBlockingDeque(); deque.addFirst(“1”);deque.addLast(“2”); String two = deque.takeLast();String one = deque.takeFirst(); 链阻塞双端队列 LinkedBlockingDeque LinkedBlockingDeque 类实现了 BlockingDeque 接口。 deque(双端队列) 是 “Double Ended Queue” 的缩写。因此，双端队列是一个你可以从任意一端插入或者抽取元素的队列。(译者注：唐僧啊，受不了。)LinkedBlockingDeque 是一个双端队列，在它为空的时候，一个试图从中抽取数据的线程将会阻塞，无论该线程是试图从哪一端抽取数据。以下是 LinkedBlockingDeque 实例化以及使用的示例： BlockingDeque deque = new LinkedBlockingDeque(); deque.addFirst(“1”);deque.addLast(“2”); String two = deque.takeLast();String one = deque.takeFirst(); 并发 Map(映射) ConcurrentMap java.util.concurrent.ConcurrentMap java.util.concurrent.ConcurrentMap 接口表示了一个能够对别人的访问(插入和提取)进行并发处理的 java.util.Map。ConcurrentMap 除了从其父接口 java.util.Map 继承来的方法之外还有一些额外的原子性方法。 ConcurrentMap 的实现 既然 ConcurrentMap 是个接口，你想要使用它的话就得使用它的实现类之一。java.util.concurrent 包具备 ConcurrentMap 接口的以下实现类： ConcurrentHashMap ConcurrentHashMap ConcurrentHashMap 和 java.util.HashTable 类很相似，但 ConcurrentHashMap 能够提供比 HashTable 更好的并发性能。在你从中读取对象的时候 ConcurrentHashMap 并不会把整个 Map 锁住。 此外，在你向其中写入对象的时候，ConcurrentHashMap 也不会锁住整个 Map。它的内部只是把 Map 中正在被写入的部分进行锁定。 另外一个不同点是，在被遍历的时候，即使是 ConcurrentHashMap 被改动，它也不会抛 ConcurrentModificationException。尽管 Iterator 的设计不是为多个线程的同时使用。更多关于 ConcurrentMap 和 ConcurrentHashMap 的细节请参考官方文档。 ConcurrentMap 例子 以下是如何使用 ConcurrentMap 接口的一个例子。 本示例使用了 ConcurrentHashMap 实现类： ConcurrentMap concurrentMap = new ConcurrentHashMap(); concurrentMap.put(“key”, “value”); Object value = concurrentMap.get(“key”); 并发导航映射 ConcurrentNavigableMap java.util.concurrent.ConcurrentNavigableMap 是一个支持并发访问的 java.util.NavigableMap，它还能让它的子 map 具备并发访问的能力。所谓的 “子 map” 指的是诸如 headMap()，subMap()，tailMap() 之类的方法返回的 map。 NavigableMap 中的方法不再赘述，本小节我们来看一下 ConcurrentNavigableMap 添加的方法。 headMap() headMap(T toKey) 方法返回一个包含了小于给定 toKey 的 key 的子 map。如果你对原始 map 里的元素做了改动，这些改动将影响到子 map 中的元素(译者注：map 集合持有的其实只是对象的引用)。以下示例演示了对 headMap() 方法的使用： ConcurrentNavigableMap map = new ConcurrentSkipListMap(); map.put(“1”, “one”);map.put(“2”, “two”);map.put(“3”, “three”); ConcurrentNavigableMap headMap = map.headMap(“2”); headMap 将指向一个只含有键 “1″ 的 ConcurrentNavigableMap，因为只有这一个键小于 “2″。关于这个方法及其重载版本具体是怎么工作的细节请参考 Java 文档。 tailMap() tailMap(T fromKey) 方法返回一个包含了不小于给定 fromKey 的 key 的子 map。 如果你对原始 map 里的元素做了改动，这些改动将影响到子 map 中的元素(译者注：map 集合持有的其实只是对象的引用)。 以下示例演示了对 tailMap() 方法的使用： ConcurrentNavigableMap map = new ConcurrentSkipListMap(); map.put(“1”, “one”);map.put(“2”, “two”);map.put(“3”, “three”); ConcurrentNavigableMap tailMap = map.tailMap(“2”); tailMap 将拥有键 “2″ 和 “3″，因为它们不小于给定键 “2″。关于这个方法及其重载版本具体是怎么工作的细节请参考 Java 文档。 subMap() subMap() 方法返回原始 map 中，键介于 from(包含) 和 to (不包含) 之间的子 map。 示例如下： ConcurrentNavigableMap map = new ConcurrentSkipListMap(); map.put(“1”, “one”);map.put(“2”, “two”);map.put(“3”, “three”); ConcurrentNavigableMap subMap = map.subMap(“2”, “3”); 返回的 submap 只包含键 “2″，因为只有它满足不小于 “2″，比 “3″ 小。 更多方法 ConcurrentNavigableMap 接口还有其他一些方法可供使用，比如： descendingKeySet()descendingMap()navigableKeySet() 关于这些方法更多信息参考官方 Java 文档。 闭锁 CountDownLatch java.util.concurrent.CountDownLatch 是一个并发构造，它允许一个或多个线程等待一系列指定操作的完成。 CountDownLatch 以一个给定的数量初始化。countDown() 每被调用一次，这一数量就减一。通过调用 await() 方法之一，线程可以阻塞等待这一数量到达零。以下是一个简单示例。 Decrementer 三次调用 countDown() 之后，等待中的 Waiter 才会从 await() 调用中释放出来。 CountDownLatch latch = new CountDownLatch(3); Waiter waiter = new Waiter(latch);Decrementer decrementer = new Decrementer(latch); new Thread(waiter) .start();new Thread(decrementer).start(); Thread.sleep(4000); public class Waiter implements Runnable{ CountDownLatch latch = null; public Waiter(CountDownLatch latch) { this.latch = latch; } public void run() { try { latch.await(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;Waiter Released&quot;); } } public class Decrementer implements Runnable { CountDownLatch latch = null; public Decrementer(CountDownLatch latch) { this.latch = latch; } public void run() { try { Thread.sleep(1000); this.latch.countDown(); Thread.sleep(1000); this.latch.countDown(); Thread.sleep(1000); this.latch.countDown(); } catch (InterruptedException e) { e.printStackTrace(); } } } 栅栏 CyclicBarrier java.util.concurrent.CyclicBarrier 类是一种同步机制，它能够对处理一些算法的线程实现同步。换句话讲，它就是一个所有线程必须等待的一个栅栏，直到所有线程都到达这里，然后所有线程才可以继续做其他事情。 图示如下： 两个线程在栅栏旁等待对方。 通过调用 CyclicBarrier 对象的 await() 方法，两个线程可以实现互相等待。一旦 N 个线程在等待 CyclicBarrier 达成，所有线程将被释放掉去继续运行。 创建一个 CyclicBarrier 在创建一个 CyclicBarrier 的时候你需要定义有多少线程在被释放之前等待栅栏。 创建 CyclicBarrier 示例： CyclicBarrier barrier = new CyclicBarrier(2); 等待一个 CyclicBarrier 以下演示了如何让一个线程等待一个 CyclicBarrier： barrier.await(); 当然，你也可以为等待线程设定一个超时时间。等待超过了超时时间之后，即便还没有达成 N 个线程等待 CyclicBarrier 的条件，该线程也会被释放出来。以下是定义超时时间示例： barrier.await(10, TimeUnit.SECONDS); 满足以下任何条件都可以让等待 CyclicBarrier 的线程释放： 最后一个线程也到达 CyclicBarrier(调用 await())当前线程被其他线程打断(其他线程调用了这个线程的 interrupt() 方法)其他等待栅栏的线程被打断其他等待栅栏的线程因超时而被释放外部线程调用了栅栏的 CyclicBarrier.reset() 方法 CyclicBarrier 行动 CyclicBarrier 支持一个栅栏行动，栅栏行动是一个 Runnable 实例，一旦最后等待栅栏的线程抵达，该实例将被执行。你可以在 CyclicBarrier 的构造方法中将 Runnable 栅栏行动传给它： Runnable barrierAction = … ;CyclicBarrier barrier = new CyclicBarrier(2, barrierAction); CyclicBarrier 示例 以下代码演示了如何使用 CyclicBarrier： Runnable barrier1Action = new Runnable() { public void run() { System.out.println(“BarrierAction 1 executed “); }};Runnable barrier2Action = new Runnable() { public void run() { System.out.println(“BarrierAction 2 executed “); }}; CyclicBarrier barrier1 = new CyclicBarrier(2, barrier1Action);CyclicBarrier barrier2 = new CyclicBarrier(2, barrier2Action); CyclicBarrierRunnable barrierRunnable1 = new CyclicBarrierRunnable(barrier1, barrier2); CyclicBarrierRunnable barrierRunnable2 = new CyclicBarrierRunnable(barrier1, barrier2); new Thread(barrierRunnable1).start();new Thread(barrierRunnable2).start(); CyclicBarrierRunnable 类： public class CyclicBarrierRunnable implements Runnable{ CyclicBarrier barrier1 = null; CyclicBarrier barrier2 = null; public CyclicBarrierRunnable( CyclicBarrier barrier1, CyclicBarrier barrier2) { this.barrier1 = barrier1; this.barrier2 = barrier2; } public void run() { try { Thread.sleep(1000); System.out.println(Thread.currentThread().getName() + &quot; waiting at barrier 1&quot;); this.barrier1.await(); Thread.sleep(1000); System.out.println(Thread.currentThread().getName() + &quot; waiting at barrier 2&quot;); this.barrier2.await(); System.out.println(Thread.currentThread().getName() + &quot; done!&quot;); } catch (InterruptedException e) { e.printStackTrace(); } catch (BrokenBarrierException e) { e.printStackTrace(); } } } 以上代码控制台输出如下。注意每个线程写入控制台的时序可能会跟你实际执行不一样。比如有时 Thread-0 先打印，有时 Thread-1 先打印。 Thread-0 waiting at barrier 1Thread-1 waiting at barrier 1BarrierAction 1 executedThread-1 waiting at barrier 2Thread-0 waiting at barrier 2BarrierAction 2 executedThread-0 done!Thread-1 done! 交换机 Exchanger java.util.concurrent.Exchanger 类表示一种两个线程可以进行互相交换对象的会和点。这种机制图示如下： 两个线程通过一个 Exchanger 交换对象。交换对象的动作由 Exchanger 的两个 exchange() 方法的其中一个完成。 以下是一个示例： Exchanger exchanger = new Exchanger(); ExchangerRunnable exchangerRunnable1 = new ExchangerRunnable(exchanger, “A”); ExchangerRunnable exchangerRunnable2 = new ExchangerRunnable(exchanger, “B”); new Thread(exchangerRunnable1).start();new Thread(exchangerRunnable2).start(); ExchangerRunnable 代码： public class ExchangerRunnable implements Runnable{ Exchanger exchanger = null; Object object = null; public ExchangerRunnable(Exchanger exchanger, Object object) { this.exchanger = exchanger; this.object = object; } public void run() { try { Object previous = this.object; this.object = this.exchanger.exchange(this.object); System.out.println( Thread.currentThread().getName() + &quot; exchanged &quot; + previous + &quot; for &quot; + this.object ); } catch (InterruptedException e) { e.printStackTrace(); } } } 以上程序输出：Thread-0 exchanged A for BThread-1 exchanged B for A 信号量 Semaphore java.util.concurrent.Semaphore 类是一个计数信号量。这就意味着它具备两个主要方法： acquire()release() 计数信号量由一个指定数量的 “许可” 初始化。每调用一次 acquire()，一个许可会被调用线程取走。每调用一次 release()，一个许可会被返还给信号量。因此，在没有任何 release() 调用时，最多有 N 个线程能够通过 acquire() 方法，N 是该信号量初始化时的许可的指定数量。这些许可只是一个简单的计数器。这里没啥奇特的地方。 Semaphore 用法 信号量主要有两种用途： 保护一个重要(代码)部分防止一次超过 N 个线程进入。在两个线程之间发送信号。 保护重要部分 如果你将信号量用于保护一个重要部分，试图进入这一部分的代码通常会首先尝试获得一个许可，然后才能进入重要部分(代码块)，执行完之后，再把许可释放掉。 比如这样： Semaphore semaphore = new Semaphore(1); //critical sectionsemaphore.acquire(); … semaphore.release(); 在线程之间发送信号 如果你将一个信号量用于在两个线程之间传送信号，通常你应该用一个线程调用 acquire() 方法，而另一个线程调用 release() 方法。如果没有可用的许可，acquire() 调用将会阻塞，直到一个许可被另一个线程释放出来。同理，如果无法往信号量释放更多许可时，一个 release() 调用也会阻塞。 通过这个可以对多个线程进行协调。比如，如果线程 1 将一个对象插入到了一个共享列表(list)之后之后调用了 acquire()，而线程 2 则在从该列表中获取一个对象之前调用了 release()，这时你其实已经创建了一个阻塞队列。信号量中可用的许可的数量也就等同于该阻塞队列能够持有的元素个数。 公平 没有办法保证线程能够公平地可从信号量中获得许可。也就是说，无法担保掉第一个调用 acquire() 的线程会是第一个获得一个许可的线程。如果第一个线程在等待一个许可时发生阻塞，而第二个线程前来索要一个许可的时候刚好有一个许可被释放出来，那么它就可能会在第一个线程之前获得许可。如果你想要强制公平，Semaphore 类有一个具有一个布尔类型的参数的构造子，通过这个参数以告知 Semaphore 是否要强制公平。强制公平会影响到并发性能，所以除非你确实需要它否则不要启用它。 以下是如何在公平模式创建一个 Semaphore 的示例： Semaphore semaphore = new Semaphore(1, true); 更多方法 java.util.concurrent.Semaphore 类还有很多方法，比如： availablePermits()acquireUninterruptibly()drainPermits()hasQueuedThreads()getQueuedThreads()tryAcquire()等等 这些方法的细节请参考 Java 文档。 @本知识本人借阅了ImportNew]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[myGitOneDay]]></title>
    <url>%2F2017%2F08%2F04%2FmyGitOneDay%2F</url>
    <content type="text"></content>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PowerDesigner]]></title>
    <url>%2F2017%2F06%2F10%2FPowerDesigner%2F</url>
    <content type="text"><![CDATA[1.什么是PowerDesigner 引入百度百科的说法是： power designer是能进行数据库设计的强大的软件，是一款开发人员常用的数据库建模工具。使用它可以分别从概念数据模型(Conceptual Data Model)和物理数据模型(Physical Data Model)两个层次对数据库进行设计。在这里，概念数据模型描述的是独立于数据库管理系统(DBMS)的实体定义和实体关系定义；物理数据模型是在概念数据模型的基础上针对目标数据库管理系统的具体化。 2.什么是数据模型呢？ 数据模型是现实世界中数据特征的抽象。数据模型应该满足三个方面的要求：1）能够比较真实地模拟现实世界2）容易为人所理解3）便于计算机实现 恩？什么鬼，还是不懂～继续看 概念数据模型也称信息模型，它以实体－联系(Entity-RelationShip,简称E-R)理论为基础，并对这一理论进行了扩充。它从用户的观点出发对信息进行建模，主要用于数据库的概念级设计。 通常人们先将现实世界抽象为概念世界，然后再将概念世界转为机器世界。换句话说，就是先将现实世界中的客观对象抽象为实体(Entity)和联系(Relationship),它并不依赖于具体的计算机系统或某个DBMS系统，这种模型就是我们所说的CDM;然后再将CDM转换为计算机上某个DBMS所支持的数据模型，这样的模型就是物理数据模型,即PDM 有关数据模型的知识，想加深学习大家可以网上学习，IT人要懂得利用网络知识。 3.可以帮我们做哪些事 ㈠设计类图 ㈡使用PowerDesigner设计数据库关系以后，可以生成HTML,供团队成员进行讨论。 ㈢使用PowerDesigner进行面向对象分析与UML建模 动态模型 动态图包括：状态图（Statechart Diagram）、顺序图（Sequence Diagram）、协作图（Collaboration Diagram）和活动图（Activity Diagram）。 状态图：描述系统元素的状态变化。 顺序图：描述按时间顺序系统元素之间的交互。 协作图：按时空的顺序描述系统元素之间的交互和关系。 活动图：描述系统元素的活动。 功能模型 五种视图包括：用例视图、结构模型（逻辑）视图、行为模型（并发）视图、实现模型（组件）视图和部署视图。 用例视图：从用户角度表达系统功能（使用用例图+活动图）描述。 结构模型（逻辑）视图：主要使用类图和对象图描述系统静态结构，用状态图、顺序图、协作图和活动图描述对象间实现给定功能时的动态协作关系。 行为模型（并发）视图：展示系统动态行为以及其并发性，用状态图、顺序图、协作图、活动图、组件图和部署图描述。 实现模型（组件）视图：展示系统实现的结构和行为描述，用组件图描述。 部署视图：展示系统的实现环境和组件是如何在物理结构中部署的，用部署图描述。 注： 能用Powerdesigner作图就尽量用，尽量不要使用Visio；虽然很多图之间都可以转换，但要自己判断转换后的图是否有意义；所有的code都需要用规范的英文名称；模型间的关系有依赖、泛化、关联、实现四种PowerDesigner下载 链接: http://pan.baidu.com/s/1cd1pjK 密码: uea4 另：PowerDesigner是收费软件，提倡小伙伴通过正规渠道购买正版版权使用（给个表情你应该知道我在说神马 ） 注：汉化版也是博园一位神奇的博主自主捣腾的，汉化参考博园地址：http://www.cnblogs.com/yeaicc/p/PowerDesigner16CN.html]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>PowerDesigner</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM垃圾回收算法及回收器]]></title>
    <url>%2F2016%2F09%2F01%2FJVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E5%8F%8A%E5%9B%9E%E6%94%B6%E5%99%A8%2F</url>
    <content type="text"><![CDATA[本文主要讲述JVM中几种常见的垃圾回收算法和相关的垃圾回收器，以及常见的和GC相关的性能调优参数。 GC Roots 我们先来了解一下在Java中是如何判断一个对象的生死的，有些语言比如Python是采用引用计数来统计的，但是这种做法可能会遇见循环引用的问题，在Java以及C#等语言中是采用GC Roots来解决这个问题。如果一个对象和GC Roots之间没有链接，那么这个对象也可以被视作是一个可回收的对象。 Java中可以被作为GC Roots中的对象有： 虚拟机栈中的引用的对象。方法区中的类静态属性引用的对象。方法区中的常量引用的对象。本地方法栈（jni）即一般说的Native的引用对象。 垃圾回收算法 标记清除 标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。在标记阶段首先通过根节点，标记所有从根节点开始的对象，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。标记清除算法带来的一个问题是会存在大量的空间碎片，因为回收后的空间是不连续的，这样给大对象分配内存的时候可能会提前触发full gc。 复制算法 将现有的内存空间分为两快，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。 现在的商业虚拟机都采用这种收集算法来回收新生代，IBM研究表明新生代中的对象98%是朝夕生死的，所以并不需要按照1:1的比例划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一个Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1(可以通过-SurvivorRattio来配置)，也就是每次新生代中可用内存空间为整个新生代容量的90%，只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保。 标记整理 复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活的对象较多，复制的成本也将很高。标记-压缩算法是一种老年代的回收算法，它在标记-清除算法的基础上做了一些优化。首先也需要从根节点开始对所有可达对象做一次标记，但之后，它并不简单地清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。 增量算法 增量算法的基本思想是，如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。 垃圾回收器 Serial收集器 Serial收集器是最古老的收集器，它的缺点是当Serial收集器想进行垃圾回收的时候，必须暂停用户的所有进程，即stop the world。到现在为止，它依然是虚拟机运行在client模式下的默认新生代收集器，与其他收集器相比，对于限定在单个CPU的运行环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾回收自然可以获得最高的单线程收集效率。 Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用”标记－整理“算法。这个收集器的主要意义也是被Client模式下的虚拟机使用。在Server模式下，它主要还有两大用途：一个是在JDK1.5及以前的版本中与Parallel Scanvenge收集器搭配使用，另外一个就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure的时候使用。 通过指定-UseSerialGC参数，使用Serial + Serial Old的串行收集器组合进行内存回收。 ParNew收集器 ParNew收集器是Serial收集器新生代的多线程实现，注意在进行垃圾回收的时候依然会stop the world，只是相比较Serial收集器而言它会运行多条进程进行垃圾回收。 ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百的保证能超越Serial收集器。当然，随着可以使用的CPU的数量增加，它对于GC时系统资源的利用还是很有好处的。它默认开启的收集线程数与CPU的数量相同，在CPU非常多（譬如32个，现在CPU动辄4核加超线程，服务器超过32个逻辑CPU的情况越来越多了）的环境下，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。 -UseParNewGC: 打开此开关后，使用ParNew + Serial Old的收集器组合进行内存回收，这样新生代使用并行收集器，老年代使用串行收集器。 Parallel Scavenge收集器 Parallel是采用复制算法的多线程新生代垃圾回收器，似乎和ParNew收集器有很多的相似的地方。但是Parallel Scanvenge收集器的一个特点是它所关注的目标是吞吐量(Throughput)。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)。停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能够提升用户的体验；而高吞吐量则可以最高效率地利用CPU时间，尽快地完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。 Parallel Old收集器是Parallel Scavenge收集器的老年代版本，采用多线程和”标记－整理”算法。这个收集器是在jdk1.6中才开始提供的，在此之前，新生代的Parallel Scavenge收集器一直处于比较尴尬的状态。原因是如果新生代Parallel Scavenge收集器，那么老年代除了Serial Old(PS MarkSweep)收集器外别无选择。由于单线程的老年代Serial Old收集器在服务端应用性能上的”拖累“，即使使用了Parallel Scavenge收集器也未必能在整体应用上获得吞吐量最大化的效果，又因为老年代收集中无法充分利用服务器多CPU的处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定有ParNew加CMS的组合”给力“。直到Parallel Old收集器出现后，”吞吐量优先“收集器终于有了比较名副其实的应用祝贺，在注重吞吐量及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。 -UseParallelGC: 虚拟机运行在Server模式下的默认值，打开此开关后，使用Parallel Scavenge + Serial Old的收集器组合进行内存回收。-UseParallelOldGC: 打开此开关后，使用Parallel Scavenge + Parallel Old的收集器组合进行垃圾回收 CMS收集器 CMS(Concurrent Mark Swep)收集器是一个比较重要的回收器，现在应用非常广泛，我们重点来看一下，CMS一种获取最短回收停顿时间为目标的收集器，这使得它很适合用于和用户交互的业务。从名字(Mark Swep)就可以看出，CMS收集器是基于标记清除算法实现的。它的收集过程分为四个步骤： 初始标记(initial mark)并发标记(concurrent mark)重新标记(remark)并发清除(concurrent sweep) 注意初始标记和重新标记还是会stop the world，但是在耗费时间更长的并发标记和并发清除两个阶段都可以和用户进程同时工作。 不过由于CMS收集器是基于标记清除算法实现的，会导致有大量的空间碎片产生，在为大对象分配内存的时候，往往会出现老年代还有很大的空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前开启一次Full GC。为了解决这个问题，CMS收集器默认提供了一个-XX:+UseCMSCompactAtFullCollection收集开关参数（默认就是开启的)，用于在CMS收集器进行FullGC完开启内存碎片的合并整理过程，内存整理的过程是无法并发的，这样内存碎片问题倒是没有了，不过停顿时间不得不变长。虚拟机设计者还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction参数用于设置执行多少次不压缩的FULL GC后跟着来一次带压缩的（默认值为0，表示每次进入Full GC时都进行碎片整理）。 不幸的是，它作为老年代的收集器，却无法与jdk1.4中已经存在的新生代收集器Parallel Scavenge配合工作，所以在jdk1.5中使用cms来收集老年代的时候，新生代只能选择ParNew或Serial收集器中的一个。ParNew收集器是使用-XX:+UseConcMarkSweepGC选项启用CMS收集器之后的默认新生代收集器，也可以使用-XX:+UseParNewGC选项来强制指定它。 由于CMS收集器现在比较常用，下面我们再额外了解一下CMS算法的几个常用参数： UseCMSInitatingOccupancyOnly：表示只在到达阈值的时候，才进行 CMS 回收。为了减少第二次暂停的时间，通过-XX:+CMSParallelRemarkEnabled开启并行remark。如果ramark时间还是过长的话，可以开启-XX:+CMSScavengeBeforeRemark选项，强制remark之前开启一次minor gc，减少remark的暂停时间，但是在remark之后也立即开始一次minor gc。CMS默认启动的回收线程数目是(ParallelGCThreads + 3)/4，如果你需要明确设定，可以通过-XX:+ParallelCMSThreads来设定，其中-XX:+ParallelGCThreads代表的年轻代的并发收集线程数目。CMSClassUnloadingEnabled： 允许对类元数据进行回收。CMSInitatingPermOccupancyFraction：当永久区占用率达到这一百分比后，启动 CMS 回收 (前提是-XX:+CMSClassUnloadingEnabled 激活了)。CMSIncrementalMode：使用增量模式，比较适合单 CPU。UseCMSCompactAtFullCollection参数可以使 CMS 在垃圾收集完成后，进行一次内存碎片整理。内存碎片的整理并不是并发进行的。UseFullGCsBeforeCompaction：设定进行多少次 CMS 垃圾回收后，进行一次内存压缩。 一些建议 对于Native Memory: 使用了NIO或者NIO框架（Mina/Netty）使用了DirectByteBuffer分配字节缓冲区使用了MappedByteBuffer做内存映射 由于Native Memory只能通过FullGC回收，所以除非你非常清楚这时真的有必要，否则不要轻易调用System.gc()。 另外为了防止某些框架中的System.gc调用（例如NIO框架、Java RMI），建议在启动参数中加上-XX:+DisableExplicitGC来禁用显式GC。这个参数有个巨大的坑，如果你禁用了System.gc()，那么上面的3种场景下的内存就无法回收，可能造成OOM，如果你使用了CMS GC，那么可以用这个参数替代：-XX:+ExplicitGCInvokesConcurrent。 此外除了CMS的GC，其实其他针对old gen的回收器都会在对old gen回收的同时回收young gen。 G1收集器 G1收集器是一款面向服务端应用的垃圾收集器。HotSpot团队赋予它的使命是在未来替换掉JDK1.5中发布的CMS收集器。与其他GC收集器相比，G1具备如下特点： 并行与并发：G1能更充分的利用CPU，多核环境下的硬件优势来缩短stop the world的停顿时间。分代收集：和其他收集器一样，分代的概念在G1中依然存在，不过G1不需要其他的垃圾回收器的配合就可以独自管理整个GC堆。空间整合：G1收集器有利于程序长时间运行，分配大对象时不会无法得到连续的空间而提前触发一次GC。可预测的非停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。 在使用G1收集器时，Java堆的内存布局和其他收集器有很大的差别，它将这个Java堆分为多个大小相等的独立区域，虽然还保留新生代和老年代的概念，但是新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。 虽然G1看起来有很多优点，实际上CMS还是主流。 与GC相关的常用参数 除了上面提及的一些参数，下面补充一些和GC相关的常用参数： -Xmx: 设置堆内存的最大值。-Xms: 设置堆内存的初始值。-Xmn: 设置新生代的大小。-Xss: 设置栈的大小。-PretenureSizeThreshold: 直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接在老年代分配。-MaxTenuringThrehold: 晋升到老年代的对象年龄。每个对象在坚持过一次Minor GC之后，年龄就会加1，当超过这个参数值时就进入老年代。-UseAdaptiveSizePolicy: 在这种模式下，新生代的大小、eden 和 survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。在手工调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量 (GCTimeRatio) 和停顿时间 (MaxGCPauseMills)，让虚拟机自己完成调优工作。-SurvivorRattio: 新生代Eden区域与Survivor区域的容量比值，默认为8，代表Eden: Suvivor= 8: 1。-XX:ParallelGCThreads：设置用于垃圾回收的线程数。通常情况下可以和 CPU 数量相等。但在 CPU 数量比较多的情况下，设置相对较小的数值也是合理的。-XX:MaxGCPauseMills：设置最大垃圾收集停顿时间。它的值是一个大于 0 的整数。收集器在工作时，会调整 Java 堆大小或者其他一些参数，尽可能地把停顿时间控制在 MaxGCPauseMills 以内。-XX:GCTimeRatio:设置吞吐量大小，它的值是一个 0-100 之间的整数。假设 GCTimeRatio 的值为 n，那么系统将花费不超过 1/(1+n) 的时间用于垃圾收集。]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代理模式]]></title>
    <url>%2F2016%2F08%2F25%2F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[说说 JAVA 代理模式 本文内容借阅来自ImportNew中 事例 小张是一个普普通通的码农，每天勤勤恳恳地码代码。某天中午小张刚要去吃饭，一个电话打到了他的手机上。“是XX公司的小张吗？我是YY公司的王AA”。“哦，是王总啊，有什么事情吗？”。沟通过后，小张弄明白了,原来客户有个需求，刚好负责这方面开发的是小张，客户就直接找到了他。不过小张却没有答应客户的请求，而是让客户找产品经理小李沟通。 是小张着急去吃面而甩锅吗？并不是，只是为了使故事可以套到代理模式上。我们先看一下代理模式的定义： * 为其他对象提供一种代理，以控制对这个对象的访问。(Provide a surrogate or placeholder for another object to control access to it) 对照定义，码农小张可以映射为其他对象，产品经理小李为小张的代理。我们通过JAVA代码，表述上面事例。 静态代理 1.抽象角色 基于面向对象的思想，首先定义一个码农接口,它有一个实现用户需求的方法。 public interface ICoder { public void implDemands(String demandName); } 2.真实角色 我们假设小张是JAVA程序员，定义一个JAVA码农类，他通过JAA语言实现需求。 public class JavaCoder implements ICoder{ private String name; public JavaCoder(String name){ this.name = name; } @Override public void implDemands(String demandName) { System.out.println(name + &quot; implemented demand:&quot; + demandName + &quot; in JAVA!&quot;); } } 3.代理角色 委屈一下产品经理，将其命名为码农代理类，同时让他实现ICoder接口。 public class CoderProxy implements ICoder{ private ICoder coder; public CoderProxy(ICoder coder){ this.coder = coder; } @Override public void implDemands(String demandName) { coder.implDemands(demandName); } } 上面一个接口，两个类，就实现了代理模式。Are you kidding me？这么简单？是的，就是这么简单。 我们通过一个场景类，模拟用户找产品经理增加需求。 public class Customer { public static void main(String args[]){ //定义一个java码农 ICoder coder = new JavaCoder(&quot;Zhang&quot;); //定义一个产品经理 ICoder proxy = new CoderProxy(coder); //让产品经理实现一个需求 proxy.implDemands(); } } 运行程序，结果如下： Zhang implemented demand:Add user manageMent in JAVA! 产品经理充当了程序员的代理，客户把需求告诉产品经理，并不需要和程序员接触。看到这里，有些机智的程序员发现了问题。你看，产品经理就把客户的需求转达了一下，怪不得我看产品经理这么不爽。 产品经理当然不只是转达用户需求，他还有很多事情可以做。比如，该项目决定不接受新增功能的需求了，对修CoderProxy类做一些修改： public class CoderProxy implements ICoder{ private ICoder coder; public CoderProxy(ICoder coder){ this.coder = coder; } @Override public void implDemands(String demandName) { if(demandName.startsWith(&quot;Add&quot;)){ System.out.println(&quot;No longer receive &apos;Add&apos; demand&quot;); return; } coder.implDemands(demandName); } } 这样，当客户再有增加功能的需求时，产品经理就直接回绝了，程序员无需再对这部分需求做过滤。 总结 我们对上面的事例做一个简单的抽象： 代理模式包含如下角色： Subject:抽象主题角色。可以是接口，也可以是抽象类。 RealSubject:真实主题角色。业务逻辑的具体执行者。 ProxySubject:代理主题角色。内部含有RealSubject的引用,负责对真实角色的调用，并在真实主题角色处理前后做预处理和善后工作。 代理模式优点： 职责清晰 真实角色只需关注业务逻辑的实现，非业务逻辑部分，后期通过代理类完成即可。 高扩展性 不管真实角色如何变化，由于接口是固定的，代理类无需做任何改动。 动态代理 前面讲的主要是静态代理。那么什么是动态代理呢？ 假设有这么一个需求，在方法执行前和执行完成后，打印系统时间。这很简单嘛，非业务逻辑，只要在代理类调用真实角色的方法前、后输出时间就可以了。像上例，只有一个implDemands方法，这样实现没有问题。但如果真实角色有10个方法，那么我们要写10遍完全相同的代码。有点追求的码农，肯定会对这种方法感到非常不爽。有些机智的小伙伴可能想到了用AOP解决这个问题。非常正确。莫非AOP和动态代理有什么关系？没错！AOP用的恰恰是动态代理。 代理类在程序运行时创建的代理方式被称为动态代理。也就是说，代理类并不需要在Java代码中定义，而是在运行时动态生成的。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类的函数。对于上例打印时间的需求，通过使用动态代理，我们可以做一个“统一指示”，对所有代理类的方法进行统一处理，而不用逐一修改每个方法。下面我们来具体介绍下如何使用动态代理方式实现我们的需求。 与静态代理相比，抽象角色、真实角色都没有变化。变化的只有代理类。因此，抽象角色、真实角色，参考ICoder和JavaCodr。 在使用动态代理时，我们需要定义一个位于代理类与委托类之间的中介类，也叫动态代理类，这个类被要求实现InvocationHandler接口： public class CoderDynamicProxy implements InvocationHandler{ //被代理的实例 private ICoder coder; public CoderDynamicProxy(ICoder _coder){ this.coder = _coder; } //调用被代理的方法 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(System.currentTimeMillis()); Object result = method.invoke(coder, args); System.out.println(System.currentTimeMillis()); return result; } } 当我们调用代理类对象的方法时，这个“调用”会转送到中介类的invoke方法中，参数method标识了我们具体调用的是代理类的哪个方法，args为这个方法的参数。 我们通过一个场景类，模拟用户找产品经理更改需求。 public class DynamicClient { public static void main(String args[]){ //要代理的真实对象 ICoder coder = new JavaCoder(&quot;Zhang&quot;); //创建中介类实例 InvocationHandler handler = new CoderDynamicProxy(coder); //获取类加载器 ClassLoader cl = coder.getClass().getClassLoader(); //动态产生一个代理类 ICoder proxy = (ICoder) Proxy.newProxyInstance(cl, coder.getClass().getInterfaces(), handler); //通过代理类，执行doSomething方法； proxy.implDemands(&quot;Modify user management&quot;); } } 执行结果如下： 1501728574978 Zhang implemented demand:Modify user management in JAVA! 1501728574979 通过上述代码，就实现了，在执行委托类的所有方法前、后打印时间。还是那个熟悉的小张，但我们并没有创建代理类，也没有时间ICoder接口。这就是动态代理。 总结 总结一下，一个典型的动态代理可分为以下四个步骤： 创建抽象角色 创建真实角色 通过实现InvocationHandler接口创建中介类 通过场景类，动态生成代理类 如果只是想用动态代理，看到这里就够了。但如果想知道为什么通过proxy对象，就能够执行中介类的invoke方法，以及生成的proxy对象是什么样的，可以继续往下看。 源码分析(JDK7) 看到这里的小伙伴，都是有追求的程序员。上面的场景类中，通过 //动态产生一个代理类 ICoder proxy = (ICoder) Proxy.newProxyInstance(cl, coder.getClass().getInterfaces(), handler); 动态产生了一个代理类。那么这个代理类是如何产生的呢？我们通过代码一窥究竟。 Proxy类的newProxyInstance方法，主要业务逻辑如下： //生成代理类class，并加载到jvm中 Class&lt;?&gt; cl = getProxyClass0(loader, interfaces); //获取代理类参数为InvocationHandler的构造函数 final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); //生成代理类，并返回 return newInstance(cons, ih); 上面代码做了三件事： 根据传入的参数interfaces动态生成一个类，它实现interfaces中的接口，该例中即ICoder接口的implDemands方法。假设动态生成的类为$Proxy0。 通过传入的classloder,将刚生成的$Proxy0类加载到jvm中。 利用中介类，调用$Proxy0的$Proxy0(InvocationHandler)构造函数，创建$Proxy0类的实例，其InvocationHandler属性，为我们创建的中介类。 上面的核心，就在于getProxyClass0方法： private static Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) { if (interfaces.length &gt; 65535) { throw new IllegalArgumentException(&quot;interface limit exceeded&quot;); } // If the proxy class defined by the given loader implementing // the given interfaces exists, this will simply return the cached copy; // otherwise, it will create the proxy class via the ProxyClassFactory return proxyClassCache.get(loader, interfaces); } 在Proxy类中有个属性proxyClassCache，这是一个WeakCache类型的静态变量。它指示了类加载器和代理类之间的映射。所以proxyClassCache的get方法用于根据类加载器来获取Proxy类，如果已经存在则直接从cache中返回，如果没有则创建一个映射并更新cache表。 我们跟一下代理类的创建流程： 调用Factory类的get方法，而它又调用了ProxyClassFactory类的apply方法，最终找到下面一行代码： //Generate the specified proxy class. byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces); 就是它，生成了代理类。 查看动态生成的代理类 通过上面的分析，我们已经知道Proxy类动态创建代理类的流程。那创建出来的代理类到底是什么样子的呢？我们可以通过下面的代码，手动生成： public class CodeUtil { public static void main(String[] args) throws IOException { byte[] classFile = ProxyGenerator.generateProxyClass(&quot;TestProxyGen&quot;, JavaCoder.class.getInterfaces()); File file = new File(&quot;D:/aaa/TestProxyGen.class&quot;); FileOutputStream fos = new FileOutputStream(file); fos.write(classFile); fos.flush(); fos.close(); } } 通过反编译工具查看生成的class文件: import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import java.lang.reflect.UndeclaredThrowableException; import model.proxy.ICoder; public final class TestProxyGen extends Proxy implements ICoder { private static Method m1; private static Method m0; private static Method m3; private static Method m2; public TestProxyGen(InvocationHandler paramInvocationHandler) throws { super(paramInvocationHandler); } public final boolean equals(Object paramObject) throws { try { return ((Boolean)this.h.invoke(this, m1, new Object[] { paramObject })).booleanValue(); } catch (RuntimeException localRuntimeException) { throw localRuntimeException; } catch (Throwable localThrowable) { } throw new UndeclaredThrowableException(localThrowable); } public final int hashCode() throws { try { return ((Integer)this.h.invoke(this, m0, null)).intValue(); } catch (RuntimeException localRuntimeException) { throw localRuntimeException; } catch (Throwable localThrowable) { } throw new UndeclaredThrowableException(localThrowable); } public final void implDemands(String paramString) throws { try { this.h.invoke(this, m3, new Object[] { paramString }); return; } catch (RuntimeException localRuntimeException) { throw localRuntimeException; } catch (Throwable localThrowable) { } throw new UndeclaredThrowableException(localThrowable); } public final String toString() throws { try { return (String)this.h.invoke(this, m2, null); } catch (RuntimeException localRuntimeException) { throw localRuntimeException; } catch (Throwable localThrowable) { } throw new UndeclaredThrowableException(localThrowable); } static { try { m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[] { Class.forName(&quot;java.lang.Object&quot;) }); m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]); m3 = Class.forName(&quot;model.proxy.ICoder&quot;).getMethod(&quot;implDemands&quot;, new Class[] { Class.forName(&quot;java.lang.String&quot;) }); m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]); return; } catch (NoSuchMethodException localNoSuchMethodException) { throw new NoSuchMethodError(localNoSuchMethodException.getMessage()); } catch (ClassNotFoundException localClassNotFoundException) { } throw new NoClassDefFoundError(localClassNotFoundException.getMessage()); } } 这样，我们就理解，为什么调用代理类的implDemands方法，回去执行中介类的invoke方法了。 看完本文有收获？请转发分享给更多人]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊java8时间与日期]]></title>
    <url>%2F2016%2F08%2F22%2Fjava8%E6%97%B6%E9%97%B4%E4%B8%8E%E6%97%A5%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[相信大家都有这样感觉，Java操作日期和时间的时候，会有一些麻烦。你也许会通过System.currentTimeMillis() 来返回1970年1月1日到今天的毫秒数。或者使用Date类来操作日期；当遇到加减月份、天数的时候 你又需要用到Calendar类；当需要格式化日期的时候需要使用java.text.DateFormat类。所以说在Java中操作日期不是很方便，以至于很多开发者不得不使用第三方库。 JAVA8以的API前存在的问题： 线程安全: Date和Calendar不是线程安全的，你需要编写额外的代码处理线程安全问题 API设计和易用性: 由于Date和Calendar的设计不当你无法完成日常的日期操作 ZonedDate和Time: 你必须编写额外的逻辑处理时区和那些旧的逻辑 好在JSR 310规范中为Java8添加了新的API， 在java.time包中，新的API纠正了过去的缺陷， 新的日期API ZoneId: 时区ID，用来确定Instant和LocalDateTime互相转换的规则 Instant: 用来表示时间线上的一个点 LocalDate: 表示没有时区的日期, LocalDate是不可变并且线程安全的 LocalTime: 表示没有时区的时间, LocalTime是不可变并且线程安全的 LocalDateTime: 表示没有时区的日期时间, LocalDateTime是不可变并且线程安全的 Clock: 用于访问当前时刻、日期、时间，用到时区 Duration: 用秒和纳秒表示时间的数量 最常用的就是LocalDate、LocalTime、LocalDateTime了，从它们的名字就可以看出是操作日期 和时间的。这些类是主要用于当时区不需要显式地指定的上下文。在本章节中我们将讨论最常用的api。 LocalDate LocalDate代表一个IOS格式(yyyy-MM-dd)的日期，可以存储 生日、纪念日等日期。 获取当前的日期： LocalDate localDate = LocalDate.now(); System.out.println(“localDate: “ + localDate); localDate: 2017-07-20 LocalDate可以指定特定的日期，调用of或parse方法返回该实例： LocalDate.of(2017, 07, 20); LocalDate.parse(“2017-07-20”); 当然它还有一些其他方法，我们一起来看看： 为今天添加一天，也就是获取明天 LocalDate tomorrow = LocalDate.now().plusDays(1); 从今天减去一个月 LocalDate prevMonth = LocalDate.now().minus(1, ChronoUnit.MONTHS); 下面写两个例子，分别解析日期 2017-07-20，获取每周中的星期和每月中的日： DayOfWeek thursday = LocalDate.parse(“2017-07-20”).getDayOfWeek(); System.out.println(“周四: “ + thursday); int twenty = LocalDate.parse(“2017-07-20”).getDayOfMonth(); System.out.println(“twenty: “ + twenty); 试试今年是不是闰年: boolean leapYear = LocalDate.now().isLeapYear(); System.out.println(“是否闰年: “ + leapYear); 判断是否在日期之前或之后: boolean notBefore = LocalDate.parse(“2017-07-20”) .isBefore(LocalDate.parse(&quot;2017-07-22&quot;)); System.out.println(“notBefore: “ + notBefore); boolean isAfter = LocalDate.parse(“2017-07-20”).isAfter(LocalDate.parse(“2017-07-22”)); System.out.println(“isAfter: “ + isAfter); 获取这个月的第一天: LocalDate firstDayOfMonth = LocalDate.parse(“2017-07-20”) .with(TemporalAdjusters.firstDayOfMonth()); System.out.println(“这个月的第一天: “ + firstDayOfMonth); firstDayOfMonth = firstDayOfMonth.withDayOfMonth(1); System.out.println(“这个月的第一天: “ + firstDayOfMonth); 判断今天是否是我的生日，例如我的生日是 2009-07-20 LocalDate birthday = LocalDate.of(2009, 07, 20); MonthDay birthdayMd = MonthDay.of(birthday.getMonth(), birthday.getDayOfMonth()); MonthDay today = MonthDay.from(LocalDate.now()); System.out.println(“今天是否是我的生日: “ + today.equals(birthdayMd)); LocalTime LocalTime表示一个时间，而不是日期，下面介绍一下它的使用方法。 获取现在的时间，输出15:01:22.144 LocalTime now = LocalTime.now(); System.out.println(“现在的时间: “ + now); 将一个字符串时间解析为LocalTime，输出15:02 LocalTime nowTime = LocalTime.parse(“15:02”); System.out.println(“时间是: “ + nowTime); 使用静态方法of创建一个时间 LocalTime nowTime = LocalTime.of(15, 02); System.out.println(“时间是: “ + nowTime); 使用解析字符串的方式并添加一小时，输出16:02 LocalTime nextHour = LocalTime.parse(“15:02”).plus(1, ChronoUnit.HOURS); System.out.println(“下一个小时: “ + nextHour); 获取时间的小时、分钟 int hour = LocalTime.parse(“15:02”).getHour(); System.out.println(“小时: “ + hour); int minute = LocalTime.parse(“15:02”).getMinute(); System.out.println(“分钟: “ + minute); 我们也可以通过之前类似的API检查一个时间是否在另一个时间之前、之后 boolean isBefore = LocalTime.parse(“15:02”).isBefore(LocalTime.parse(“16:02”)); boolean isAfter = LocalTime.parse(“15:02”).isAfter(LocalTime.parse(“16:02”)); System.out.println(“isBefore: “ + isBefore); System.out.println(“isAfter: “ + isAfter); 输出 isBefore: true, isAfter: false。 在LocalTime类中也将每天的开始和结束作为常量供我们使用: System.out.println(LocalTime.MAX); System.out.println(LocalTime.MIN); 输出: 23:59:59.999999999 00:00 LocalTime就这些了，下面我们来了解一下LocalDateTime LocalDateTime LocalDateTime是用来表示日期和时间的，这是一个最常用的类之一。 获取当前的日期和时间: LocalDateTime now = LocalDateTime.now(); System.out.println(“现在: “ + now); 输出 现在: 2017-07-20T15:17:19.926 下面使用静态方法和字符串的方式分别创建LocalDateTime对象 LocalDateTime.of(2017, Month.JULY, 20, 15, 18); LocalDateTime.parse(“2017-07-20T15:18:00”); `` 同时LocalDateTime也提供了相关API来对日期和时间进行增减操作: ```java LocalDateTime tomorrow = now.plusDays(1); System.out.println(“明天的这个时间: “ + tomorrow); LocalDateTime minusTowHour = now.minusHours(2); System.out.println(“两小时前: “ + minusTowHour); 这个类也提供一系列的get方法来获取特定单位: Month month = now.getMonth(); System.out.println(“当前月份: “ + month); 日期格式化 在日常开发中我们用到最多的也许就是日期、时间的格式化了，那在Java8种该如何操作呢？ LocalDateTime now = LocalDateTime.now(); DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(“yyyy-MM-dd HH:mm:ss”); System.out.println(“默认格式化: “ + now); System.out.println(“自定义格式化: “ + now.format(dateTimeFormatter)); LocalDateTime localDateTime = LocalDateTime.parse(“2017-07-20 15:27:44”, dateTimeFormatter); System.out.println(“字符串转LocalDateTime: “ + localDateTime); 也可以使用DateTimeFormatter的format方法将日期、时间格式化为字符串 DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(“yyyy-MM-dd”); String dateString = dateTimeFormatter.format(LocalDate.now()); System.out.println(“日期转字符串: “ + dateString); 日期周期 Period类用于修改给定日期或获得的两个日期之间的区别。 给初始化的日期添加5天: LocalDate initialDate = LocalDate.parse(“2017-07-20”); LocalDate finalDate = initialDate.plus(Period.ofDays(5)); System.out.println(“初始化日期: “ + initialDate); System.out.println(“加日期之后: “ + finalDate); 周期API中提供给我们可以比较两个日期的差别，像下面这样获取差距天数: long between = ChronoUnit.DAYS.between(initialDate, finalDate); System.out.println(“差距天数: “ + between); 上面的代码会返回5，当然你想获取两个日期相差多少小时也是简单的。 与遗留代码转换 在之前的代码中你可能出现了大量的Date类，如何将它转换为Java8种的时间类呢？ Date和Instant互相转换 Date date = Date.from(Instant.now()); Instant instant = date.toInstant(); Date转换为LocalDateTime LocalDateTime localDateTime = LocalDateTime.from(new Date()); System.out.println(localDateTime); LocalDateTime转Date Date date = Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant()); LocalDate转Date Date date = Date.from(LocalDate.now().atStartOfDay().atZone(ZoneId.systemDefault()).toInstant]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反射实践]]></title>
    <url>%2F2016%2F07%2F01%2FJava%E5%8F%8D%E5%B0%84%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[Java 反射机制应用实践 Java反射机制是一个非常强大的功能，在很多大型项目比如Spring, Mybatis中都可以看见反射的身影。通过反射机制我们可以在运行期间获取对象的类型信息，利用这一特性我们可以实现工厂模式和代理模式等设计模式，同时也可以解决Java泛型擦除等令人苦恼的问题。本文我们就从实际应用的角度出发，来应用一下Java的反射机制。 反射基础 p.s: 本文需要读者对反射机制的API有一定程度的了解，如果之前没有接触过的话，建议先看一下官方文档的Quick Start。 在应用反射机制之前，首先我们先来看一下如何获取一个对象对应的反射类Class，在Java中我们有三种方法可以获取一个对象的反射类。 通过getClass方法 在Java中，每一个Object都有一个getClass()方法，通过getClass方法我们可以获取到这个对象对应的反射类： String s = “http://www.ziwenxie.site“;Class&lt;?&gt; c = s.getClass(); 通过forName方法 我们也可以调用Class类的静态方法forName()： Class&lt;?&gt; c = Class.forName(“java.lang.String”); 使用.class 或者我们也可以直接使用.class： Class&lt;?&gt; c = String.class; 获取类型信息 在文章开头我们就提到反射的一大好处就是可以允许我们在运行期间获取对象的类型信息，下面我们通过一个例子来具体看一下。 首先我们在typeinfo.interfacea包下面新建一个接口A： package typeinfo.interfacea;public interface A { void f(); } 接着我们在typeinfo.packageaccess包下面新建一个类C，类C实现了接口A，并且我们还另外创建了几个用于测试的方法，注意下面几个方法的权限都是不同的。 package typeinfo.packageaccess;import typeinfo.interfacea.A;class C implements A { public void f() { System.out.println(“public C.f()”); } public void g() { System.out.println(“public C.g()”); } protected void v () { System.out.println(“protected C.v()”); } void u() { System.out.println(“package C.u()”); } private void w() { System.out.println(“private C.w()”); }}public class HiddenC { public static A makeA() { return new C(); }} 在callHiddenMethod()方法中我们用到了几个新的API，其中getDeclaredMethod()根据方法名用于获取Class类指代对象自己声明的某个方法，然后我们通过调用invoke()方法就可以触发对象的相关方法： package typeinfo;import typeinfo.interfacea.A;import typeinfo.packageaccess.HiddenC;import java.lang.reflect.Method;public class HiddenImplementation { public static void main(String[] args) throws Exception { A a = HiddenC.makeA(); a.f(); System.out.println(a.getClass().getName()); // Oops! Reflection still allows us to call g(): callHiddenMethod(a, “g”); // And even methods that are less accessible! callHiddenMethod(a, “u”); callHiddenMethod(a, “v”); callHiddenMethod(a, “w”); } static void callHiddenMethod(Object a, String methodName) throws Exception { Method g = a.getClass().getDeclaredMethod(methodName); g.setAccessible(true); g.invoke(a); }} 从输出结果我们可以看出来，不管是public，default，protect还是private方法，通过反射类我们都可以自由调用。当然这里我们只是为了显示反射的强大威力，在实际开发中这种技巧还是不提倡。 public C.f()typeinfo.packageaccess.Cpublic C.g()package C.u()protected C.v()private C.w() 上面我们只是测试了Method对象，感兴趣的读者在熟悉了反射的API之后，不妨测试一下Filed，这里我们就不重复了。 利用动态代理实现面向切面编程 AOP是Spring提供的一个强大特性之一，AOP的意思是面向切面编程，就是说要分离和业务不相关的代码，当我们需要新增相关的事务的时候，我们不想要对业务本身做修改。面向切面编程和面向对象变成相比到底有什么好处呢，我们通过一个例子来看一下，对于新手来说，常常会写出下面这样的代码： public class Example1 { public void execute() { // 记录日志 Logger logger = Logger.getLog(…); // 进行性能统计 PerformanceUtil.startTimer(…); // 权限检查 if (!user.hasPrevilege()) { // 抛出异常 } // 执行真正的业务 executeTransaction(); PerformanceUtil.endTimer(); }} 虽然我们上面真正要执行的业务只有executeTransaction()，但是日志，性能，权限相关的代码差不多要将真正的业务代码掩盖了。而且以后如果我们还有一个Example2，它同样需要实现相同的日志，性能，权限代码。这样当以后我们需要新增相关的逻辑检查的时候，我们需要所有Example进行重构，这显然不符合面向对象的一个基本原则-封装变化。 上面这个场景利用模板方法和装饰器模式都可以解决，在Spring中是通过动态代理来实现的，下面我们通过一个例子来模拟一下Spring中的AOP实现。 我们要实现的业务时，统计程序统计员工工资所执行的时间以及检查用户的权限。首先先来实现的Salary类，它里面包含一些实现统计员工工资的业务逻辑： public interface SalaryInterface { public void doSalary();} public class Salary implements SalaryInterface { public void doSalary() { … }} 通过InvocationHandler我们来实现动态代理，以后当我们调用obj的相关方法之前，都会通过invoke方法进行代理，而不会直接调用obj方法。 public class SimpleProxy implements InvocationHandler { private Object obj; private Object advice; // 绑定代理对象 public Object bind(Object obj, Advice advice) { this.obj = obj; this.advice = advice; return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), this) } // 实现代理 public Object invoke(Object proxy, Method method, Object[] args) throws Throwalbe { Object result = null; try { advice.before(); result = method.invoke(obj, args); advice.after(); } catch(Exception e) { e.printStackTrace(); } return result }} 模拟Spring中的Advice接口： public interface Advice { public void before(); public void after();} 实现TimeAdvice用于统计程序的执行时间： public class TimeAdvice implements Advice { long startTime; long endTime; @Override public void before() { startTime = System.nanoTime(); // 获取开始时间 } @Override public void after() { endTime = System.nanoTime(); // 获取结束时间 }} 客户端调用代码如下： public class Client { public static void main(String[] args) { SimpleProxy = new SimpleProxy(); SalaryInterface salaryInterface = (SalaryInterface) simpleProxy.bind(new Salary(), new TimeAdvice()); salaryInterface.doSalary(); }} 如果我们现在需要新增权限控制，我们来实现ControlAdvie类： public class ControlAdvice implements Advice { @Override public void before() { if (…) { … } else { … } } @Override public void after() { … }} 而我们客户端的代码只需要改成simpleProxy.bind(new Salary(), new ControlAdvie)就行了，而SimpleProxy本身不需要做任何的修改。 与注解相结合 在单元测试框架比如Junit中反射机制也得到了广泛的应用，即通过注解的方式。下面我们简单地来了解一下如何通过反射机制来获取相关方法的注解信息，比如说我们有下面这样一个业务场景，当用户在修改自己密码的时候，为了保证密码的安全性，我们要求用户的新密码要满足一些条件，比如说至少要包含一个非数字字符，不能与以前的密码相同之类的条件等。 import java.lang.annotation.*@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface UserCase { public int id(); public String description() default “no description”;} 下面是我们检测密码的工具类的实现： public class PasswordUtils { @UserCase(id=47, description=”Password must contain at least one numeric”) public boolean validatePassword(String password) { return (password.matches(“\w\d\w“)); } @UserCase(id=48) public String encryptPassword(String password) { return new StringBuilder(password).reverse().toString(); } @UserCase(id=49, description=”New passwords can’t equal previously used ones”) public boolean checkForNewPassword(List prevPasswords, String password) { return !prevPasswords.contains(password); }} 利用反射我们可以写出更加清晰的测试代码，其中getDeclaredMethods()方法可以获取相关对象自己声明的相关方法，而getAnnotation()则可以获取Method对象的指定注解。 public class UseCaseTracker { public static void trackUseCases(List useCases, Class&lt;?&gt; cl) { for(Method m : cl.getDeclaredMethods()) { UseCase uc = m.getAnnotation(UseCase.class); if(uc != null) { System.out.println(“Found Use Case: “ + uc.id() + “ “ + uc.description()); useCases.remove(new Integer(uc.id())); } } for(int i : useCases) { System.out.println(“Warning: Missing use case-“ + i); } } public static void main(String[] args) { List useCases = new ArrayList(); Collections.addAll(useCases, 47, 48, 49, 50); trackUseCases(userCases, PasswordUtils.class); }} 解决泛型擦除 现在有下面这样一个业务场景，我们有一个泛型集合类List]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新的经济周期已经到来]]></title>
    <url>%2F2015%2F09%2F02%2F%E6%96%B0%E7%9A%84%E7%BB%8F%E6%B5%8E%E5%91%A8%E6%9C%9F%E5%B7%B2%E7%BB%8F%E5%88%B0%E6%9D%A5%2F</url>
    <content type="text"><![CDATA[新的经济周期已经到来，这个周期的“房地产、金融、互联网”是谁？ 创业者的核心是找准趋势提前布局深耕细作，时机成熟风自然会来。 一、慌和丧时代 前些日子，李文星事件爆发，Boss直聘一夜之间成了众矢之的。媒体人、自媒体、网友纷纷声讨，呼吁对招聘平台展开严查。这件事情的背后，是招聘app们为了快速爆发、野蛮生长，而大大降低了审核和互动门槛，对平台上涌入的各种虚假可疑公司熟视无睹，是一种监管的不作为。 对招聘领域来说，这当然不是个好消息。可没有好消息的，又岂止招聘行业？ 慌和丧，这两种情绪互相交织，横亘了整个上半年的互联网创投圈。 慌。前些日子，风头正劲的付费社群产品“小密圈”忽然被传下架。尽管公司一再声称这只是“技术性升级”，并且在朋友圈征得新名“知识星球”。但产品“涉及色情和敏感信息”的传言还是甚嚣尘上。一时间满城风雨，同类产品们风声鹤唳、噤若寒蝉。 这不是先例。在此之前，已经有多个被资本们吹上天的“风口”，在政策监管的铁腕面前烟消云散。在国家意志面前，资本的投机炒作不堪一击。 滴滴火了，但是很快最严厉的网约车管制接踵而至，而来自国家的反垄断调查一直在继续。 直播火了，国家一句必须要有试听节目许可证，就让200家直播公司转眼倒下或即将倒下，而诸如黄鳝门等事件打击力度之快之大超出预期。 p2p火了，互金最严整顿也来了，破产跑路无数，从红岭清盘到陆金所传言，现在你还敢进吗，进得了吗？ 内容领域火了，但是自媒体当家花旦咪蒙都可以关进黑屋30天，更何况毒舌电影这些热门号一夜倒下，一时间人人都在猜测、下一个被关的会是谁？ 游戏火了，王者荣耀火遍全中国，于是官媒的联合声讨也来了…… 在这样一种诚惶诚恐的局面下，很多人的情绪已经开始转为“丧”。 当然，也有人根本没把风险放在眼里，先捞到钱再说，能捞到多少是多少。这边互联网金融风声鹤唳，那边他玩ico6得飞起，虚拟货币的暴富神话一时又让人看不明白了。 很多人在问，2017年的风口究竟是什么？在我看来，不论风口是什么，最大的关注点应该是十九大。因为只有十九大开了，国家定了调，我们才知道什么能做、什么不能做，什么国家倡导，什么即便暂时没有禁止、长远来看也一定会面临系统性风险。 而很多人的关注点，已经开始从“究竟做什么赚钱”，转向“什么即使赚钱，长远来看也绝不能做”。 二、上一个周期的逻辑 凛冬将至，上述苦恼绝不仅仅只在互联网一家。 有人说，一个人赚了很多钱是能力问题，但是一个人赚了很多很多很多很多很多……钱，就是时代的问题，是踩准了风口，享受了大趋势带来的红利和泡沫。 回顾这一个经济周期，这样的“红利”非常明显有三个：金融、房地产和互联网。 再往细一点儿说，是金融的“宽松和创新”，是房地产的“投机和炒作”，是互联网的“泡沫和野蛮生长”。本质上说，很多人吃的都是“监管红利”，是在政策宽松或滞后的情况下，通过“钻空子”斩获了史无前例的巨大红利。中国的市场是全球最大的市场，稍微漏出一点风，乘以13亿人，成就的都是亿万资产。 但是今天，全国金融工作会议的召开，金融全面进入“规范和整肃”的时代；伴随着房市严控、租售同权等一系列政策的推出，国家已经给出了信号：这次是动真格的，中国的钱有大用、不能统统吸进楼市黑洞。 而在互联网领域，最严厉高效的监管正在步步走来，以前野蛮生长的方式可能行不通了。 野蛮生长就是互联网的原罪，怎么个野蛮法？ 三、互联网原罪的十字口诀 有人说，在中国最挣钱的方法，其实都写在《刑法》里。这句话虽然过于夸张，但反映在互联网上很明显的一点是：创业者们要想异军突起、迅速逆袭，老老实实一般是行不通的，往往要行走在“灰色地带”，打下三路和擦边球。 可以说，过去几年互联网产品的快速爆发，除了日常刚需工具，其他多半是迎合人性的黑暗面，做多巴胺、伏隔核、心流机制的操控家，简言之就是十字口诀：黄毒假抄懒，斗贴装谣灰。 1、黄 黄，就是色情的力量。性的威力永远是不言而喻的，从传说中的草榴，到约炮神器的横行，从直播平台上晃动的乳沟，到cj上看不尽的大腿……互联网产品即使没有明确的制黄贩黄，也常常作出大量的性暗示和感官刺激。遗憾的是，这一点对于我们这个习惯了故作清高的民族却是异常奏效的，特别是对大多数的底层屌丝用户、几乎立竿见影。这从约炮神器上一度惊人的用户数据和色流诈骗吓人的成功率中可以得证。 2、毒 毒，就是利用各种类似赌博的上瘾机制、让用户沉迷其中。这一点在游戏领域极其明显，网上一直有传言，《王者荣耀》的团队一个重要的研究是，如何在5分钟内让你上瘾。 3、假 假，电商平台相对传统商家，往往可以给出惊人优惠的价格，但其中一些却可能是假冒伪劣。特别在发展的早期，往往成为重灾区，价格便宜往往以品质掺水为代价。 4、抄 抄，擅长抄袭、美其名曰“改良式创新”几乎是中国互联网公司的通病，或者盗版、打着信息公开分享的名义侵犯创作者权益。截至今日，中国的互联网公司已经几乎抄袭了西方所有流行或不流行的产品和商业模式，甚至连综艺、内容和包装设计都能抄即抄、拿来主义。即便本土偶有创新，好不容易从0到1的新创公司只要稍有成就，也会转眼被大公司和资本裹挟的对手们（背景优越的团队）“抄死”。尽管国家一直喊着万众创新，但实际创投圈完全在失控的丛林状态，对创新的不友好到达了史上最严酷的程度。 5、懒 懒，即利用用户的懒惰，提供更加简单高效、可以依赖的解决方案。这是大多数工具性产品的出发点，只要用户对工具产生依赖离不开，就成了任人宰割的羔羊。为什么迅雷、暴风越改版越让人受不了，广告繁多、界面复杂？说到底还是商业诉求在作祟，一开始是用户体验第一，等用户依赖了就翻身做主人、商业诉求力压用户体验。 6、斗 斗，发动群众斗群众，利用各种矛盾造热点、搏眼球、吸流量。从微博的围观到贴吧的爆吧，从知乎的撕逼到网易的评论，从直男癌与田园女权的征战，到地图炮、阶层炮、年龄炮、行业炮的炮火连天……各大平台可谓谙熟了中国人喜好站队互踩、在与人斗其乐无穷中发泄无聊和寻求优越感的心理，网路暴力伴随群体潜意识四处横行。 7、贴 贴，简言之就是补贴。互联网经济总想制造“价格优势”，从低价到特惠到免费到倒贴钱，背后是资本们的人傻钱多、一掷千金、烧钱补贴抢市场。 8、装 装，利用人们的装逼心理，满足用户的虚荣心。从脸萌到足记，从“你的思维更接近东方、西方”到“你是欢乐颂中的谁”，从星座解读的横行到各种心理测试题，无不抓住中国用户的一种心理：想要装逼又必需表面低调、所以借你产品来释放一下。 9、谣 谣，好事不出门、坏事传千里，中国人对各种谣言八卦总是具有特殊的癖好。早年微博的各种曝光、匿名社交平台的横行、各种八卦号的一度爆火，都论证来这一点，窥私欲具有着不可阻挡的诱惑。 10、灰 灰，就是将各种灰色产业合法化。滴滴刚开始，很多时候就是把“黑车”合法化；p2p的横行，很多是给过去的民间高利贷披上了合法外衣。 往细里看，那些面对c端取得大小成就的互联网公司们，谁敢拍着胸脯，说自己的爆发和以上10条没有一点干系？ 四、红利的褪尽 在阶层日益固化的今天，人们越来越关注所谓“红利”。因为只有时代的红利，才能让底层和中产们挣脱可怕的宿命，获得进入“上流城堡”的最后通道。没有这样的红利，你就算赚得还不错，也永远都是做生意、给人打工、挣辛苦钱，富人们早就在“食利”了。 但是很遗憾，在互联网领域，传统意义的红利都在褪尽，而且是从2015年下半年就开始了。 1、人口红利消失了 中国人基本上已经人手一部智能机了，新增手机用户上涨进入了瓶颈期，同时换机的频率也逐步降低，整个移动互联网市场进入了存量时代。新的装机用户越来越少了，谁去应用市场下载你的app呢？于是，获客成本开始激增，互联网创业“低成本起步”的优势消失了。 2、心智瓜分大势确定 打开应用市场，从工具到娱乐到本地商务，所有显而易见的通用需求，都已经有一堆产品堵在那里了，特别是其中的“头部产品”往往已经牢牢占据了用户的心智空间，即便体验已经不是最好，其地位也很难撼动。围绕不同场景、需求和习惯的心智空间已经被瓜分完毕了，互联网创业进入了需求稀缺难寻的时代。此种情况下作出来的产品，要么需求是yy出来的，要么需求不通约天花板太低，要么即便体验确实更好，却沉没在头部产品投射的阴影中，养在深闺人不知，获客成本比头部高出许多倍（没他钱多，还比他获客贵）。 3、寡头垄断局面已经形成 过去是BAT，现在是AT，过去是2vc，现在是2at，腾讯和阿里已经开始成为中国互联网中无处不在的巨力。每一条赛道，只要稍微火，很快就会有他们的身影，要么果断跟进抄抄抄，要么砸钱投资买买买。而新公司们赖以生存的流量管道，也多数被他们把在手里，想造反？先让你的产品分享不到朋友圈，先让你的支付接不上。 4、资本“疯投”破坏生态 很多事情一开始是绝对赚钱的，财务模型也很清晰，比如共享单车、共享充电宝、部分o2o甚至刚开始的团购。可惜的是，这都是在良性竞争的理想状态下。中国的问题是，一个领域稍微有一点儿赚钱，资本就可能带着抄袭者们疯狂进场，从千团大战到百播大战到千车大战，现在甚至狼人杀领域都开始千狼混战。这种情况屡屡发生，蓝海转眼变红海，好好的产品创新转眼变成烧钱补贴抢用户的资本修罗场，创业者成了资本的傀儡。于是，一个红利满满的市场转眼做滥做臭做死，各种同质化恶性竞争甚嚣尘上，要不了多久，一拥而上就会变成一哄而上，创业者纷纷倒下，资本收割了速度离场。不要小看这一点，这世上到处是背景优越、团队豪华、被资本看好却没有方向的团队，资本美其名曰“我就是投人”，如果没背景的你不小心发现了一块沃土，他们就像苍蝇闻着肉香一样扑过来了。 5、最关键的是，十字口诀不灵了。 五、新机会 新的经济周期已经到来，这个周期的“房地产、金融、互联网”是谁？ 在《未来5年大机会——从实用到娱乐，“国民总时间”的结构性变局》中，笔者已经指出：在经济下行的大背景下，我们迎来了一个“口红经济”和“奶嘴乐”的时代，消费和娱乐会上扬。 对于无法在技术领域取得巨大突破、抑或是在线下无法拥有巨大资本资源的草根玩家们来说，这里确实就是机会：产品和商业模式创新，收割娱乐时间和消费升级（相对上流社会是降级）。 说起来容易做起来难，我们又要注意几个点： 1、必须是健康和正面的 不要以为娱乐的崛起就是多巴胺与荷尔蒙的狂欢，就是软色情、暴力、游戏的乐土。《王者荣耀》被围攻和直播管制的例子已经表明：互联网正处在十多个政府部门最严厉的管制之下，更有朝阳群众随时监督，你简单粗暴只怕越来越走不通。 所以，未来能够做大做强的娱乐一定是健康益智、寓教于乐的，像象棋、健身一样远离红线、不易被指摘。那些一味引人沉迷、荒废正业、低俗色情的娱乐模式，会和过去一样容易速火，但只怕死也死得更快。健康积极的娱乐将贯穿在我们的整个社会生活中，内容、培训、商务等各个方面。 但健康积极的娱乐谈何容易，在处处是“一夜暴富”神话的今天，又有多少创业者和投资人经得起慢工细活的忍耐？ 2、警惕潮流性 娱乐爆发也好，消费升级也罢，需要警惕的是其潮流性，即往往“火一把就死”，而不能从流行到经典，这样的速生速死是不可能支撑起一个新时代大公司的。所以，你应该去做“标准化”的产品，要设法抢占心智成为头部，甚至有可能成为未来人们娱乐消费生活方式的档次标准或基础设施。 3、越高端，流量越分散 很多人喜欢说服务中高端人群、做消费升级，但是很遗憾，我们发现在中国，越是做“下三路”接近底层的需求，往往用户流量越集中，约炮、打车、便宜货、傻瓜型游戏……但是越往中高端做，越是作用于人性的优点和人们的自我提升，这个流量就越分散。因为越是底层的需求越是相似，越容易成为人们的最大公约数，也越容易平台化。但越是向上的需求就越分散，不同人眼中有不同的情怀兴致，不同人眼中有不同的逼格档次，不同人眼中有不同的健康品味，不同人眼中有不同的充电方式……越是向上的需求就越是小圈子化，所以你很容易触到人群的天花板，如何精准捕获分散的目标客群，如何做高毛利，这些都会非常重要。 4、中产的钱不好赚 很多人认为，屌丝就是免费，中产就是消费升级，消费升级就是人傻钱多有钱任性。但是实践中，中产的消费可能更加理性和谨慎，更善于精打细算，一方面他们有足够的信息源来做这样的“计算”，另一方面中产面临着“向上上不去、向下却随时可能滑落底层”的困境，很多人都是接近上流的精致外表、接近屌丝的可支配收入。所以如何征服他们的心，可没有那么容易。 5、做小弟的思想准备 在这样的情势下，真的不要天天想着做大平台、想着颠覆BAT、想着改变世界了，高筑墙、广积粮、缓称王，先学会容易腾讯和阿里的体系中、老老实实从小弟做起比较重要。想想看，牛如乔布斯，当年不也一样不得不暂时对盖茨“称臣”？创业首先是生意，找到现金活下去才有勃勃野心。 6、快速变现，轻资本依赖 过去几年，大量公司的衰落，其实是因为创业者把大多数时间都放在了融资上，和投资人觥筹交错四处周旋，却始终没有功夫聚焦在产品、员工和市场一线上，而后者才是真正的重要。这样的结果也造成了一种逆淘汰，谁背景好会融资，谁就能一直跑下去，哪怕产品和商业模式很多和一坨屎一样，大不了直接抄袭做的好的就行了。这样的逆淘汰到最后，走出来的公司都是重度资本依赖型公司，都是资本家们的提线木偶。没有显赫背景的草根创业者们显然不能这么玩儿，所以拜托你不要讲“先烧钱、做免费大平台、流量成规模了再变现”的故事，这个故事太奢侈不属于你。 你要做的是简化商业模型、缩短盈利链条，尽快地闷声赚钱，这样哪怕有大家伙进场，只要有钱赚至少你活得下去。不要在想什么“英雄不问出身”了，那都是投资人套你点子之前的说辞，人家心里可都是对你的背景明码标价着呢。 7、创新和壁垒更重要 时至今日，从0到1的创新的重要变得史无前例，因为玩“模仿加微创新”，你不仅玩不过BAT，玩不过TMD，恐怕一个陌陌也能把你抄死。草根玩家在别人主场的赛道上再怎么创新，别人只要稍稍动一动产品、玩一玩资本、分分钟就能把你弄死。 所以，两种思维会比较重要： 一是第一性原理，不比照市面上已经有的产品，而是回归用户需求本初；二是破坏性创新，减少主流对手长期专注、持续发展以至效率过分的部分，把关注点放到其他价值诉求上，并且不断深耕，由于双方基础理念结构不同，强敌不大可能转而追随。但即便这样我也要说，中国现在最关键的是专利制度，是创新保护，否则我苦心孤诣好不容易找到一个杀手锏，申请专利用了一年半，你凭着资本人傻钱多分分钟把我干了，这个局还有什么意义，以后还会有人创新吗？ 保护中小创业者，从保护创新开始，救救创业救救创新！ 8、找趋势，不追风口 喜马拉雅上卫哲老师一句话非常好： 要寻找未来的趋势，而不是追风口。趋势是长期的必然的，而风口则是可以通过短期炒作、资本哄抬制造出来的“热点”。截至今天，相当多的风口已经被证明是“伪需求泡沫”，根本不是未来趋势，你去追不是送死吗？更何况，当一个领域成为风口的时候，往往之前已经有几十家企业在那里深耕了半年一年，主流投资人估计都进去过了一遍，这个时候你才反应过来要追，还来得及吗？当一个事情已经成为风口时，它多半已经和你无关了。 所以，创业者的核心是找准趋势提前布局深耕细作，时机成熟风自然会来。只不过，很多人是心理还没过断奶期，没有融资就不敢创业，所以一定要2vc，一定要追风口。 六、未必是坏事 总结一句，对于大多数草根玩家来说，可以融入大公司生态、具有创新壁垒、围绕年轻一代（准）中产阶级、盈利路径短、现金流清晰、低资本依赖、健康积极可持续的娱乐和消费，或者大公司体系下的2b服务，会存在越来越多的机会，甚至存在平台级大机遇的可能。 但是回到开头，今年是创业者尤其需要“讲政治”的一年，只有一个最重要的背景，19大的召开。毕竟，经历了前景如此混沌不明、几乎看不到多少大机会的16年，我们迫切地需要知道，这个国家下一个重要的棋子将落在何方？ 科技趋势，政治走向，市场规律，社会思潮，这四大合力的系统性结果，才能让我们看清新一个周期下“时代的红利”究竟为何。 过去的路都不灵了，但这未必是坏事。大争之世，英雄方能崛起于草莽之间。 对于新来者来说，最大的优点或许是“没有包袱、没有惯性、没有原罪”，因为上个周期能走得通的模式现在都不灵了，你轻装上阵，很多事情从头开始，这带来了宝贵的重新洗牌的机会。 不要怕寒冬，因为生来就在寒冬中，没有什么可以失去，除了“思维的锁链”。 祝好运，再过个五年，我们看谁是新经济周期中的马云、马化腾、王健林。 #专栏作家#]]></content>
      <categories>
        <category>创业知识</category>
      </categories>
      <tags>
        <tag>创业</tag>
      </tags>
  </entry>
</search>