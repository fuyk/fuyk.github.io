<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[时间观念]]></title>
    <url>%2F2017%2F08%2F26%2F%E6%97%B6%E9%97%B4%E8%A7%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[时间的概念因为我们不知道，究竟什么对我们最重要，所以，每件事都花不少时间，盲目行动，浪费时间。有些人看到我们每一件事都做， 所以，他们期望我们什么都做。每一件事都做让我们非常忙碌，所以，我们没有时间去考虑，究竟什么对我们重要。怎么去规划时间，管理时间，不让时间管理我们。时间，在我们人生中是最珍贵的，所以，我们要高效率利用它。 1.大家可能问时间有什么意义？ 我废话少说，大家想象五年后的你?然后我们把这个5年倒回来看看。 What you are doing in 5 years? 你可能长叹一口气，……yes?（哈哈） 我的回答可能是：拥有一家大数据，物联网相关的公司正在运营（这是自己的一个痴心妄想，也踏上这条路的初心，哈哈）。那么第四年，公司已经成熟，有固定的客户，业务，稳定业绩。第三年，公司逐步进入正轨，走上成熟，走过重重浴火，终于要变成小鸟，凤凰就不敢了。第二年，公司刚刚成立不久，正是瓶颈期，为业务种种发愁。第一年，公司注册，团队组建完成，公司选址等等准备完成。 这个只是的简单想法，只是为了举例让读者明白罢了。 2.个人的处理事情的原则（可以给大家参考），我分为五类 ①重要紧急②重要不紧急③紧急不重要（委托授权）④不重要不紧急 符永坤（富伊克fuyk） 著]]></content>
      <categories>
        <category>职业知识</category>
      </categories>
      <tags>
        <tag>职业修养</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[致即将毕业的我]]></title>
    <url>%2F2017%2F08%2F26%2F%E8%87%B4%E6%AF%95%E4%B8%9A%E7%9A%84%E8%87%AA%E5%B7%B1%2F</url>
    <content type="text"><![CDATA[面临毕业的自己，听师兄师姐们的侃侃而谈，自己也担忧起了自己的就业前程，毕业就是失业。所以自己也有了面临就业的临危感，俗话说祸起 乃于萧蔷也。归根结底是自己的问题，我的座右铭是：世上无难事，只要肯登攀。机会是留给有准备的人，此时的我又激情澎湃了。所以埋头学习了起来。拿起笔学习有关职业方面知识。 1.1准备职业人定位 1.1.1那么什么是职业人? 人力资源专家胡斌曾把人分为：“没人经营的人”，“别人经营的人”，“自我经营的人”和“经营别人的人”四种。职业人属于那个范畴相信大家已有所思 既然进入企业，职业人必须按企业对员工的标准要求自己，这是职业人基本素质。 1.2由院校人向企业人转变 在学校时的几个特点： 》可以与喜欢的人在一起，自己选择性。 》可以喜形于色。 》考试通过就OK，分数比什么都重要，而且闭卷考试（不可以其他辅助完成）。 》事情自己做的，成绩当然归功于自己 》喜欢做“与众不同的人” 》自由性强 》。。。。。。。。。。。大家可以集思广益 所以我们必须转变思想，向企业，社会转型》 ①个人--团队导向 在学校中，以自我为中心的模式不适合于企业，个人的成功必须与整体的成功结合才有意义。一荣俱荣，一损俱损，重个性 转变到重标准；以个人衡量到集体衡量；独创到协作；独行到合作。 ②情感--职业导向 情绪化是学生显著的特征之一，职业场格格不入的，注重游戏规则，个人好恶不能左右于你。 ③思维--行为导向 学生学习，重在开发智力，学习知识，往往都是3思维的训练。这也是和企业有很大的不同，转变也就必不可少了。 思维至上转变到产品至上；想到就行转到做到才行，而且要做到最好；理论家转变到实干家；注重思考，分析。 ⑤个人资源--组织资源 1.2.1企业目标 企业需要对客户负责，对社会负责，对投资者负责，对员工负责。 联想公司对员工要求，也是招聘人才的要求： 1.知识，是基础。 2.人际交往。团队合作和团队精神，现代企业非常注重。 3.责任感。对自己所做的事情负责 4.能力，知识不等于能力，能力取决于个人执行力等等。 5.敬业。干一行爱一行，真正爱自己的工作，不是爱一行，干一行。企业不花钱养废人。]]></content>
      <categories>
        <category>职业知识</category>
      </categories>
      <tags>
        <tag>职业修养</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux（一）]]></title>
    <url>%2F2017%2F08%2F25%2FLinux%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[先说明本文：图片没有贴出，大家认真阅读不影响 一 ：为什么学Linux Linux的历史发展大家可以百度一些，了解了解就ok,学利用一切可以利用的资源； 1.Linux的特点： 第一： 免费开源，了解它的发展就知道为什么开源了，一款完全的免费的操作系统，都可以下载它的源码，没有什么限制。 第二： 模块化程度高。 Linux 的 内核 设计 分成 进程 管理、 内存 管理、进程 间 通信、 虚拟 文件 系统、 网络 5 部分， 其 采用 的 模块 机制 使得 用户 可以 根据 实际 需要， 在 内核 中 插入 或 移走 模块， 这使 得 内核 可以 被 高度 的 剪裁 定制， 以 方便 在 不同 的 场景 下 使用。 . 第三： 广泛 的 硬件 支持。 得 益于 其 免费 开源 的 特点， 有 大批 程序员 不断 地 向 Linux 社区 提供 代码， 使得 Linux 有着 异常 丰富 的 设备 驱动 资源， 对 主流 硬件 的 支持 极好， 而且 几乎 能 运行 在 所有 流行 的 处理器 上。 第四： 安全 稳定。 Linux 采取 了 很多 安全 技术 措施， 包括 读写 权限 控制、 带 保护 的 子系统、 审计 跟踪、 核心 授权 等， 这 为 网络 环境 中的 用户 提供 了 安全保障。 实际 上有 很多 运行 Linux 的 服务器 可以 持续 运行 长达 数年 而 无须 重 启， 依然 可以 性能 良好 地 提供 服务， 其 安全 稳定性 已经 在各 个领域 得到 了 广泛 的 证实。 第五： 多用户， 多任务。 多用户 是指 系统 资源 可以 同时 被 不同 的 用户 使用， 每个 用户 对 自己的 资源 有 特定 的 权限， 互不 影响。 多任务 是 现代化 计算机的 主要 特点， 指的 是 计算 机能 同时 运行 多个 程序， 且 程序 之间 彼此 独立， Linux 内核 负责 调度 每个 进程， 使之 平等 地 访问 处理器。 由于 CPU 处理 速度 极快， 从 用户 的 角度 来看 所有 的 进程 好像 在 并行 运行。 第六： 良好 的 可移植性。 Linux 中 95% 以上 的 代码 都是 用 C 语言 编写 的， 由于 C 语言 是一 种 机器 无关 的 高级 语言， 是 可 移植 的， 因此 Linux 系统 也是 移植的 1.2Linux优点： 稳定、免费或者花费少 安全性高 多任务，多用户 耗资源少 由于内核小，所以它可以支持多种电子产品，如：Android手机、PDA等 1.3安装（建议初学者可以以下） 在安装Linux系统之前，先来了解windows系统结构，windows系统一般是安装在C盘系统盘，同样Linux也有类似的系统盘（/根分区），Linux通常分区为（根分区/、swap分区），Linux系统以文件的存储方式，所有的文件都是存储在某个目录下的，类似于windows的文件夹。对于文件系统的属性来说，windows文件系统类型一般是ntfs、fat32等，而Linux文件系统类型则为ext2、ext3、ext4等（文件系统：是操作系统用于明确磁盘或分区上的文件的方法和数据结构，文件系统由三部分组成：与文件管理有关软件、被管理文件以及实施文件管理所需数据结构。）安装 Linux系统是每一个初学者的第一个门槛。在这个过程中间，最大的困惑莫过于给硬盘进行分区。虽然现在各种发行版本的 Linux 已经提供了友好的图形交互界面，但是很多人还是感觉无从下手。这其中的原因主要是不清楚 Linux 的分区规定。就好比如果我们了解了windows分区的规则，系统盘C、数据盘D等，就很好分区了。在 Linux 中规定，每一个硬盘设备最多只能有 4个主分区（其中包含扩展分区）构成，任何一个扩展分区都要占用一个主分区号码，也就是在一个硬盘中，主分区和扩展分区一共最多是 4 个。下面正式来安装Linux系统，安装系统前需要准备如下软件： VMware workstation 10.0（可以百度一下）CentOS 5.8 x86_i386.i或redhat（Linux官网下载） 说明：可能随时间更新版本可能安装有一定差异，不过换汤不换药，相信我们这些IT男的头脑这so easy。 1. 3. 1 安装 前 的 规划 可能会有读者正计划学习Linux 而苦恼于 不知道 使用 哪一个 发行 版， 其实 所有 的 发行 版 不管 是 RedHat、 CentOS 还是 Ubuntu， 其内 核 都是 来自 Linux 内核 官 网（ www. kernel. org）， 不同 发行 版 之间 的 差别 在于 软件 管理 的 不同， 所以 不管 使用 哪一个 发行 版， 只要 理解 其 原理 之后， 各类 发行 版 的 区别 其实 不大。 当然 对于 初学者 来说， 拥有 广泛 的 学习 资源 也是 很重 要的。 由于 RedHat 公司 进行 了 大力 商业 推广， 且 得 益于 其 成熟 的 认证 体系， 因此 使用 RedHat 的 用户 比较 多， 同时， 它 还有 丰富 的 相关 技术 文档， 以及 活跃 的 社区， 所以 作为 入门 学习， 可以 使用 RedHat。 不过年来，CentOS 发展 也 很 迅猛， 这个 发行 版 和 RedHat 几乎 完全 一样， 而且 在 某些方面 还 比 RedHat 略胜一筹， 所以 在 本书 中 后面 的 所有 内容 中将 主要 使用 版本 为 5. 5 的 CentOS， 小部分 涉及 RedHat 的 内容 也 将 采用 5. 5 版本。 有 读者 可能 会 考虑 在 一台 计算 机上 安装 多个 操作系统， 比如说 在 自己的 家用 计算 机上 安装 Windows 用于 娱乐 和 日常 应用 或 Windows 环境 下 的 开发 等， 另外 再 安装 Linux 系统 用于 学习。 在 这种 情况下， 最简单 的 安装 方法 是 先 安装 Windows， 后 安装 Linux， 这样 开机 的 时候 就 自动 出现 操作系统 选择 条， 可以 根据 实际需要 选择 进入 不同 的 操作系统。 由于 Linux 对 系统 的 需求 并不 高， 所以 几乎 所有 计算机 都可以 安装， 但是 考虑到 入门 学习 Linux 需要 用到 图形 界面， 所以 建议 最好 不要 低于 以下 配置： CPU， P- 3 800MHz； 内存， 1GB； 硬盘， 40GB。 在 安装 Linux 的 过程中， 必须 要有 的 两个 分区 为 根 分区（/） 和 swap 分区（ 交换 分区）， 当然 还有 一些 其他 的 分区 可以 独立 出来， 比如说/ boot 分区、/ var 分区 等。 另外， 这里 介绍 几个 概念， 便于 大家 理解 后面 即将 出现 的 一些 专业 词汇。 什么 是 交换 分区？ 交换 分区 是一 个 特殊 的 分区， 它的 作用 相当于 Windows 下 的 虚拟 内存， 这个 分区 的 大小 一般 设置 为 物理 内存 的 两倍， 但是 不管 物理 内存 有 多大， 交换 分区 建议 不要 超过 8GB， 因为 大于 8GB 的 交换 分区 其实 并没有 多大 实际意义。 什么 是 Grub？ Grub 是一 个 系统 引导 工具， 通过 它可 以 加载 内核， 从而 在 安装 Linux 的 过程中， 必须 要有 的 两个 分区 为 根 分区（/） 和 swap 分区（ 交换 分区）， 当然 还有 一些 其他 的 分区 可以 独立 出来， 比如说/ boot 分区、/ var 分区 等。 另外， 这里 介绍 几个 概念， 便于 大家 理解 后面 即将 出现 的 一些 专业 词汇。 什么 是 交换 分区？ 交换 分区 是一 个 特殊 的 分区， 它的 作用 相当于 Windows 下 的 虚拟 内存， 这个 分区 的 大小 一般 设置 为 物理 内存 的 两倍， 但是 不管 物理 内存 有 多大， 交换 分区 建议 不要 超过 8GB， 因为 大于 8GB 的 交换 分区 其实 并没有 多大 实际意义。 什么 是 Grub？ Grub 是一 个 系统 引导 工具， 通过 它可 以 加载 内核， 从而 引导 系统 启动。 什么 是/ boot 分区？/ boot 分区 用于 放置 Linux 启动 所 用到 的 文件， 如 kernel 和 initrd 文件。 什么 是 DHCP？ DHCP 是 Dynamic Host Configuration Protocol 的 简写， 中文 称为 动态 主机 配置 协议。 在 TCP/ IP 网络 中， 每 台 主机 都 需要 有 IP 地址 才能 与其 他 主机 通信， 在 一个 大规模 的 网络 中， 如果 由 管理员 手动 地 对 每一 台 主机 进行 IP 地址 配置 是 不现实 的。 由此 也就 产生了 DHCP 协议， 可用 它来 2 安装 RedHat 本节 将 演示 安装 RedHat 系统 的 过程， 使 用到 的 版本 是 RedHat 5. 5。 大家 可以 先到 网上 下载 RedHat 5. 5 操作系统 的 ISO 文件， 然后 刻成 光盘 再 安装。 当然 不要 忘记 在 计算机 的 主 板 中 设置 从 光驱 启动， 也可以 使用 虚拟 机 软件 通过 安装 虚拟 机 的 方式 模拟 安装 过程。 计算机 从 光盘 启动 后， 首先 会 显示 如图 1- 1 所示 界面（ 注意 看 英文 提示）。 如果 想 使用 图形 界面 安装 直接 按 回车 键 即可， 或者 在 10 秒 之内 不做 任何 输入， 这样 也会 默认 进入 图形 安装 模式。 如果 想用 字符 模式 安装， 需要 输入 linux text， 然后 按 回车 键。 如果 计算机 的 内存 过小， 安装 程序 会 检测 到 因 内存 不足 而无 法 进入 图形 安装 模式， 转而 进入 字符 安装 模式。 安装图解如下：第一步，新建虚拟机如下图： 第二步，选择相关选项，如下图： 第三步选择“稍后安装操作系统”，如下图: 第四步，选择客户机操作系统类型如下图： 第五步，设置虚拟机硬盘大小为20G，最低不能小于5G，如下图 第六步，虚拟机新建完成，如下图： 第七步，修改虚拟机内存为512M，并添加ISO镜像，如下图： 自此，虚拟机新建完成，接下来点击“启动此虚拟机”进行Linux系统安装，Linux系统安装图解如下：第一步，进入安装界面，直接按Enter回车键即可。 第二步，光盘检测，选择SKIP跳过。 第三步，选择安装过程中的语言，初学者可以选择“简体中文”。 第四步，选择初始化整个硬盘，清除所有数据。 第五步，选择分区方式为“自定义分区“。 点击“新建“-首先创建一个swap交换分区，大小为物理内存的2倍（1024M）。 第六步，继续创建分区，选择“新建“，然后创建根分区/，如下图选择，大小为剩余所有空间即可。 第七步，默认点击下一步，同时默认DHCP配置，时钟选择上海，去掉UTC勾，点击下一步。 第八步，设置root密码，至少六位，点击下一步。 第九步，系统安装包选择，这里选择“现在定制“。 第十步，系统安装包选择，左侧选择“开发“—-右侧选择”开发工具“和“开发库”，语言选择“支持中文“，其他一概不选择。 安装完毕会提示“reboot“，直接回车即可。 .]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[whystudyIT]]></title>
    <url>%2F2017%2F08%2F07%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B5%B0%E4%B8%8A%E8%BF%99%E8%B7%AF%2F</url>
    <content type="text"></content>
      <categories>
        <category>关于我</category>
      </categories>
      <tags>
        <tag>story</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexoStudy]]></title>
    <url>%2F2017%2F08%2F05%2FhexoStudy%2F</url>
    <content type="text"><![CDATA[前提准备 NodeJSgit确保安装这两个才可以继续。 安装Hexo打开git $ npm install -g hexo部署Hexo在任何想要放置Hexo的文件夹下建立名为Hexo的文件夹，在此文件夹中右键打开Git Bash $ hexo initHexo会自动建立所有博客需要的文件 $ hexo g$ hexo s输入上面的命令就可以在本地看到初始化的博客啦，浏览器中输入localhost:4000以上就完成了博客的本地调试了，下面需要将本地的博客放到github中去，利用github pages 的免费空间存放你的博客，而且别人也可以访问你的博客。 配置和使用github首先需要注册github（废话。。划掉），然后登录github，点击右上角你的头像，再点击Settings，进入设置页面。点击侧栏的SSH and GPG keys,可以查看你是否有本机的SSH密匙。如果没有，说明并没有设置SSH密匙。 检查SSH keys的设置先不管github的网页，回到本机，打开Git Bash。输入： $ cd ~/. ssh 检查本机的ssh密钥如果提示：No such file or directory 说明你是第一次使用git。 生成新的SSH Key：继续输入： $ ssh-keygen -t rsa -C “邮件地址@youremail.com”Generating public/private rsa key pair.Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt;系统会要求你输入密码，输入就好，只是这里的输入是不显示占位符的。 Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;Enter same passphrase again:&lt;再次输入加密串&gt;完成后就会提示你的密匙文件所在的位置，打开id_rsa.pub文件，复制所有，回到github网页，点击New SSH key,粘贴到key文本框中，点击add key就可以了。 测试SSH连接输入下面的命令，git@github.com不用修改。 $ ssh -T git@github.com会有这样的反馈： The authenticity of host ‘github.com (207.97.227.239)’ can’t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)?输入yes，就会看到： Hi Dulmcat! You’ve successfully authenticated, but GitHub does not provide shell access.到这里就代表已经正确的连接到github了。 设置用户信息但还有一些个人信息还是需要继续完善下的，Git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的。 $ git config –global user.name “cnfeat”//用户名$ git config –global user.email “cnfeat@gmail.com”//填写自己的邮箱若有问题，从头再来一遍，或者到GitHub help中寻找解决方案。 使用GitHub pages 建立网页与GitHub建立好链接之后，就可以方便的使用它提供的Pages服务。但pages服务每个ID只有一个，大小也只有300M，但作为博客站，已经足够了。 建立仓库登录GitHub后，点击那个大大的绿色New repository按钮，新建一个仓库：Repository name：dulmcat.github.ioDescription (optional): 嗯。。括号里都说了是可选的，就随便吧，可填可不填。注意！！ 这里的Repository name必须是你的github用户名.github.io，否则就不是一个github pages而只是单纯的一个仓库了。点击Create Repository 完成创建。 上传hexo到github pages上传前，需要将Hexo和github想关联起来，在Hexo的配置文件_config.yml文件中,拉到最下面，修改配置文件： deploy: type: git repository: https://github.com/Dulmcat/Dulmcat.github.io branch: master这里的repository填写的是你的github pages所在库（就是上面刚建好的那个）的地址。这里有个坑，关于type的填写，有说应该是github的，有说是git的，我在两个月前的配置文件type写的github，写这篇文章时发现出错了，这才发现好像是作者在3.0之后改为了git，大家在安装Hexo时可以输入命令hexo-v查看Hexo的版本。在3.0之后需要另外安装hexo-deployer-git。 $ npm install hexo-deployer-git –save然后 $ hexo d这里可能会要求填写密码，填了就好。然后在浏览器中输入https://dulmcat.github.io 就可以看到你的博客啦一个在线的博客就这样建好了当然这是我的…要输入 你的github用户名.github.io]]></content>
      <categories>
        <category>hexo建博小结</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[myGitOneDay]]></title>
    <url>%2F2017%2F08%2F04%2FmyGitOneDay%2F</url>
    <content type="text"></content>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM垃圾回收算法及回收器]]></title>
    <url>%2F2016%2F09%2F01%2FJVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E5%8F%8A%E5%9B%9E%E6%94%B6%E5%99%A8%2F</url>
    <content type="text"><![CDATA[本文主要讲述JVM中几种常见的垃圾回收算法和相关的垃圾回收器，以及常见的和GC相关的性能调优参数。 GC Roots 我们先来了解一下在Java中是如何判断一个对象的生死的，有些语言比如Python是采用引用计数来统计的，但是这种做法可能会遇见循环引用的问题，在Java以及C#等语言中是采用GC Roots来解决这个问题。如果一个对象和GC Roots之间没有链接，那么这个对象也可以被视作是一个可回收的对象。 Java中可以被作为GC Roots中的对象有： 虚拟机栈中的引用的对象。方法区中的类静态属性引用的对象。方法区中的常量引用的对象。本地方法栈（jni）即一般说的Native的引用对象。 垃圾回收算法 标记清除 标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。在标记阶段首先通过根节点，标记所有从根节点开始的对象，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。标记清除算法带来的一个问题是会存在大量的空间碎片，因为回收后的空间是不连续的，这样给大对象分配内存的时候可能会提前触发full gc。 复制算法 将现有的内存空间分为两快，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。 现在的商业虚拟机都采用这种收集算法来回收新生代，IBM研究表明新生代中的对象98%是朝夕生死的，所以并不需要按照1:1的比例划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一个Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1(可以通过-SurvivorRattio来配置)，也就是每次新生代中可用内存空间为整个新生代容量的90%，只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保。 标记整理 复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活的对象较多，复制的成本也将很高。标记-压缩算法是一种老年代的回收算法，它在标记-清除算法的基础上做了一些优化。首先也需要从根节点开始对所有可达对象做一次标记，但之后，它并不简单地清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。 增量算法 增量算法的基本思想是，如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。 垃圾回收器 Serial收集器 Serial收集器是最古老的收集器，它的缺点是当Serial收集器想进行垃圾回收的时候，必须暂停用户的所有进程，即stop the world。到现在为止，它依然是虚拟机运行在client模式下的默认新生代收集器，与其他收集器相比，对于限定在单个CPU的运行环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾回收自然可以获得最高的单线程收集效率。 Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用”标记－整理“算法。这个收集器的主要意义也是被Client模式下的虚拟机使用。在Server模式下，它主要还有两大用途：一个是在JDK1.5及以前的版本中与Parallel Scanvenge收集器搭配使用，另外一个就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure的时候使用。 通过指定-UseSerialGC参数，使用Serial + Serial Old的串行收集器组合进行内存回收。 ParNew收集器 ParNew收集器是Serial收集器新生代的多线程实现，注意在进行垃圾回收的时候依然会stop the world，只是相比较Serial收集器而言它会运行多条进程进行垃圾回收。 ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百的保证能超越Serial收集器。当然，随着可以使用的CPU的数量增加，它对于GC时系统资源的利用还是很有好处的。它默认开启的收集线程数与CPU的数量相同，在CPU非常多（譬如32个，现在CPU动辄4核加超线程，服务器超过32个逻辑CPU的情况越来越多了）的环境下，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。 -UseParNewGC: 打开此开关后，使用ParNew + Serial Old的收集器组合进行内存回收，这样新生代使用并行收集器，老年代使用串行收集器。 Parallel Scavenge收集器 Parallel是采用复制算法的多线程新生代垃圾回收器，似乎和ParNew收集器有很多的相似的地方。但是Parallel Scanvenge收集器的一个特点是它所关注的目标是吞吐量(Throughput)。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)。停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能够提升用户的体验；而高吞吐量则可以最高效率地利用CPU时间，尽快地完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。 Parallel Old收集器是Parallel Scavenge收集器的老年代版本，采用多线程和”标记－整理”算法。这个收集器是在jdk1.6中才开始提供的，在此之前，新生代的Parallel Scavenge收集器一直处于比较尴尬的状态。原因是如果新生代Parallel Scavenge收集器，那么老年代除了Serial Old(PS MarkSweep)收集器外别无选择。由于单线程的老年代Serial Old收集器在服务端应用性能上的”拖累“，即使使用了Parallel Scavenge收集器也未必能在整体应用上获得吞吐量最大化的效果，又因为老年代收集中无法充分利用服务器多CPU的处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定有ParNew加CMS的组合”给力“。直到Parallel Old收集器出现后，”吞吐量优先“收集器终于有了比较名副其实的应用祝贺，在注重吞吐量及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。 -UseParallelGC: 虚拟机运行在Server模式下的默认值，打开此开关后，使用Parallel Scavenge + Serial Old的收集器组合进行内存回收。-UseParallelOldGC: 打开此开关后，使用Parallel Scavenge + Parallel Old的收集器组合进行垃圾回收 CMS收集器 CMS(Concurrent Mark Swep)收集器是一个比较重要的回收器，现在应用非常广泛，我们重点来看一下，CMS一种获取最短回收停顿时间为目标的收集器，这使得它很适合用于和用户交互的业务。从名字(Mark Swep)就可以看出，CMS收集器是基于标记清除算法实现的。它的收集过程分为四个步骤： 初始标记(initial mark)并发标记(concurrent mark)重新标记(remark)并发清除(concurrent sweep) 注意初始标记和重新标记还是会stop the world，但是在耗费时间更长的并发标记和并发清除两个阶段都可以和用户进程同时工作。 不过由于CMS收集器是基于标记清除算法实现的，会导致有大量的空间碎片产生，在为大对象分配内存的时候，往往会出现老年代还有很大的空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前开启一次Full GC。为了解决这个问题，CMS收集器默认提供了一个-XX:+UseCMSCompactAtFullCollection收集开关参数（默认就是开启的)，用于在CMS收集器进行FullGC完开启内存碎片的合并整理过程，内存整理的过程是无法并发的，这样内存碎片问题倒是没有了，不过停顿时间不得不变长。虚拟机设计者还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction参数用于设置执行多少次不压缩的FULL GC后跟着来一次带压缩的（默认值为0，表示每次进入Full GC时都进行碎片整理）。 不幸的是，它作为老年代的收集器，却无法与jdk1.4中已经存在的新生代收集器Parallel Scavenge配合工作，所以在jdk1.5中使用cms来收集老年代的时候，新生代只能选择ParNew或Serial收集器中的一个。ParNew收集器是使用-XX:+UseConcMarkSweepGC选项启用CMS收集器之后的默认新生代收集器，也可以使用-XX:+UseParNewGC选项来强制指定它。 由于CMS收集器现在比较常用，下面我们再额外了解一下CMS算法的几个常用参数： UseCMSInitatingOccupancyOnly：表示只在到达阈值的时候，才进行 CMS 回收。为了减少第二次暂停的时间，通过-XX:+CMSParallelRemarkEnabled开启并行remark。如果ramark时间还是过长的话，可以开启-XX:+CMSScavengeBeforeRemark选项，强制remark之前开启一次minor gc，减少remark的暂停时间，但是在remark之后也立即开始一次minor gc。CMS默认启动的回收线程数目是(ParallelGCThreads + 3)/4，如果你需要明确设定，可以通过-XX:+ParallelCMSThreads来设定，其中-XX:+ParallelGCThreads代表的年轻代的并发收集线程数目。CMSClassUnloadingEnabled： 允许对类元数据进行回收。CMSInitatingPermOccupancyFraction：当永久区占用率达到这一百分比后，启动 CMS 回收 (前提是-XX:+CMSClassUnloadingEnabled 激活了)。CMSIncrementalMode：使用增量模式，比较适合单 CPU。UseCMSCompactAtFullCollection参数可以使 CMS 在垃圾收集完成后，进行一次内存碎片整理。内存碎片的整理并不是并发进行的。UseFullGCsBeforeCompaction：设定进行多少次 CMS 垃圾回收后，进行一次内存压缩。 一些建议 对于Native Memory: 使用了NIO或者NIO框架（Mina/Netty）使用了DirectByteBuffer分配字节缓冲区使用了MappedByteBuffer做内存映射 由于Native Memory只能通过FullGC回收，所以除非你非常清楚这时真的有必要，否则不要轻易调用System.gc()。 另外为了防止某些框架中的System.gc调用（例如NIO框架、Java RMI），建议在启动参数中加上-XX:+DisableExplicitGC来禁用显式GC。这个参数有个巨大的坑，如果你禁用了System.gc()，那么上面的3种场景下的内存就无法回收，可能造成OOM，如果你使用了CMS GC，那么可以用这个参数替代：-XX:+ExplicitGCInvokesConcurrent。 此外除了CMS的GC，其实其他针对old gen的回收器都会在对old gen回收的同时回收young gen。 G1收集器 G1收集器是一款面向服务端应用的垃圾收集器。HotSpot团队赋予它的使命是在未来替换掉JDK1.5中发布的CMS收集器。与其他GC收集器相比，G1具备如下特点： 并行与并发：G1能更充分的利用CPU，多核环境下的硬件优势来缩短stop the world的停顿时间。分代收集：和其他收集器一样，分代的概念在G1中依然存在，不过G1不需要其他的垃圾回收器的配合就可以独自管理整个GC堆。空间整合：G1收集器有利于程序长时间运行，分配大对象时不会无法得到连续的空间而提前触发一次GC。可预测的非停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。 在使用G1收集器时，Java堆的内存布局和其他收集器有很大的差别，它将这个Java堆分为多个大小相等的独立区域，虽然还保留新生代和老年代的概念，但是新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。 虽然G1看起来有很多优点，实际上CMS还是主流。 与GC相关的常用参数 除了上面提及的一些参数，下面补充一些和GC相关的常用参数： -Xmx: 设置堆内存的最大值。-Xms: 设置堆内存的初始值。-Xmn: 设置新生代的大小。-Xss: 设置栈的大小。-PretenureSizeThreshold: 直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接在老年代分配。-MaxTenuringThrehold: 晋升到老年代的对象年龄。每个对象在坚持过一次Minor GC之后，年龄就会加1，当超过这个参数值时就进入老年代。-UseAdaptiveSizePolicy: 在这种模式下，新生代的大小、eden 和 survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。在手工调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量 (GCTimeRatio) 和停顿时间 (MaxGCPauseMills)，让虚拟机自己完成调优工作。-SurvivorRattio: 新生代Eden区域与Survivor区域的容量比值，默认为8，代表Eden: Suvivor= 8: 1。-XX:ParallelGCThreads：设置用于垃圾回收的线程数。通常情况下可以和 CPU 数量相等。但在 CPU 数量比较多的情况下，设置相对较小的数值也是合理的。-XX:MaxGCPauseMills：设置最大垃圾收集停顿时间。它的值是一个大于 0 的整数。收集器在工作时，会调整 Java 堆大小或者其他一些参数，尽可能地把停顿时间控制在 MaxGCPauseMills 以内。-XX:GCTimeRatio:设置吞吐量大小，它的值是一个 0-100 之间的整数。假设 GCTimeRatio 的值为 n，那么系统将花费不超过 1/(1+n) 的时间用于垃圾收集。]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代理模式]]></title>
    <url>%2F2016%2F08%2F25%2F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[说说 JAVA 代理模式 本文内容借阅来自ImportNew中 事例 小张是一个普普通通的码农，每天勤勤恳恳地码代码。某天中午小张刚要去吃饭，一个电话打到了他的手机上。“是XX公司的小张吗？我是YY公司的王AA”。“哦，是王总啊，有什么事情吗？”。沟通过后，小张弄明白了,原来客户有个需求，刚好负责这方面开发的是小张，客户就直接找到了他。不过小张却没有答应客户的请求，而是让客户找产品经理小李沟通。 是小张着急去吃面而甩锅吗？并不是，只是为了使故事可以套到代理模式上。我们先看一下代理模式的定义： * 为其他对象提供一种代理，以控制对这个对象的访问。(Provide a surrogate or placeholder for another object to control access to it) 对照定义，码农小张可以映射为其他对象，产品经理小李为小张的代理。我们通过JAVA代码，表述上面事例。 静态代理 1.抽象角色 基于面向对象的思想，首先定义一个码农接口,它有一个实现用户需求的方法。 public interface ICoder { public void implDemands(String demandName); } 2.真实角色 我们假设小张是JAVA程序员，定义一个JAVA码农类，他通过JAA语言实现需求。 public class JavaCoder implements ICoder{ private String name; public JavaCoder(String name){ this.name = name; } @Override public void implDemands(String demandName) { System.out.println(name + &quot; implemented demand:&quot; + demandName + &quot; in JAVA!&quot;); } } 3.代理角色 委屈一下产品经理，将其命名为码农代理类，同时让他实现ICoder接口。 public class CoderProxy implements ICoder{ private ICoder coder; public CoderProxy(ICoder coder){ this.coder = coder; } @Override public void implDemands(String demandName) { coder.implDemands(demandName); } } 上面一个接口，两个类，就实现了代理模式。Are you kidding me？这么简单？是的，就是这么简单。 我们通过一个场景类，模拟用户找产品经理增加需求。 public class Customer { public static void main(String args[]){ //定义一个java码农 ICoder coder = new JavaCoder(&quot;Zhang&quot;); //定义一个产品经理 ICoder proxy = new CoderProxy(coder); //让产品经理实现一个需求 proxy.implDemands(); } } 运行程序，结果如下： Zhang implemented demand:Add user manageMent in JAVA! 产品经理充当了程序员的代理，客户把需求告诉产品经理，并不需要和程序员接触。看到这里，有些机智的程序员发现了问题。你看，产品经理就把客户的需求转达了一下，怪不得我看产品经理这么不爽。 产品经理当然不只是转达用户需求，他还有很多事情可以做。比如，该项目决定不接受新增功能的需求了，对修CoderProxy类做一些修改： public class CoderProxy implements ICoder{ private ICoder coder; public CoderProxy(ICoder coder){ this.coder = coder; } @Override public void implDemands(String demandName) { if(demandName.startsWith(&quot;Add&quot;)){ System.out.println(&quot;No longer receive &apos;Add&apos; demand&quot;); return; } coder.implDemands(demandName); } } 这样，当客户再有增加功能的需求时，产品经理就直接回绝了，程序员无需再对这部分需求做过滤。 总结 我们对上面的事例做一个简单的抽象： 代理模式包含如下角色： Subject:抽象主题角色。可以是接口，也可以是抽象类。 RealSubject:真实主题角色。业务逻辑的具体执行者。 ProxySubject:代理主题角色。内部含有RealSubject的引用,负责对真实角色的调用，并在真实主题角色处理前后做预处理和善后工作。 代理模式优点： 职责清晰 真实角色只需关注业务逻辑的实现，非业务逻辑部分，后期通过代理类完成即可。 高扩展性 不管真实角色如何变化，由于接口是固定的，代理类无需做任何改动。 动态代理 前面讲的主要是静态代理。那么什么是动态代理呢？ 假设有这么一个需求，在方法执行前和执行完成后，打印系统时间。这很简单嘛，非业务逻辑，只要在代理类调用真实角色的方法前、后输出时间就可以了。像上例，只有一个implDemands方法，这样实现没有问题。但如果真实角色有10个方法，那么我们要写10遍完全相同的代码。有点追求的码农，肯定会对这种方法感到非常不爽。有些机智的小伙伴可能想到了用AOP解决这个问题。非常正确。莫非AOP和动态代理有什么关系？没错！AOP用的恰恰是动态代理。 代理类在程序运行时创建的代理方式被称为动态代理。也就是说，代理类并不需要在Java代码中定义，而是在运行时动态生成的。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类的函数。对于上例打印时间的需求，通过使用动态代理，我们可以做一个“统一指示”，对所有代理类的方法进行统一处理，而不用逐一修改每个方法。下面我们来具体介绍下如何使用动态代理方式实现我们的需求。 与静态代理相比，抽象角色、真实角色都没有变化。变化的只有代理类。因此，抽象角色、真实角色，参考ICoder和JavaCodr。 在使用动态代理时，我们需要定义一个位于代理类与委托类之间的中介类，也叫动态代理类，这个类被要求实现InvocationHandler接口： public class CoderDynamicProxy implements InvocationHandler{ //被代理的实例 private ICoder coder; public CoderDynamicProxy(ICoder _coder){ this.coder = _coder; } //调用被代理的方法 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(System.currentTimeMillis()); Object result = method.invoke(coder, args); System.out.println(System.currentTimeMillis()); return result; } } 当我们调用代理类对象的方法时，这个“调用”会转送到中介类的invoke方法中，参数method标识了我们具体调用的是代理类的哪个方法，args为这个方法的参数。 我们通过一个场景类，模拟用户找产品经理更改需求。 public class DynamicClient { public static void main(String args[]){ //要代理的真实对象 ICoder coder = new JavaCoder(&quot;Zhang&quot;); //创建中介类实例 InvocationHandler handler = new CoderDynamicProxy(coder); //获取类加载器 ClassLoader cl = coder.getClass().getClassLoader(); //动态产生一个代理类 ICoder proxy = (ICoder) Proxy.newProxyInstance(cl, coder.getClass().getInterfaces(), handler); //通过代理类，执行doSomething方法； proxy.implDemands(&quot;Modify user management&quot;); } } 执行结果如下： 1501728574978 Zhang implemented demand:Modify user management in JAVA! 1501728574979 通过上述代码，就实现了，在执行委托类的所有方法前、后打印时间。还是那个熟悉的小张，但我们并没有创建代理类，也没有时间ICoder接口。这就是动态代理。 总结 总结一下，一个典型的动态代理可分为以下四个步骤： 创建抽象角色 创建真实角色 通过实现InvocationHandler接口创建中介类 通过场景类，动态生成代理类 如果只是想用动态代理，看到这里就够了。但如果想知道为什么通过proxy对象，就能够执行中介类的invoke方法，以及生成的proxy对象是什么样的，可以继续往下看。 源码分析(JDK7) 看到这里的小伙伴，都是有追求的程序员。上面的场景类中，通过 //动态产生一个代理类 ICoder proxy = (ICoder) Proxy.newProxyInstance(cl, coder.getClass().getInterfaces(), handler); 动态产生了一个代理类。那么这个代理类是如何产生的呢？我们通过代码一窥究竟。 Proxy类的newProxyInstance方法，主要业务逻辑如下： //生成代理类class，并加载到jvm中 Class&lt;?&gt; cl = getProxyClass0(loader, interfaces); //获取代理类参数为InvocationHandler的构造函数 final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); //生成代理类，并返回 return newInstance(cons, ih); 上面代码做了三件事： 根据传入的参数interfaces动态生成一个类，它实现interfaces中的接口，该例中即ICoder接口的implDemands方法。假设动态生成的类为$Proxy0。 通过传入的classloder,将刚生成的$Proxy0类加载到jvm中。 利用中介类，调用$Proxy0的$Proxy0(InvocationHandler)构造函数，创建$Proxy0类的实例，其InvocationHandler属性，为我们创建的中介类。 上面的核心，就在于getProxyClass0方法： private static Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) { if (interfaces.length &gt; 65535) { throw new IllegalArgumentException(&quot;interface limit exceeded&quot;); } // If the proxy class defined by the given loader implementing // the given interfaces exists, this will simply return the cached copy; // otherwise, it will create the proxy class via the ProxyClassFactory return proxyClassCache.get(loader, interfaces); } 在Proxy类中有个属性proxyClassCache，这是一个WeakCache类型的静态变量。它指示了类加载器和代理类之间的映射。所以proxyClassCache的get方法用于根据类加载器来获取Proxy类，如果已经存在则直接从cache中返回，如果没有则创建一个映射并更新cache表。 我们跟一下代理类的创建流程： 调用Factory类的get方法，而它又调用了ProxyClassFactory类的apply方法，最终找到下面一行代码： //Generate the specified proxy class. byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces); 就是它，生成了代理类。 查看动态生成的代理类 通过上面的分析，我们已经知道Proxy类动态创建代理类的流程。那创建出来的代理类到底是什么样子的呢？我们可以通过下面的代码，手动生成： public class CodeUtil { public static void main(String[] args) throws IOException { byte[] classFile = ProxyGenerator.generateProxyClass(&quot;TestProxyGen&quot;, JavaCoder.class.getInterfaces()); File file = new File(&quot;D:/aaa/TestProxyGen.class&quot;); FileOutputStream fos = new FileOutputStream(file); fos.write(classFile); fos.flush(); fos.close(); } } 通过反编译工具查看生成的class文件: import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import java.lang.reflect.UndeclaredThrowableException; import model.proxy.ICoder; public final class TestProxyGen extends Proxy implements ICoder { private static Method m1; private static Method m0; private static Method m3; private static Method m2; public TestProxyGen(InvocationHandler paramInvocationHandler) throws { super(paramInvocationHandler); } public final boolean equals(Object paramObject) throws { try { return ((Boolean)this.h.invoke(this, m1, new Object[] { paramObject })).booleanValue(); } catch (RuntimeException localRuntimeException) { throw localRuntimeException; } catch (Throwable localThrowable) { } throw new UndeclaredThrowableException(localThrowable); } public final int hashCode() throws { try { return ((Integer)this.h.invoke(this, m0, null)).intValue(); } catch (RuntimeException localRuntimeException) { throw localRuntimeException; } catch (Throwable localThrowable) { } throw new UndeclaredThrowableException(localThrowable); } public final void implDemands(String paramString) throws { try { this.h.invoke(this, m3, new Object[] { paramString }); return; } catch (RuntimeException localRuntimeException) { throw localRuntimeException; } catch (Throwable localThrowable) { } throw new UndeclaredThrowableException(localThrowable); } public final String toString() throws { try { return (String)this.h.invoke(this, m2, null); } catch (RuntimeException localRuntimeException) { throw localRuntimeException; } catch (Throwable localThrowable) { } throw new UndeclaredThrowableException(localThrowable); } static { try { m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[] { Class.forName(&quot;java.lang.Object&quot;) }); m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]); m3 = Class.forName(&quot;model.proxy.ICoder&quot;).getMethod(&quot;implDemands&quot;, new Class[] { Class.forName(&quot;java.lang.String&quot;) }); m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]); return; } catch (NoSuchMethodException localNoSuchMethodException) { throw new NoSuchMethodError(localNoSuchMethodException.getMessage()); } catch (ClassNotFoundException localClassNotFoundException) { } throw new NoClassDefFoundError(localClassNotFoundException.getMessage()); } } 这样，我们就理解，为什么调用代理类的implDemands方法，回去执行中介类的invoke方法了。 看完本文有收获？请转发分享给更多人]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊java8时间与日期]]></title>
    <url>%2F2016%2F08%2F22%2Fjava8%E6%97%B6%E9%97%B4%E4%B8%8E%E6%97%A5%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[相信大家都有这样感觉，Java操作日期和时间的时候，会有一些麻烦。你也许会通过System.currentTimeMillis() 来返回1970年1月1日到今天的毫秒数。或者使用Date类来操作日期；当遇到加减月份、天数的时候 你又需要用到Calendar类；当需要格式化日期的时候需要使用java.text.DateFormat类。所以说在Java中操作日期不是很方便，以至于很多开发者不得不使用第三方库。 JAVA8以的API前存在的问题： 线程安全: Date和Calendar不是线程安全的，你需要编写额外的代码处理线程安全问题 API设计和易用性: 由于Date和Calendar的设计不当你无法完成日常的日期操作 ZonedDate和Time: 你必须编写额外的逻辑处理时区和那些旧的逻辑 好在JSR 310规范中为Java8添加了新的API， 在java.time包中，新的API纠正了过去的缺陷， 新的日期API ZoneId: 时区ID，用来确定Instant和LocalDateTime互相转换的规则 Instant: 用来表示时间线上的一个点 LocalDate: 表示没有时区的日期, LocalDate是不可变并且线程安全的 LocalTime: 表示没有时区的时间, LocalTime是不可变并且线程安全的 LocalDateTime: 表示没有时区的日期时间, LocalDateTime是不可变并且线程安全的 Clock: 用于访问当前时刻、日期、时间，用到时区 Duration: 用秒和纳秒表示时间的数量 最常用的就是LocalDate、LocalTime、LocalDateTime了，从它们的名字就可以看出是操作日期 和时间的。这些类是主要用于当时区不需要显式地指定的上下文。在本章节中我们将讨论最常用的api。 LocalDate LocalDate代表一个IOS格式(yyyy-MM-dd)的日期，可以存储 生日、纪念日等日期。 获取当前的日期： LocalDate localDate = LocalDate.now(); System.out.println(“localDate: “ + localDate); localDate: 2017-07-20 LocalDate可以指定特定的日期，调用of或parse方法返回该实例： LocalDate.of(2017, 07, 20); LocalDate.parse(“2017-07-20”); 当然它还有一些其他方法，我们一起来看看： 为今天添加一天，也就是获取明天 LocalDate tomorrow = LocalDate.now().plusDays(1); 从今天减去一个月 LocalDate prevMonth = LocalDate.now().minus(1, ChronoUnit.MONTHS); 下面写两个例子，分别解析日期 2017-07-20，获取每周中的星期和每月中的日： DayOfWeek thursday = LocalDate.parse(“2017-07-20”).getDayOfWeek(); System.out.println(“周四: “ + thursday); int twenty = LocalDate.parse(“2017-07-20”).getDayOfMonth(); System.out.println(“twenty: “ + twenty); 试试今年是不是闰年: boolean leapYear = LocalDate.now().isLeapYear(); System.out.println(“是否闰年: “ + leapYear); 判断是否在日期之前或之后: boolean notBefore = LocalDate.parse(“2017-07-20”) .isBefore(LocalDate.parse(&quot;2017-07-22&quot;)); System.out.println(“notBefore: “ + notBefore); boolean isAfter = LocalDate.parse(“2017-07-20”).isAfter(LocalDate.parse(“2017-07-22”)); System.out.println(“isAfter: “ + isAfter); 获取这个月的第一天: LocalDate firstDayOfMonth = LocalDate.parse(“2017-07-20”) .with(TemporalAdjusters.firstDayOfMonth()); System.out.println(“这个月的第一天: “ + firstDayOfMonth); firstDayOfMonth = firstDayOfMonth.withDayOfMonth(1); System.out.println(“这个月的第一天: “ + firstDayOfMonth); 判断今天是否是我的生日，例如我的生日是 2009-07-20 LocalDate birthday = LocalDate.of(2009, 07, 20); MonthDay birthdayMd = MonthDay.of(birthday.getMonth(), birthday.getDayOfMonth()); MonthDay today = MonthDay.from(LocalDate.now()); System.out.println(“今天是否是我的生日: “ + today.equals(birthdayMd)); LocalTime LocalTime表示一个时间，而不是日期，下面介绍一下它的使用方法。 获取现在的时间，输出15:01:22.144 LocalTime now = LocalTime.now(); System.out.println(“现在的时间: “ + now); 将一个字符串时间解析为LocalTime，输出15:02 LocalTime nowTime = LocalTime.parse(“15:02”); System.out.println(“时间是: “ + nowTime); 使用静态方法of创建一个时间 LocalTime nowTime = LocalTime.of(15, 02); System.out.println(“时间是: “ + nowTime); 使用解析字符串的方式并添加一小时，输出16:02 LocalTime nextHour = LocalTime.parse(“15:02”).plus(1, ChronoUnit.HOURS); System.out.println(“下一个小时: “ + nextHour); 获取时间的小时、分钟 int hour = LocalTime.parse(“15:02”).getHour(); System.out.println(“小时: “ + hour); int minute = LocalTime.parse(“15:02”).getMinute(); System.out.println(“分钟: “ + minute); 我们也可以通过之前类似的API检查一个时间是否在另一个时间之前、之后 boolean isBefore = LocalTime.parse(“15:02”).isBefore(LocalTime.parse(“16:02”)); boolean isAfter = LocalTime.parse(“15:02”).isAfter(LocalTime.parse(“16:02”)); System.out.println(“isBefore: “ + isBefore); System.out.println(“isAfter: “ + isAfter); 输出 isBefore: true, isAfter: false。 在LocalTime类中也将每天的开始和结束作为常量供我们使用: System.out.println(LocalTime.MAX); System.out.println(LocalTime.MIN); 输出: 23:59:59.999999999 00:00 LocalTime就这些了，下面我们来了解一下LocalDateTime LocalDateTime LocalDateTime是用来表示日期和时间的，这是一个最常用的类之一。 获取当前的日期和时间: LocalDateTime now = LocalDateTime.now(); System.out.println(“现在: “ + now); 输出 现在: 2017-07-20T15:17:19.926 下面使用静态方法和字符串的方式分别创建LocalDateTime对象 LocalDateTime.of(2017, Month.JULY, 20, 15, 18); LocalDateTime.parse(“2017-07-20T15:18:00”); `` 同时LocalDateTime也提供了相关API来对日期和时间进行增减操作: ```java LocalDateTime tomorrow = now.plusDays(1); System.out.println(“明天的这个时间: “ + tomorrow); LocalDateTime minusTowHour = now.minusHours(2); System.out.println(“两小时前: “ + minusTowHour); 这个类也提供一系列的get方法来获取特定单位: Month month = now.getMonth(); System.out.println(“当前月份: “ + month); 日期格式化 在日常开发中我们用到最多的也许就是日期、时间的格式化了，那在Java8种该如何操作呢？ LocalDateTime now = LocalDateTime.now(); DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(“yyyy-MM-dd HH:mm:ss”); System.out.println(“默认格式化: “ + now); System.out.println(“自定义格式化: “ + now.format(dateTimeFormatter)); LocalDateTime localDateTime = LocalDateTime.parse(“2017-07-20 15:27:44”, dateTimeFormatter); System.out.println(“字符串转LocalDateTime: “ + localDateTime); 也可以使用DateTimeFormatter的format方法将日期、时间格式化为字符串 DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(“yyyy-MM-dd”); String dateString = dateTimeFormatter.format(LocalDate.now()); System.out.println(“日期转字符串: “ + dateString); 日期周期 Period类用于修改给定日期或获得的两个日期之间的区别。 给初始化的日期添加5天: LocalDate initialDate = LocalDate.parse(“2017-07-20”); LocalDate finalDate = initialDate.plus(Period.ofDays(5)); System.out.println(“初始化日期: “ + initialDate); System.out.println(“加日期之后: “ + finalDate); 周期API中提供给我们可以比较两个日期的差别，像下面这样获取差距天数: long between = ChronoUnit.DAYS.between(initialDate, finalDate); System.out.println(“差距天数: “ + between); 上面的代码会返回5，当然你想获取两个日期相差多少小时也是简单的。 与遗留代码转换 在之前的代码中你可能出现了大量的Date类，如何将它转换为Java8种的时间类呢？ Date和Instant互相转换 Date date = Date.from(Instant.now()); Instant instant = date.toInstant(); Date转换为LocalDateTime LocalDateTime localDateTime = LocalDateTime.from(new Date()); System.out.println(localDateTime); LocalDateTime转Date Date date = Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant()); LocalDate转Date Date date = Date.from(LocalDate.now().atStartOfDay().atZone(ZoneId.systemDefault()).toInstant]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反射实践]]></title>
    <url>%2F2016%2F07%2F01%2FJava%E5%8F%8D%E5%B0%84%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[Java 反射机制应用实践 Java反射机制是一个非常强大的功能，在很多大型项目比如Spring, Mybatis中都可以看见反射的身影。通过反射机制我们可以在运行期间获取对象的类型信息，利用这一特性我们可以实现工厂模式和代理模式等设计模式，同时也可以解决Java泛型擦除等令人苦恼的问题。本文我们就从实际应用的角度出发，来应用一下Java的反射机制。 反射基础 p.s: 本文需要读者对反射机制的API有一定程度的了解，如果之前没有接触过的话，建议先看一下官方文档的Quick Start。 在应用反射机制之前，首先我们先来看一下如何获取一个对象对应的反射类Class，在Java中我们有三种方法可以获取一个对象的反射类。 通过getClass方法 在Java中，每一个Object都有一个getClass()方法，通过getClass方法我们可以获取到这个对象对应的反射类： String s = “http://www.ziwenxie.site“;Class&lt;?&gt; c = s.getClass(); 通过forName方法 我们也可以调用Class类的静态方法forName()： Class&lt;?&gt; c = Class.forName(“java.lang.String”); 使用.class 或者我们也可以直接使用.class： Class&lt;?&gt; c = String.class; 获取类型信息 在文章开头我们就提到反射的一大好处就是可以允许我们在运行期间获取对象的类型信息，下面我们通过一个例子来具体看一下。 首先我们在typeinfo.interfacea包下面新建一个接口A： package typeinfo.interfacea;public interface A { void f(); } 接着我们在typeinfo.packageaccess包下面新建一个类C，类C实现了接口A，并且我们还另外创建了几个用于测试的方法，注意下面几个方法的权限都是不同的。 package typeinfo.packageaccess;import typeinfo.interfacea.A;class C implements A { public void f() { System.out.println(“public C.f()”); } public void g() { System.out.println(“public C.g()”); } protected void v () { System.out.println(“protected C.v()”); } void u() { System.out.println(“package C.u()”); } private void w() { System.out.println(“private C.w()”); }}public class HiddenC { public static A makeA() { return new C(); }} 在callHiddenMethod()方法中我们用到了几个新的API，其中getDeclaredMethod()根据方法名用于获取Class类指代对象自己声明的某个方法，然后我们通过调用invoke()方法就可以触发对象的相关方法： package typeinfo;import typeinfo.interfacea.A;import typeinfo.packageaccess.HiddenC;import java.lang.reflect.Method;public class HiddenImplementation { public static void main(String[] args) throws Exception { A a = HiddenC.makeA(); a.f(); System.out.println(a.getClass().getName()); // Oops! Reflection still allows us to call g(): callHiddenMethod(a, “g”); // And even methods that are less accessible! callHiddenMethod(a, “u”); callHiddenMethod(a, “v”); callHiddenMethod(a, “w”); } static void callHiddenMethod(Object a, String methodName) throws Exception { Method g = a.getClass().getDeclaredMethod(methodName); g.setAccessible(true); g.invoke(a); }} 从输出结果我们可以看出来，不管是public，default，protect还是private方法，通过反射类我们都可以自由调用。当然这里我们只是为了显示反射的强大威力，在实际开发中这种技巧还是不提倡。 public C.f()typeinfo.packageaccess.Cpublic C.g()package C.u()protected C.v()private C.w() 上面我们只是测试了Method对象，感兴趣的读者在熟悉了反射的API之后，不妨测试一下Filed，这里我们就不重复了。 利用动态代理实现面向切面编程 AOP是Spring提供的一个强大特性之一，AOP的意思是面向切面编程，就是说要分离和业务不相关的代码，当我们需要新增相关的事务的时候，我们不想要对业务本身做修改。面向切面编程和面向对象变成相比到底有什么好处呢，我们通过一个例子来看一下，对于新手来说，常常会写出下面这样的代码： public class Example1 { public void execute() { // 记录日志 Logger logger = Logger.getLog(…); // 进行性能统计 PerformanceUtil.startTimer(…); // 权限检查 if (!user.hasPrevilege()) { // 抛出异常 } // 执行真正的业务 executeTransaction(); PerformanceUtil.endTimer(); }} 虽然我们上面真正要执行的业务只有executeTransaction()，但是日志，性能，权限相关的代码差不多要将真正的业务代码掩盖了。而且以后如果我们还有一个Example2，它同样需要实现相同的日志，性能，权限代码。这样当以后我们需要新增相关的逻辑检查的时候，我们需要所有Example进行重构，这显然不符合面向对象的一个基本原则-封装变化。 上面这个场景利用模板方法和装饰器模式都可以解决，在Spring中是通过动态代理来实现的，下面我们通过一个例子来模拟一下Spring中的AOP实现。 我们要实现的业务时，统计程序统计员工工资所执行的时间以及检查用户的权限。首先先来实现的Salary类，它里面包含一些实现统计员工工资的业务逻辑： public interface SalaryInterface { public void doSalary();} public class Salary implements SalaryInterface { public void doSalary() { … }} 通过InvocationHandler我们来实现动态代理，以后当我们调用obj的相关方法之前，都会通过invoke方法进行代理，而不会直接调用obj方法。 public class SimpleProxy implements InvocationHandler { private Object obj; private Object advice; // 绑定代理对象 public Object bind(Object obj, Advice advice) { this.obj = obj; this.advice = advice; return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), this) } // 实现代理 public Object invoke(Object proxy, Method method, Object[] args) throws Throwalbe { Object result = null; try { advice.before(); result = method.invoke(obj, args); advice.after(); } catch(Exception e) { e.printStackTrace(); } return result }} 模拟Spring中的Advice接口： public interface Advice { public void before(); public void after();} 实现TimeAdvice用于统计程序的执行时间： public class TimeAdvice implements Advice { long startTime; long endTime; @Override public void before() { startTime = System.nanoTime(); // 获取开始时间 } @Override public void after() { endTime = System.nanoTime(); // 获取结束时间 }} 客户端调用代码如下： public class Client { public static void main(String[] args) { SimpleProxy = new SimpleProxy(); SalaryInterface salaryInterface = (SalaryInterface) simpleProxy.bind(new Salary(), new TimeAdvice()); salaryInterface.doSalary(); }} 如果我们现在需要新增权限控制，我们来实现ControlAdvie类： public class ControlAdvice implements Advice { @Override public void before() { if (…) { … } else { … } } @Override public void after() { … }} 而我们客户端的代码只需要改成simpleProxy.bind(new Salary(), new ControlAdvie)就行了，而SimpleProxy本身不需要做任何的修改。 与注解相结合 在单元测试框架比如Junit中反射机制也得到了广泛的应用，即通过注解的方式。下面我们简单地来了解一下如何通过反射机制来获取相关方法的注解信息，比如说我们有下面这样一个业务场景，当用户在修改自己密码的时候，为了保证密码的安全性，我们要求用户的新密码要满足一些条件，比如说至少要包含一个非数字字符，不能与以前的密码相同之类的条件等。 import java.lang.annotation.*@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface UserCase { public int id(); public String description() default “no description”;} 下面是我们检测密码的工具类的实现： public class PasswordUtils { @UserCase(id=47, description=”Password must contain at least one numeric”) public boolean validatePassword(String password) { return (password.matches(“\w\d\w“)); } @UserCase(id=48) public String encryptPassword(String password) { return new StringBuilder(password).reverse().toString(); } @UserCase(id=49, description=”New passwords can’t equal previously used ones”) public boolean checkForNewPassword(List prevPasswords, String password) { return !prevPasswords.contains(password); }} 利用反射我们可以写出更加清晰的测试代码，其中getDeclaredMethods()方法可以获取相关对象自己声明的相关方法，而getAnnotation()则可以获取Method对象的指定注解。 public class UseCaseTracker { public static void trackUseCases(List useCases, Class&lt;?&gt; cl) { for(Method m : cl.getDeclaredMethods()) { UseCase uc = m.getAnnotation(UseCase.class); if(uc != null) { System.out.println(“Found Use Case: “ + uc.id() + “ “ + uc.description()); useCases.remove(new Integer(uc.id())); } } for(int i : useCases) { System.out.println(“Warning: Missing use case-“ + i); } } public static void main(String[] args) { List useCases = new ArrayList(); Collections.addAll(useCases, 47, 48, 49, 50); trackUseCases(userCases, PasswordUtils.class); }} 解决泛型擦除 现在有下面这样一个业务场景，我们有一个泛型集合类List]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>