<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[并发concurrent(2)]]></title>
    <url>%2F2017%2F09%2F05%2F%E5%B9%B6%E5%8F%91concurrent-2%2F</url>
    <content type="text"><![CDATA[并发编程 ：Concurrent ( 中 ) 一般并发，多线程都会结合线程池的使用，所以本篇说说相关线程池。 执行器服务 ExecutorService java.util.concurrent.ExecutorService 接口表示一个异步执行机制，使我们能够在后台执行任务。因此一个 ExecutorService 很类似于一个线程池。实际上，存在于 java.util.concurrent 包里的 ExecutorService 实现就是一个线程池实现。 ExecutorService 例子 以下是一个简单的 ExecutorService 例子： ExecutorService executorService = Executors.newFixedThreadPool(10); executorService.execute(new Runnable() { public void run() { System.out.println(“Asynchronous task”); }}); executorService.shutdown(); 首先使用 newFixedThreadPool() 工厂方法创建一个 ExecutorService。这里创建了一个十个线程执行任务的线程池。然后，将一个 Runnable 接口的匿名实现类传递给 execute() 方法。这将导致 ExecutorService 中的某个线程执行该 Runnable。 任务委派 下图说明了一个线程是如何将一个任务委托给一个 ExecutorService 去异步执行的： 一个线程将一个任务委派给一个 ExecutorService 去异步执行。 一旦该线程将任务委派给 ExecutorService，该线程将继续它自己的执行，独立于该任务的执行。 ExecutorService 实现 既然 ExecutorService 是个接口，如果你想用它的话就得去使用它的实现类之一。 java.util.concurrent 包提供了 ExecutorService 接口的以下实现类： ThreadPoolExecutorScheduledThreadPoolExecutor 创建一个 ExecutorService ExecutorService 的创建依赖于你使用的具体实现。但是你也可以使用 Executors 工厂类来创建 ExecutorService 实例。 以下是几个创建 ExecutorService 实例的例子： ExecutorService executorService1 = Executors.newSingleThreadExecutor(); ExecutorService executorService2 = Executors.newFixedThreadPool(10); ExecutorService executorService3 = Executors.newScheduledThreadPool(10); ExecutorService 使用 有几种不同的方式来将任务委托给 ExecutorService 去执行： execute(Runnable)submit(Runnable)submit(Callable)invokeAny(…)invokeAll(…) 接下来我们挨个看一下这些方法。 execute(Runnable) execute(Runnable) 方法要求一个 java.lang.Runnable 对象，然后对它进行异步执行。以下是使用 ExecutorService 执行一个 Runnable 的示例： ExecutorService executorService = Executors.newSingleThreadExecutor(); executorService.execute(new Runnable() { public void run() { System.out.println(“Asynchronous task”); }}); executorService.shutdown(); 没有办法得知被执行的 Runnable 的执行结果。如果有需要的话你得使用一个 Callable(以下将做介绍)。 submit(Runnable) submit(Runnable) 方法也要求一个 Runnable 实现类，但它返回一个 Future 对象。这个 Future 对象可以用来检查 Runnable 是否已经执行完毕。以下是 ExecutorService submit() 示例： Future future = executorService.submit(new Runnable() { public void run() { System.out.println(“Asynchronous task”); }}); future.get(); //returns null if the task has finished correctly. submit(Callable) submit(Callable) 方法类似于 submit(Runnable) 方法，除了它所要求的参数类型之外。Callable 实例除了它的 call() 方法能够返回一个结果之外和一个 Runnable 很相像。Runnable.run() 不能够返回一个结果。Callable 的结果可以通过 submit(Callable) 方法返回的 Future 对象进行获取。 以下是一个 ExecutorService Callable 示例： Future future = executorService.submit(new Callable(){ public Object call() throws Exception { System.out.println(“Asynchronous Callable”); return “Callable Result”; }}); System.out.println(“future.get() = “ + future.get()); 以上代码输出： Asynchronous Callablefuture.get() = Callable Result invokeAny() invokeAny() 方法要求一系列的 Callable 或者其子接口的实例对象。调用这个方法并不会返回一个 Future，但它返回其中一个 Callable 对象的结果。无法保证返回的是哪个 Callable 的结果 – 只能表明其中一个已执行结束。 如果其中一个任务执行结束(或者抛了一个异常)，其他 Callable 将被取消。以下是示例代码： ExecutorService executorService = Executors.newSingleThreadExecutor(); Set]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java 并发编程之 NIO]]></title>
    <url>%2F2017%2F09%2F01%2FNIO%2F</url>
    <content type="text"><![CDATA[Java 并发编程之 NIO 问题来源 在传统的架构中，对于客户端的每一次请求，服务器都会创建一个新的线程或者利用线程池复用去处理用户的一个请求，然后返回给用户结果，这样做在高并发的情况下会存在非常严重的性能问题：对于用户的每一次请求都创建一个新的线程是需要一定内存的，同时线程之间频繁的上下文切换也是一个很大的开销。 p.s: 本文涉及的完整实例代码都可以在我的GitHub上面下载。 什么是Selector NIO的核心就是Selector，读懂了Selector就理解了异步机制的实现原理，下面先来简单的介绍一下什么是Selector。现在对于客户端的每一次请求到来时我们不再立即创建一个线程进行处理，相反以epool为例子当一个事件准备就绪之后通过回调机制将描述符加入到阻塞队列中，下面只需要通过遍历阻塞队列对相应的事件进行处理就行了，通过这种回调机制整个过程都不需要对于每一个请求都去创建一个线程去单独处理。上面的解释还是有些抽象，下面我会通过具体的代码实例来解释，在这之前我们先来了解一下NIO中两个基础概念Buffer和Channel。 如果大家对于多路IO复用比如select/epool完全陌生的话，建议先读一下我的这篇Linux下的五种IO模型 :-) Buffer 以ByteBuffer为例子，我们可以通过ByteBuffer.allocate(n)来分配n个字节的缓冲区，对于缓冲区有四个重要的属性： capacity，缓冲区的容量，也就是我们上面指定的n。position，当前指针指向的位置。mark，前一个位置，这里我们下面再解释。limit，最大能读取或者写入的位置。 如上图所示，Buffer实际上也是分为两种，一种用于写数据，一种用于读取数据。 put 通过直接阅读ByteBuffer源码可以清晰看出put方法是把一个byte变量x放到缓冲区中去，同时position加1： public ByteBuffer put(byte x) { hb[ix(nextPutIndex())] = x; return this;}final int nextPutIndex() { if (position &gt;= limit) throw new BufferOverflowException(); return position++;} get get方法是从缓冲区中读取一个字节，同时position加一： public byte get() { return hb[ix(nextGetIndex())];}final int nextGetIndex() { if (position &gt;= limit) throw new BufferUnderflowException(); return position++;} flip 如果我们想将buffer从写数据的情况变成读数据的情况，可以直接使用flip方法： public final Buffer flip() { limit = position; position = 0; mark = -1; return this;} mark和reset mark是记住当前的位置用的，也就是保存position的值： public final Buffer mark() { mark = position; return this;} 如果我们在对缓冲区读写之前就调用了mark方法，那么以后当position位置变化之后，想回到之前的位置可以调用reset会将mark的值重新赋给position： public final Buffer reset() { int m = mark; if (m &lt; 0) throw new InvalidMarkException(); position = m; return this;} Channel 利用NIO，当我们读取数据的时候，会先从buffer加载到channel，而写入数据的时候，会先入到channel然后通过channel转移到buffer中去。channel给我们提供了两个方法：通过channel.read(buffer)可以将channel中的数据写入到buffer中，而通过channel.write(buffer)则可以将buffer中的数据写入到到channel中。 Channel的话分为四种： FileChannel从文件中读写数据。DatagramChannel以UDP的形式从网络中读写数据。SocketChannel以TCP的形式从网络中读写数据。ServerSocketChannel允许你监听TCP连接。 因为今天我们的重点是Selector，所以来看一下SocketChannel的用法。在下面的代码利用SocketChannel模拟了一个简单的server-client程序。 WebServer的代码如下，和传统的sock程序并没有太多的差异，只是我们引入了buffer和channel的概念： ServerSocketChannel ssc = ServerSocketChannel.open();ssc.socket().bind(new InetSocketAddress(“127.0.0.1”, 5000));SocketChannel socketChannel = ssc.accept();ByteBuffer readBuffer = ByteBuffer.allocate(128);socketChannel.read(readBuffer);readBuffer.flip();while (readBuffer.hasRemaining()) { System.out.println((char)readBuffer.get());}socketChannel.close();ssc.close(); WebClient的代码如下： SocketChannel socketChannel = null;socketChannel = SocketChannel.open();socketChannel.connect(new InetSocketAddress(“127.0.0.1”, 5000));ByteBuffer writeBuffer = ByteBuffer.allocate(128);writeBuffer.put(“hello world”.getBytes());writeBuffer.flip();socketChannel.write(writeBuffer);socketChannel.close(); Scatter / Gather 在上面的client程序中，我们也可以同时将多个buffer中的数据放入到一个数组后然后统一放入到channel后传递给服务器： ByteBuffer buffer1 = ByteBuffer.allocate(128);ByteBuffer buffer2 = ByteBuffer.allocate(16);buffer1.put(“hello “.getBytes());buffer2.put(“world”.getBytes());buffer1.flip();buffer2.flip();ByteBuffer[] bufferArray = {buffer1, buffer2};socketChannel.write(bufferArray); Selector 通过使用selector，我们可以通过一个线程来同时管理多个channel，省去了创建线程以及线程之间进行上下文切换的开销。 创建一个selector 通过调用selector类的静态方法open我们就可以创建一个selector对象： Selector selector = Selector.open(); 注册channel 为了保证selector能够监听多个channel，我们需要将channel注册到selector当中： channel.configureBlocking(false);SelectionKey key = channel.register(selector, SelectionKey.OP_READ); 我们可以监听四种事件： SelectionKey.OP_CONNECT：当客户端的尝试连接到服务器SelectionKey.OP_ACCEPT：当服务器接受来自客户端的请求SelectionKey.OP_READ：当服务器可以从channel中读取数据SelectionKey.OP_WRITE：当服务器可以向channel中写入数据 对SelectorKey调用channel方法可以得到key对应的channel: Channel channel = key.channel(); 而key自身感兴趣的监听事件也可以通过interestOps来获得： int interestSet = selectionKey.interestOps(); 对selector调用selectedKeys()方法我们可以得到注册的所有key： Set selectedKeys = selector.selectedKeys(); 实战 服务器的代码如下： ServerSocketChannel ssc = ServerSocketChannel.open();ssc.socket().bind(new InetSocketAddress(“127.0.0.1”, 5000));ssc.configureBlocking(false);Selector selector = Selector.open();ssc.register(selector, SelectionKey.OP_ACCEPT);ByteBuffer readBuff = ByteBuffer.allocate(128);ByteBuffer writeBuff = ByteBuffer.allocate(128);writeBuff.put(“received”.getBytes());writeBuff.flip(); // make buffer ready for readingwhile (true) { selector.select(); Set keys = selector.selectedKeys(); Iterator it = keys.iterator(); while (it.hasNext()) { SelectionKey key = it.next(); it.remove(); if (key.isAcceptable()) { SocketChannel socketChannel = ssc.accept(); socketChannel.configureBlocking(false); socketChannel.register(selector, SelectionKey.OP_READ); } else if (key.isReadable()) { SocketChannel socketChannel = (SocketChannel) key.channel(); readBuff.clear(); // make buffer ready for writing socketChannel.read(readBuff); readBuff.flip(); // make buffer ready for reading System.out.println(new String(readBuff.array())); key.interestOps(SelectionKey.OP_WRITE); } else if (key.isWritable()) { writeBuff.rewind(); // sets the position back to 0 SocketChannel socketChannel = (SocketChannel) key.channel(); socketChannel.write(writeBuff); key.interestOps(SelectionKey.OP_READ); } }} 客户端程序的代码如下，各位读者可以同时在终端下面多开几个程序来同时模拟多个请求，而对于多个客户端的程序我们的服务器始终只用一个线程来处理多个请求。一个很常见的应用场景就是多个用户同时往服务器上传文件，对于每一个上传请求我们不在单独去创建一个线程去处理，同时利用Executor/Future我们也可以不用阻塞在IO操作中而是立即返回用户结果。 SocketChannel socketChannel = SocketChannel.open();socketChannel.connect(new InetSocketAddress(“127.0.0.1”, 5000));ByteBuffer writeBuffer = ByteBuffer.allocate(32);ByteBuffer readBuffer = ByteBuffer.allocate(32);writeBuffer.put(“hello”.getBytes());writeBuffer.flip(); // make buffer ready for readingwhile (true) { writeBuffer.rewind(); // sets the position back to 0 socketChannel.write(writeBuffer); // hello readBuffer.clear(); // make buffer ready for writing socketChannel.read(readBuffer); // recieved}]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间观念]]></title>
    <url>%2F2017%2F08%2F26%2F%E6%97%B6%E9%97%B4%E8%A7%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[时间的概念因为我们不知道，究竟什么对我们最重要，所以，每件事都花不少时间，盲目行动，浪费时间。有些人看到我们每一件事都做， 所以，他们期望我们什么都做。每一件事都做让我们非常忙碌，所以，我们没有时间去考虑，究竟什么对我们重要。怎么去规划时间，管理时间，不让时间管理我们。时间，在我们人生中是最珍贵的，所以，我们要高效率利用它。 1.大家可能问时间有什么意义？ 我废话少说，大家想象五年后的你?然后我们把这个5年倒回来看看。 What you are doing in 5 years? 你可能长叹一口气，……yes?（哈哈） 我的回答可能是：拥有一家大数据，物联网相关的公司正在运营（这是自己的一个痴心妄想，也踏上这条路的初心，哈哈）。那么第四年，公司已经成熟，有固定的客户，业务，稳定业绩。第三年，公司逐步进入正轨，走上成熟，走过重重浴火，终于要变成小鸟，凤凰就不敢了。第二年，公司刚刚成立不久，正是瓶颈期，为业务种种发愁。第一年，公司注册，团队组建完成，公司选址等等准备完成。 这个只是的简单想法，只是为了举例让读者明白罢了。 2.个人的处理事情的原则（可以给大家参考），我分为五类 ①重要紧急②重要不紧急③紧急不重要（委托授权）④不重要不紧急 符永坤（富伊克fuyk） 著]]></content>
      <categories>
        <category>职业知识</category>
      </categories>
      <tags>
        <tag>职业修养</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[致即将毕业的我]]></title>
    <url>%2F2017%2F08%2F26%2F%E8%87%B4%E6%AF%95%E4%B8%9A%E7%9A%84%E8%87%AA%E5%B7%B1%2F</url>
    <content type="text"><![CDATA[面临毕业的自己，听师兄师姐们的侃侃而谈，自己也担忧起了自己的就业前程，毕业就是失业。所以自己也有了面临就业的临危感，俗话说祸起 乃于萧蔷也。归根结底是自己的问题，我的座右铭是：世上无难事，只要肯登攀。机会是留给有准备的人，此时的我又激情澎湃了。所以埋头学习了起来。拿起笔学习有关职业方面知识。 1.1准备职业人定位 1.1.1那么什么是职业人? 人力资源专家胡斌曾把人分为：“没人经营的人”，“别人经营的人”，“自我经营的人”和“经营别人的人”四种。职业人属于那个范畴相信大家已有所思 既然进入企业，职业人必须按企业对员工的标准要求自己，这是职业人基本素质。 1.2由院校人向企业人转变 在学校时的几个特点： 》可以与喜欢的人在一起，自己选择性。 》可以喜形于色。 》考试通过就OK，分数比什么都重要，而且闭卷考试（不可以其他辅助完成）。 》事情自己做的，成绩当然归功于自己 》喜欢做“与众不同的人” 》自由性强 》。。。。。。。。。。。大家可以集思广益 所以我们必须转变思想，向企业，社会转型》 ①个人--团队导向 在学校中，以自我为中心的模式不适合于企业，个人的成功必须与整体的成功结合才有意义。一荣俱荣，一损俱损，重个性 转变到重标准；以个人衡量到集体衡量；独创到协作；独行到合作。 ②情感--职业导向 情绪化是学生显著的特征之一，职业场格格不入的，注重游戏规则，个人好恶不能左右于你。 ③思维--行为导向 学生学习，重在开发智力，学习知识，往往都是3思维的训练。这也是和企业有很大的不同，转变也就必不可少了。 思维至上转变到产品至上；想到就行转到做到才行，而且要做到最好；理论家转变到实干家；注重思考，分析。 ⑤个人资源--组织资源 1.2.1企业目标 企业需要对客户负责，对社会负责，对投资者负责，对员工负责。 联想公司对员工要求，也是招聘人才的要求： 1.知识，是基础。 2.人际交往。团队合作和团队精神，现代企业非常注重。 3.责任感。对自己所做的事情负责 4.能力，知识不等于能力，能力取决于个人执行力等等。 5.敬业。干一行爱一行，真正爱自己的工作，不是爱一行，干一行。企业不花钱养废人。]]></content>
      <categories>
        <category>职业知识</category>
      </categories>
      <tags>
        <tag>职业修养</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux（一）]]></title>
    <url>%2F2017%2F08%2F25%2FLinux%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[先说明本文：图片没有贴出，大家认真阅读不影响 一 ：为什么学Linux Linux的历史发展大家可以百度一些，了解了解就ok,学利用一切可以利用的资源； 1.Linux的特点： 第一： 免费开源，了解它的发展就知道为什么开源了，一款完全的免费的操作系统，都可以下载它的源码，没有什么限制。 第二： 模块化程度高。 Linux 的 内核 设计 分成 进程 管理、 内存 管理、进程 间 通信、 虚拟 文件 系统、 网络 5 部分， 其 采用 的 模块 机制 使得 用户 可以 根据 实际 需要， 在 内核 中 插入 或 移走 模块， 这使 得 内核 可以 被 高度 的 剪裁 定制， 以 方便 在 不同 的 场景 下 使用。 . 第三： 广泛 的 硬件 支持。 得 益于 其 免费 开源 的 特点， 有 大批 程序员 不断 地 向 Linux 社区 提供 代码， 使得 Linux 有着 异常 丰富 的 设备 驱动 资源， 对 主流 硬件 的 支持 极好， 而且 几乎 能 运行 在 所有 流行 的 处理器 上。 第四： 安全 稳定。 Linux 采取 了 很多 安全 技术 措施， 包括 读写 权限 控制、 带 保护 的 子系统、 审计 跟踪、 核心 授权 等， 这 为 网络 环境 中的 用户 提供 了 安全保障。 实际 上有 很多 运行 Linux 的 服务器 可以 持续 运行 长达 数年 而 无须 重 启， 依然 可以 性能 良好 地 提供 服务， 其 安全 稳定性 已经 在各 个领域 得到 了 广泛 的 证实。 第五： 多用户， 多任务。 多用户 是指 系统 资源 可以 同时 被 不同 的 用户 使用， 每个 用户 对 自己的 资源 有 特定 的 权限， 互不 影响。 多任务 是 现代化 计算机的 主要 特点， 指的 是 计算 机能 同时 运行 多个 程序， 且 程序 之间 彼此 独立， Linux 内核 负责 调度 每个 进程， 使之 平等 地 访问 处理器。 由于 CPU 处理 速度 极快， 从 用户 的 角度 来看 所有 的 进程 好像 在 并行 运行。 第六： 良好 的 可移植性。 Linux 中 95% 以上 的 代码 都是 用 C 语言 编写 的， 由于 C 语言 是一 种 机器 无关 的 高级 语言， 是 可 移植 的， 因此 Linux 系统 也是 移植的 1.2Linux优点： 稳定、免费或者花费少 安全性高 多任务，多用户 耗资源少 由于内核小，所以它可以支持多种电子产品，如：Android手机、PDA等 1.3安装（建议初学者可以以下） 在安装Linux系统之前，先来了解windows系统结构，windows系统一般是安装在C盘系统盘，同样Linux也有类似的系统盘（/根分区），Linux通常分区为（根分区/、swap分区），Linux系统以文件的存储方式，所有的文件都是存储在某个目录下的，类似于windows的文件夹。对于文件系统的属性来说，windows文件系统类型一般是ntfs、fat32等，而Linux文件系统类型则为ext2、ext3、ext4等（文件系统：是操作系统用于明确磁盘或分区上的文件的方法和数据结构，文件系统由三部分组成：与文件管理有关软件、被管理文件以及实施文件管理所需数据结构。）安装 Linux系统是每一个初学者的第一个门槛。在这个过程中间，最大的困惑莫过于给硬盘进行分区。虽然现在各种发行版本的 Linux 已经提供了友好的图形交互界面，但是很多人还是感觉无从下手。这其中的原因主要是不清楚 Linux 的分区规定。就好比如果我们了解了windows分区的规则，系统盘C、数据盘D等，就很好分区了。在 Linux 中规定，每一个硬盘设备最多只能有 4个主分区（其中包含扩展分区）构成，任何一个扩展分区都要占用一个主分区号码，也就是在一个硬盘中，主分区和扩展分区一共最多是 4 个。下面正式来安装Linux系统，安装系统前需要准备如下软件： VMware workstation 10.0（可以百度一下）CentOS 5.8 x86_i386.i或redhat（Linux官网下载） 说明：可能随时间更新版本可能安装有一定差异，不过换汤不换药，相信我们这些IT男的头脑这so easy。 1. 3. 1 安装 前 的 规划 可能会有读者正计划学习Linux 而苦恼于 不知道 使用 哪一个 发行 版， 其实 所有 的 发行 版 不管 是 RedHat、 CentOS 还是 Ubuntu， 其内 核 都是 来自 Linux 内核 官 网（ www. kernel. org）， 不同 发行 版 之间 的 差别 在于 软件 管理 的 不同， 所以 不管 使用 哪一个 发行 版， 只要 理解 其 原理 之后， 各类 发行 版 的 区别 其实 不大。 当然 对于 初学者 来说， 拥有 广泛 的 学习 资源 也是 很重 要的。 由于 RedHat 公司 进行 了 大力 商业 推广， 且 得 益于 其 成熟 的 认证 体系， 因此 使用 RedHat 的 用户 比较 多， 同时， 它 还有 丰富 的 相关 技术 文档， 以及 活跃 的 社区， 所以 作为 入门 学习， 可以 使用 RedHat。 不过年来，CentOS 发展 也 很 迅猛， 这个 发行 版 和 RedHat 几乎 完全 一样， 而且 在 某些方面 还 比 RedHat 略胜一筹， 所以 在 本书 中 后面 的 所有 内容 中将 主要 使用 版本 为 5. 5 的 CentOS， 小部分 涉及 RedHat 的 内容 也 将 采用 5. 5 版本。 有 读者 可能 会 考虑 在 一台 计算 机上 安装 多个 操作系统， 比如说 在 自己的 家用 计算 机上 安装 Windows 用于 娱乐 和 日常 应用 或 Windows 环境 下 的 开发 等， 另外 再 安装 Linux 系统 用于 学习。 在 这种 情况下， 最简单 的 安装 方法 是 先 安装 Windows， 后 安装 Linux， 这样 开机 的 时候 就 自动 出现 操作系统 选择 条， 可以 根据 实际需要 选择 进入 不同 的 操作系统。 由于 Linux 对 系统 的 需求 并不 高， 所以 几乎 所有 计算机 都可以 安装， 但是 考虑到 入门 学习 Linux 需要 用到 图形 界面， 所以 建议 最好 不要 低于 以下 配置： CPU， P- 3 800MHz； 内存， 1GB； 硬盘， 40GB。 在 安装 Linux 的 过程中， 必须 要有 的 两个 分区 为 根 分区（/） 和 swap 分区（ 交换 分区）， 当然 还有 一些 其他 的 分区 可以 独立 出来， 比如说/ boot 分区、/ var 分区 等。 另外， 这里 介绍 几个 概念， 便于 大家 理解 后面 即将 出现 的 一些 专业 词汇。 什么 是 交换 分区？ 交换 分区 是一 个 特殊 的 分区， 它的 作用 相当于 Windows 下 的 虚拟 内存， 这个 分区 的 大小 一般 设置 为 物理 内存 的 两倍， 但是 不管 物理 内存 有 多大， 交换 分区 建议 不要 超过 8GB， 因为 大于 8GB 的 交换 分区 其实 并没有 多大 实际意义。 什么 是 Grub？ Grub 是一 个 系统 引导 工具， 通过 它可 以 加载 内核， 从而 在 安装 Linux 的 过程中， 必须 要有 的 两个 分区 为 根 分区（/） 和 swap 分区（ 交换 分区）， 当然 还有 一些 其他 的 分区 可以 独立 出来， 比如说/ boot 分区、/ var 分区 等。 另外， 这里 介绍 几个 概念， 便于 大家 理解 后面 即将 出现 的 一些 专业 词汇。 什么 是 交换 分区？ 交换 分区 是一 个 特殊 的 分区， 它的 作用 相当于 Windows 下 的 虚拟 内存， 这个 分区 的 大小 一般 设置 为 物理 内存 的 两倍， 但是 不管 物理 内存 有 多大， 交换 分区 建议 不要 超过 8GB， 因为 大于 8GB 的 交换 分区 其实 并没有 多大 实际意义。 什么 是 Grub？ Grub 是一 个 系统 引导 工具， 通过 它可 以 加载 内核， 从而 引导 系统 启动。 什么 是/ boot 分区？/ boot 分区 用于 放置 Linux 启动 所 用到 的 文件， 如 kernel 和 initrd 文件。 什么 是 DHCP？ DHCP 是 Dynamic Host Configuration Protocol 的 简写， 中文 称为 动态 主机 配置 协议。 在 TCP/ IP 网络 中， 每 台 主机 都 需要 有 IP 地址 才能 与其 他 主机 通信， 在 一个 大规模 的 网络 中， 如果 由 管理员 手动 地 对 每一 台 主机 进行 IP 地址 配置 是 不现实 的。 由此 也就 产生了 DHCP 协议， 可用 它来 2 安装 RedHat 本节 将 演示 安装 RedHat 系统 的 过程， 使 用到 的 版本 是 RedHat 5. 5。 大家 可以 先到 网上 下载 RedHat 5. 5 操作系统 的 ISO 文件， 然后 刻成 光盘 再 安装。 当然 不要 忘记 在 计算机 的 主 板 中 设置 从 光驱 启动， 也可以 使用 虚拟 机 软件 通过 安装 虚拟 机 的 方式 模拟 安装 过程。 计算机 从 光盘 启动 后， 首先 会 显示 如图 1- 1 所示 界面（ 注意 看 英文 提示）。 如果 想 使用 图形 界面 安装 直接 按 回车 键 即可， 或者 在 10 秒 之内 不做 任何 输入， 这样 也会 默认 进入 图形 安装 模式。 如果 想用 字符 模式 安装， 需要 输入 linux text， 然后 按 回车 键。 如果 计算机 的 内存 过小， 安装 程序 会 检测 到 因 内存 不足 而无 法 进入 图形 安装 模式， 转而 进入 字符 安装 模式。 安装图解如下：第一步，新建虚拟机如下图： 第二步，选择相关选项，如下图： 第三步选择“稍后安装操作系统”，如下图: 第四步，选择客户机操作系统类型如下图： 第五步，设置虚拟机硬盘大小为20G，最低不能小于5G，如下图 第六步，虚拟机新建完成，如下图： 第七步，修改虚拟机内存为512M，并添加ISO镜像，如下图： 自此，虚拟机新建完成，接下来点击“启动此虚拟机”进行Linux系统安装，Linux系统安装图解如下：第一步，进入安装界面，直接按Enter回车键即可。 第二步，光盘检测，选择SKIP跳过。 第三步，选择安装过程中的语言，初学者可以选择“简体中文”。 第四步，选择初始化整个硬盘，清除所有数据。 第五步，选择分区方式为“自定义分区“。 点击“新建“-首先创建一个swap交换分区，大小为物理内存的2倍（1024M）。 第六步，继续创建分区，选择“新建“，然后创建根分区/，如下图选择，大小为剩余所有空间即可。 第七步，默认点击下一步，同时默认DHCP配置，时钟选择上海，去掉UTC勾，点击下一步。 第八步，设置root密码，至少六位，点击下一步。 第九步，系统安装包选择，这里选择“现在定制“。 第十步，系统安装包选择，左侧选择“开发“—-右侧选择”开发工具“和“开发库”，语言选择“支持中文“，其他一概不选择。 安装完毕会提示“reboot“，直接回车即可。 .]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[whystudyIT]]></title>
    <url>%2F2017%2F08%2F07%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B5%B0%E4%B8%8A%E8%BF%99%E8%B7%AF%2F</url>
    <content type="text"></content>
      <categories>
        <category>关于我</category>
      </categories>
      <tags>
        <tag>story</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexoStudy]]></title>
    <url>%2F2017%2F08%2F05%2FhexoStudy%2F</url>
    <content type="text"><![CDATA[前提准备 NodeJSgit确保安装这两个才可以继续。 安装Hexo打开git $ npm install -g hexo部署Hexo在任何想要放置Hexo的文件夹下建立名为Hexo的文件夹，在此文件夹中右键打开Git Bash $ hexo initHexo会自动建立所有博客需要的文件 $ hexo g$ hexo s输入上面的命令就可以在本地看到初始化的博客啦，浏览器中输入localhost:4000以上就完成了博客的本地调试了，下面需要将本地的博客放到github中去，利用github pages 的免费空间存放你的博客，而且别人也可以访问你的博客。 配置和使用github首先需要注册github（废话。。划掉），然后登录github，点击右上角你的头像，再点击Settings，进入设置页面。点击侧栏的SSH and GPG keys,可以查看你是否有本机的SSH密匙。如果没有，说明并没有设置SSH密匙。 检查SSH keys的设置先不管github的网页，回到本机，打开Git Bash。输入： $ cd ~/. ssh 检查本机的ssh密钥如果提示：No such file or directory 说明你是第一次使用git。 生成新的SSH Key：继续输入： $ ssh-keygen -t rsa -C “邮件地址@youremail.com”Generating public/private rsa key pair.Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt;系统会要求你输入密码，输入就好，只是这里的输入是不显示占位符的。 Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;Enter same passphrase again:&lt;再次输入加密串&gt;完成后就会提示你的密匙文件所在的位置，打开id_rsa.pub文件，复制所有，回到github网页，点击New SSH key,粘贴到key文本框中，点击add key就可以了。 测试SSH连接输入下面的命令，git@github.com不用修改。 $ ssh -T git@github.com会有这样的反馈： The authenticity of host ‘github.com (207.97.227.239)’ can’t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)?输入yes，就会看到： Hi Dulmcat! You’ve successfully authenticated, but GitHub does not provide shell access.到这里就代表已经正确的连接到github了。 设置用户信息但还有一些个人信息还是需要继续完善下的，Git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的。 $ git config –global user.name “cnfeat”//用户名$ git config –global user.email “cnfeat@gmail.com”//填写自己的邮箱若有问题，从头再来一遍，或者到GitHub help中寻找解决方案。 使用GitHub pages 建立网页与GitHub建立好链接之后，就可以方便的使用它提供的Pages服务。但pages服务每个ID只有一个，大小也只有300M，但作为博客站，已经足够了。 建立仓库登录GitHub后，点击那个大大的绿色New repository按钮，新建一个仓库：Repository name：dulmcat.github.ioDescription (optional): 嗯。。括号里都说了是可选的，就随便吧，可填可不填。注意！！ 这里的Repository name必须是你的github用户名.github.io，否则就不是一个github pages而只是单纯的一个仓库了。点击Create Repository 完成创建。 上传hexo到github pages上传前，需要将Hexo和github想关联起来，在Hexo的配置文件_config.yml文件中,拉到最下面，修改配置文件： deploy: type: git repository: https://github.com/Dulmcat/Dulmcat.github.io branch: master这里的repository填写的是你的github pages所在库（就是上面刚建好的那个）的地址。这里有个坑，关于type的填写，有说应该是github的，有说是git的，我在两个月前的配置文件type写的github，写这篇文章时发现出错了，这才发现好像是作者在3.0之后改为了git，大家在安装Hexo时可以输入命令hexo-v查看Hexo的版本。在3.0之后需要另外安装hexo-deployer-git。 $ npm install hexo-deployer-git –save然后 $ hexo d这里可能会要求填写密码，填了就好。然后在浏览器中输入https://dulmcat.github.io 就可以看到你的博客啦一个在线的博客就这样建好了当然这是我的…要输入 你的github用户名.github.io]]></content>
      <categories>
        <category>hexo建博小结</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程 ：Concurrent （一）]]></title>
    <url>%2F2017%2F08%2F05%2F%E5%B9%B6%E5%8F%91concurrent%2F</url>
    <content type="text"><![CDATA[并发编程 ：Concurrent ( 上 ) 最近工作中用到并发相关知识，所以趁机复习一些相关知识，知识确定要间断复习，温故而知新不说，至少让你记忆加深。 java.util.concurrent – Java 并发工具包 阻塞队列 BlockingQueue java.util.concurrent 包里的 BlockingQueue 接口表示一个线程安放入和提取实例的队列。本小节我将给你演示如何使用这个 BlockingQueue。本节不会讨论如何在 Java 中实现一个你自己的 BlockingQueue。如果你对那个感兴趣，参考《Java 并发指南》 BlockingQueue 用法 BlockingQueue 通常用于一个线程生产对象，而另外一个线程消费这些对象的场景。下图是对这个原理的阐述： 一个线程往里边放，另外一个线程从里边取的一个 BlockingQueue。 一个线程将会持续生产新对象并将其插入到队列之中，直到队列达到它所能容纳的临界点。也就是说，它是有限的。如果该阻塞队列到达了其临界点，负责生产的线程将会在往里边插入新对象时发生阻塞。它会一直处于阻塞之中，直到负责消费的线程从队列中拿走一个对象。负责消费的线程将会一直从该阻塞队列中拿出对象。如果消费线程尝试去从一个空的队列中提取对象的话，这个消费线程将会处于阻塞之中，直到一个生产线程把一个对象丢进队列。 BlockingQueue 的方法 BlockingQueue 具有 4 组不同的方法用于插入、移除以及对队列中的元素进行检查。如果请求的操作不能得到立即执行的话，每个方法的表现也不同。这些方法如下： 四组不同的行为方式解释： 抛异常：如果试图的操作无法立即执行，抛一个异常。特定值：如果试图的操作无法立即执行，返回一个特定的值(常常是 true / false)。阻塞：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行。超时：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功(典型的是 true / false)。 无法向一个 BlockingQueue 中插入 null。如果你试图插入 null，BlockingQueue 将会抛出一个 NullPointerException。 可以访问到 BlockingQueue 中的所有元素，而不仅仅是开始和结束的元素。比如说，你将一个对象放入队列之中以等待处理，但你的应用想要将其取消掉。那么你可以调用诸如 remove(o) 方法来将队列之中的特定对象进行移除。但是这么干效率并不高(译者注：基于队列的数据结构，获取除开始或结束位置的其他对象的效率不会太高)，因此你尽量不要用这一类的方法，除非你确实不得不那么做。 BlockingQueue 的实现 BlockingQueue 是个接口，你需要使用它的实现之一来使用 BlockingQueue。java.util.concurrent 具有以下 BlockingQueue 接口的实现(Java 6)： ArrayBlockingQueueDelayQueueLinkedBlockingQueuePriorityBlockingQueueSynchronousQueue Java 中使用 BlockingQueue 的例子 这里是一个 Java 中使用 BlockingQueue 的示例。本示例使用的是 BlockingQueue 接口的 ArrayBlockingQueue 实现。 首先，BlockingQueueExample 类分别在两个独立的线程中启动了一个 Producer 和 一个 Consumer。 Producer 向一个共享的 BlockingQueue 中注入字符串，而 Consumer 则会从中把它们拿出来。 public class BlockingQueueExample { public static void main(String[] args) throws Exception { BlockingQueue queue = new ArrayBlockingQueue(1024); Producer producer = new Producer(queue); Consumer consumer = new Consumer(queue); new Thread(producer).start(); new Thread(consumer).start(); Thread.sleep(4000); } } 以下是 Producer 类。注意它在每次 put() 调用时是如何休眠一秒钟的。这将导致 Consumer 在等待队列中对象的时候发生阻塞。 public class Producer implements Runnable{ protected BlockingQueue queue = null; public Producer(BlockingQueue queue) { this.queue = queue; } public void run() { try { queue.put(&quot;1&quot;); Thread.sleep(1000); queue.put(&quot;2&quot;); Thread.sleep(1000); queue.put(&quot;3&quot;); } catch (InterruptedException e) { e.printStackTrace(); } } } 以下是 Consumer 类。它只是把对象从队列中抽取出来，然后将它们打印到 System.out。 public class Consumer implements Runnable{ protected BlockingQueue queue = null; public Consumer(BlockingQueue queue) { this.queue = queue; } public void run() { try { System.out.println(queue.take()); System.out.println(queue.take()); System.out.println(queue.take()); } catch (InterruptedException e) { e.printStackTrace(); } } } 数组阻塞队列 ArrayBlockingQueue ArrayBlockingQueue 类实现了 BlockingQueue 接口。 ArrayBlockingQueue 是一个有界的阻塞队列，其内部实现是将对象放到一个数组里。有界也就意味着，它不能够存储无限多数量的元素。它有一个同一时间能够存储元素数量的上限。你可以在对其初始化的时候设定这个上限，但之后就无法对这个上限进行修改了(译者注：因为它是基于数组实现的，也就具有数组的特性：一旦初始化，大小就无法修改)。 ‘ArrayBlockingQueue 内部以 FIFO(先进先出)的顺序对元素进行存储。队列中的头元素在所有元素之中是放入时间最久的那个，而尾元素则是最短的那个。 以下是在使用 ArrayBlockingQueue 的时候对其初始化的一个示例： BlockingQueue queue = new ArrayBlockingQueue(1024); queue.put(“1”); Object object = queue.take(); 以下是使用了 Java 泛型的一个 BlockingQueue 示例。注意其中是如何对 String 元素放入和提取的： BlockingQueue queue = new ArrayBlockingQueue(1024); queue.put(“1”); String string = queue.take(); 延迟队列 DelayQueue DelayQueue 实现了 BlockingQueue 接口。DelayQueue 对元素进行持有直到一个特定的延迟到期。注入其中的元素必须实现 java.util.concurrent.Delayed 接口，该接口定义： public interface Delayed extends Comparable&lt;Delayed&lt; { public long getDelay(TimeUnit timeUnit); } DelayQueue 将会在每个元素的 getDelay() 方法返回的值的时间段之后才释放掉该元素。如果返回的是 0 或者负值，延迟将被认为过期，该元素将会在 DelayQueue 的下一次 take 被调用的时候被释放掉。传递给 getDelay 方法的 getDelay 实例是一个枚举类型，它表明了将要延迟的时间段。 TimeUnit 枚举将会取以下值： DAYSHOURSMINUTESSECONDSMILLISECONDSMICROSECONDSNANOSECONDS 正如你所看到的，Delayed 接口也继承了 java.lang.Comparable 接口，这也就意味着 Delayed 对象之间可以进行对比。这个可能在对 DelayQueue 队列中的元素进行排序时有用，因此它们可以根据过期时间进行有序释放。以下是使用 DelayQueue 的例子： public class DelayQueueExample { public static void main(String[] args) { DelayQueue queue = new DelayQueue(); Delayed element1 = new DelayedElement(); queue.put(element1); Delayed element2 = queue.take(); } } DelayedElement 是我所创建的一个 DelayedElement 接口的实现类，它不在 Java.util.concurrent 包里。你需要自行创建你自己的 Delayed 接口的实现以使用 DelayQueue 类。 链阻塞队列 LinkedBlockingQueue LinkedBlockingQueue 类实现了 BlockingQueue 接口。 LinkedBlockingQueue 内部以一个链式结构(链接节点)对其元素进行存储。如果需要的话，这一链式结构可以选择一个上限。如果没有定义上限，将使用 Integer.MAX_VALUE 作为上限。 LinkedBlockingQueue 内部以 FIFO(先进先出)的顺序对元素进行存储。队列中的头元素在所有元素之中是放入时间最久的那个，而尾元素则是最短的那个。 以下是 LinkedBlockingQueue 的初始化和使用示例代码： BlockingQueue unbounded = new LinkedBlockingQueue();BlockingQueue bounded = new LinkedBlockingQueue(1024); bounded.put(“Value”); String value = bounded.take(); 具有优先级的阻塞队列 PriorityBlockingQueue PriorityBlockingQueue 类实现了 BlockingQueue 接口。 PriorityBlockingQueue 是一个无界的并发队列。它使用了和类 java.util.PriorityQueue 一样的排序规则。你无法向这个队列中插入 null 值。所有插入到 PriorityBlockingQueue 的元素必须实现 java.lang.Comparable 接口。因此该队列中元素的排序就取决于你自己的 Comparable 实现。注意 PriorityBlockingQueue 对于具有相等优先级(compare() == 0)的元素并不强制任何特定行为。 同时注意，如果你从一个 PriorityBlockingQueue 获得一个 Iterator 的话，该 Iterator 并不能保证它对元素的遍历是以优先级为序的。 以下是使用 PriorityBlockingQueue 的示例： BlockingQueue queue = new PriorityBlockingQueue(); //String implements java.lang.Comparable queue.put(&quot;Value&quot;); String value = queue.take(); 同步队列 SynchronousQueue SynchronousQueue 类实现了 BlockingQueue 接口。 SynchronousQueue 是一个特殊的队列，它的内部同时只能够容纳单个元素。如果该队列已有一元素的话，试图向队列中插入一个新元素的线程将会阻塞，直到另一个线程将该元素从队列中抽走。同样，如果该队列为空，试图向队列中抽取一个元素的线程将会阻塞，直到另一个线程向队列中插入了一条新的元素。 据此，把这个类称作一个队列显然是夸大其词了。它更多像是一个汇合点。 阻塞双端队列 BlockingDeque java.util.concurrent 包里的 BlockingDeque 接口表示一个线程安放入和提取实例的双端队列。本小节我将给你演示如何使用 BlockingDeque。BlockingDeque 类是一个双端队列，在不能够插入元素时，它将阻塞住试图插入元素的线程；在不能够抽取元素时，它将阻塞住试图抽取的线程。deque(双端队列) 是 “Double Ended Queue” 的缩写。因此，双端队列是一个你可以从任意一端插入或者抽取元素的队列。 BlockingDeque 的使用 在线程既是一个队列的生产者又是这个队列的消费者的时候可以使用到 BlockingDeque。如果生产者线程需要在队列的两端都可以插入数据，消费者线程需要在队列的两端都可以移除数据，这个时候也可以使用 BlockingDeque。 一个 BlockingDeque – 线程在双端队列的两端都可以插入和提取元素。 一个线程生产元素，并把它们插入到队列的任意一端。如果双端队列已满，插入线程将被阻塞，直到一个移除线程从该队列中移出了一个元素。如果双端队列为空，移除线程将被阻塞，直到一个插入线程向该队列插入了一个新元素。 BlockingDeque 的方法 BlockingDeque 具有 4 组不同的方法用于插入、移除以及对双端队列中的元素进行检查。如果请求的操作不能得到立即执行的话，每个方法的表现也不同。这些方法如下： 四组不同的行为方式解释： 抛异常：如果试图的操作无法立即执行，抛一个异常。特定值：如果试图的操作无法立即执行，返回一个特定的值(常常是 true / false)。阻塞：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行。超时：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功(典型的是 true / false)。 BlockingDeque 继承自 BlockingQueue BlockingDeque 接口继承自 BlockingQueue 接口。 这就意味着你可以像使用一个 BlockingQueue 那样使用 BlockingDeque。如果你这么干的话，各种插入方法将会把新元素添加到双端队列的尾端，而移除方法将会把双端队列的首端的元素移除。正如 BlockingQueue 接口的插入和移除方法一样。 以下是 BlockingDeque 对 BlockingQueue 接口的方法的具体内部实现： BlockingDeque 的实现 既然 BlockingDeque 是一个接口，那么你想要使用它的话就得使用它的众多的实现类的其中一个。java.util.concurrent 包提供了以下 BlockingDeque 接口的实现类： LinkedBlockingDeque BlockingDeque 代码示例 以下是如何使用 BlockingDeque 方法的一个简短代码示例： BlockingDeque deque = new LinkedBlockingDeque(); deque.addFirst(“1”);deque.addLast(“2”); String two = deque.takeLast();String one = deque.takeFirst(); 链阻塞双端队列 LinkedBlockingDeque LinkedBlockingDeque 类实现了 BlockingDeque 接口。 deque(双端队列) 是 “Double Ended Queue” 的缩写。因此，双端队列是一个你可以从任意一端插入或者抽取元素的队列。(译者注：唐僧啊，受不了。)LinkedBlockingDeque 是一个双端队列，在它为空的时候，一个试图从中抽取数据的线程将会阻塞，无论该线程是试图从哪一端抽取数据。以下是 LinkedBlockingDeque 实例化以及使用的示例： BlockingDeque deque = new LinkedBlockingDeque(); deque.addFirst(“1”);deque.addLast(“2”); String two = deque.takeLast();String one = deque.takeFirst(); 并发 Map(映射) ConcurrentMap java.util.concurrent.ConcurrentMap java.util.concurrent.ConcurrentMap 接口表示了一个能够对别人的访问(插入和提取)进行并发处理的 java.util.Map。ConcurrentMap 除了从其父接口 java.util.Map 继承来的方法之外还有一些额外的原子性方法。 ConcurrentMap 的实现 既然 ConcurrentMap 是个接口，你想要使用它的话就得使用它的实现类之一。java.util.concurrent 包具备 ConcurrentMap 接口的以下实现类： ConcurrentHashMap ConcurrentHashMap ConcurrentHashMap 和 java.util.HashTable 类很相似，但 ConcurrentHashMap 能够提供比 HashTable 更好的并发性能。在你从中读取对象的时候 ConcurrentHashMap 并不会把整个 Map 锁住。 此外，在你向其中写入对象的时候，ConcurrentHashMap 也不会锁住整个 Map。它的内部只是把 Map 中正在被写入的部分进行锁定。 另外一个不同点是，在被遍历的时候，即使是 ConcurrentHashMap 被改动，它也不会抛 ConcurrentModificationException。尽管 Iterator 的设计不是为多个线程的同时使用。更多关于 ConcurrentMap 和 ConcurrentHashMap 的细节请参考官方文档。 ConcurrentMap 例子 以下是如何使用 ConcurrentMap 接口的一个例子。 本示例使用了 ConcurrentHashMap 实现类： ConcurrentMap concurrentMap = new ConcurrentHashMap(); concurrentMap.put(“key”, “value”); Object value = concurrentMap.get(“key”); 并发导航映射 ConcurrentNavigableMap java.util.concurrent.ConcurrentNavigableMap 是一个支持并发访问的 java.util.NavigableMap，它还能让它的子 map 具备并发访问的能力。所谓的 “子 map” 指的是诸如 headMap()，subMap()，tailMap() 之类的方法返回的 map。 NavigableMap 中的方法不再赘述，本小节我们来看一下 ConcurrentNavigableMap 添加的方法。 headMap() headMap(T toKey) 方法返回一个包含了小于给定 toKey 的 key 的子 map。如果你对原始 map 里的元素做了改动，这些改动将影响到子 map 中的元素(译者注：map 集合持有的其实只是对象的引用)。以下示例演示了对 headMap() 方法的使用： ConcurrentNavigableMap map = new ConcurrentSkipListMap(); map.put(“1”, “one”);map.put(“2”, “two”);map.put(“3”, “three”); ConcurrentNavigableMap headMap = map.headMap(“2”); headMap 将指向一个只含有键 “1″ 的 ConcurrentNavigableMap，因为只有这一个键小于 “2″。关于这个方法及其重载版本具体是怎么工作的细节请参考 Java 文档。 tailMap() tailMap(T fromKey) 方法返回一个包含了不小于给定 fromKey 的 key 的子 map。 如果你对原始 map 里的元素做了改动，这些改动将影响到子 map 中的元素(译者注：map 集合持有的其实只是对象的引用)。 以下示例演示了对 tailMap() 方法的使用： ConcurrentNavigableMap map = new ConcurrentSkipListMap(); map.put(“1”, “one”);map.put(“2”, “two”);map.put(“3”, “three”); ConcurrentNavigableMap tailMap = map.tailMap(“2”); tailMap 将拥有键 “2″ 和 “3″，因为它们不小于给定键 “2″。关于这个方法及其重载版本具体是怎么工作的细节请参考 Java 文档。 subMap() subMap() 方法返回原始 map 中，键介于 from(包含) 和 to (不包含) 之间的子 map。 示例如下： ConcurrentNavigableMap map = new ConcurrentSkipListMap(); map.put(“1”, “one”);map.put(“2”, “two”);map.put(“3”, “three”); ConcurrentNavigableMap subMap = map.subMap(“2”, “3”); 返回的 submap 只包含键 “2″，因为只有它满足不小于 “2″，比 “3″ 小。 更多方法 ConcurrentNavigableMap 接口还有其他一些方法可供使用，比如： descendingKeySet()descendingMap()navigableKeySet() 关于这些方法更多信息参考官方 Java 文档。 闭锁 CountDownLatch java.util.concurrent.CountDownLatch 是一个并发构造，它允许一个或多个线程等待一系列指定操作的完成。 CountDownLatch 以一个给定的数量初始化。countDown() 每被调用一次，这一数量就减一。通过调用 await() 方法之一，线程可以阻塞等待这一数量到达零。以下是一个简单示例。 Decrementer 三次调用 countDown() 之后，等待中的 Waiter 才会从 await() 调用中释放出来。 CountDownLatch latch = new CountDownLatch(3); Waiter waiter = new Waiter(latch);Decrementer decrementer = new Decrementer(latch); new Thread(waiter) .start();new Thread(decrementer).start(); Thread.sleep(4000); public class Waiter implements Runnable{ CountDownLatch latch = null; public Waiter(CountDownLatch latch) { this.latch = latch; } public void run() { try { latch.await(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;Waiter Released&quot;); } } public class Decrementer implements Runnable { CountDownLatch latch = null; public Decrementer(CountDownLatch latch) { this.latch = latch; } public void run() { try { Thread.sleep(1000); this.latch.countDown(); Thread.sleep(1000); this.latch.countDown(); Thread.sleep(1000); this.latch.countDown(); } catch (InterruptedException e) { e.printStackTrace(); } } } 栅栏 CyclicBarrier java.util.concurrent.CyclicBarrier 类是一种同步机制，它能够对处理一些算法的线程实现同步。换句话讲，它就是一个所有线程必须等待的一个栅栏，直到所有线程都到达这里，然后所有线程才可以继续做其他事情。 图示如下： 两个线程在栅栏旁等待对方。 通过调用 CyclicBarrier 对象的 await() 方法，两个线程可以实现互相等待。一旦 N 个线程在等待 CyclicBarrier 达成，所有线程将被释放掉去继续运行。 创建一个 CyclicBarrier 在创建一个 CyclicBarrier 的时候你需要定义有多少线程在被释放之前等待栅栏。 创建 CyclicBarrier 示例： CyclicBarrier barrier = new CyclicBarrier(2); 等待一个 CyclicBarrier 以下演示了如何让一个线程等待一个 CyclicBarrier： barrier.await(); 当然，你也可以为等待线程设定一个超时时间。等待超过了超时时间之后，即便还没有达成 N 个线程等待 CyclicBarrier 的条件，该线程也会被释放出来。以下是定义超时时间示例： barrier.await(10, TimeUnit.SECONDS); 满足以下任何条件都可以让等待 CyclicBarrier 的线程释放： 最后一个线程也到达 CyclicBarrier(调用 await())当前线程被其他线程打断(其他线程调用了这个线程的 interrupt() 方法)其他等待栅栏的线程被打断其他等待栅栏的线程因超时而被释放外部线程调用了栅栏的 CyclicBarrier.reset() 方法 CyclicBarrier 行动 CyclicBarrier 支持一个栅栏行动，栅栏行动是一个 Runnable 实例，一旦最后等待栅栏的线程抵达，该实例将被执行。你可以在 CyclicBarrier 的构造方法中将 Runnable 栅栏行动传给它： Runnable barrierAction = … ;CyclicBarrier barrier = new CyclicBarrier(2, barrierAction); CyclicBarrier 示例 以下代码演示了如何使用 CyclicBarrier： Runnable barrier1Action = new Runnable() { public void run() { System.out.println(“BarrierAction 1 executed “); }};Runnable barrier2Action = new Runnable() { public void run() { System.out.println(“BarrierAction 2 executed “); }}; CyclicBarrier barrier1 = new CyclicBarrier(2, barrier1Action);CyclicBarrier barrier2 = new CyclicBarrier(2, barrier2Action); CyclicBarrierRunnable barrierRunnable1 = new CyclicBarrierRunnable(barrier1, barrier2); CyclicBarrierRunnable barrierRunnable2 = new CyclicBarrierRunnable(barrier1, barrier2); new Thread(barrierRunnable1).start();new Thread(barrierRunnable2).start(); CyclicBarrierRunnable 类： public class CyclicBarrierRunnable implements Runnable{ CyclicBarrier barrier1 = null; CyclicBarrier barrier2 = null; public CyclicBarrierRunnable( CyclicBarrier barrier1, CyclicBarrier barrier2) { this.barrier1 = barrier1; this.barrier2 = barrier2; } public void run() { try { Thread.sleep(1000); System.out.println(Thread.currentThread().getName() + &quot; waiting at barrier 1&quot;); this.barrier1.await(); Thread.sleep(1000); System.out.println(Thread.currentThread().getName() + &quot; waiting at barrier 2&quot;); this.barrier2.await(); System.out.println(Thread.currentThread().getName() + &quot; done!&quot;); } catch (InterruptedException e) { e.printStackTrace(); } catch (BrokenBarrierException e) { e.printStackTrace(); } } } 以上代码控制台输出如下。注意每个线程写入控制台的时序可能会跟你实际执行不一样。比如有时 Thread-0 先打印，有时 Thread-1 先打印。 Thread-0 waiting at barrier 1Thread-1 waiting at barrier 1BarrierAction 1 executedThread-1 waiting at barrier 2Thread-0 waiting at barrier 2BarrierAction 2 executedThread-0 done!Thread-1 done! 交换机 Exchanger java.util.concurrent.Exchanger 类表示一种两个线程可以进行互相交换对象的会和点。这种机制图示如下： 两个线程通过一个 Exchanger 交换对象。交换对象的动作由 Exchanger 的两个 exchange() 方法的其中一个完成。 以下是一个示例： Exchanger exchanger = new Exchanger(); ExchangerRunnable exchangerRunnable1 = new ExchangerRunnable(exchanger, “A”); ExchangerRunnable exchangerRunnable2 = new ExchangerRunnable(exchanger, “B”); new Thread(exchangerRunnable1).start();new Thread(exchangerRunnable2).start(); ExchangerRunnable 代码： public class ExchangerRunnable implements Runnable{ Exchanger exchanger = null; Object object = null; public ExchangerRunnable(Exchanger exchanger, Object object) { this.exchanger = exchanger; this.object = object; } public void run() { try { Object previous = this.object; this.object = this.exchanger.exchange(this.object); System.out.println( Thread.currentThread().getName() + &quot; exchanged &quot; + previous + &quot; for &quot; + this.object ); } catch (InterruptedException e) { e.printStackTrace(); } } } 以上程序输出：Thread-0 exchanged A for BThread-1 exchanged B for A 信号量 Semaphore java.util.concurrent.Semaphore 类是一个计数信号量。这就意味着它具备两个主要方法： acquire()release() 计数信号量由一个指定数量的 “许可” 初始化。每调用一次 acquire()，一个许可会被调用线程取走。每调用一次 release()，一个许可会被返还给信号量。因此，在没有任何 release() 调用时，最多有 N 个线程能够通过 acquire() 方法，N 是该信号量初始化时的许可的指定数量。这些许可只是一个简单的计数器。这里没啥奇特的地方。 Semaphore 用法 信号量主要有两种用途： 保护一个重要(代码)部分防止一次超过 N 个线程进入。在两个线程之间发送信号。 保护重要部分 如果你将信号量用于保护一个重要部分，试图进入这一部分的代码通常会首先尝试获得一个许可，然后才能进入重要部分(代码块)，执行完之后，再把许可释放掉。 比如这样： Semaphore semaphore = new Semaphore(1); //critical sectionsemaphore.acquire(); … semaphore.release(); 在线程之间发送信号 如果你将一个信号量用于在两个线程之间传送信号，通常你应该用一个线程调用 acquire() 方法，而另一个线程调用 release() 方法。如果没有可用的许可，acquire() 调用将会阻塞，直到一个许可被另一个线程释放出来。同理，如果无法往信号量释放更多许可时，一个 release() 调用也会阻塞。 通过这个可以对多个线程进行协调。比如，如果线程 1 将一个对象插入到了一个共享列表(list)之后之后调用了 acquire()，而线程 2 则在从该列表中获取一个对象之前调用了 release()，这时你其实已经创建了一个阻塞队列。信号量中可用的许可的数量也就等同于该阻塞队列能够持有的元素个数。 公平 没有办法保证线程能够公平地可从信号量中获得许可。也就是说，无法担保掉第一个调用 acquire() 的线程会是第一个获得一个许可的线程。如果第一个线程在等待一个许可时发生阻塞，而第二个线程前来索要一个许可的时候刚好有一个许可被释放出来，那么它就可能会在第一个线程之前获得许可。如果你想要强制公平，Semaphore 类有一个具有一个布尔类型的参数的构造子，通过这个参数以告知 Semaphore 是否要强制公平。强制公平会影响到并发性能，所以除非你确实需要它否则不要启用它。 以下是如何在公平模式创建一个 Semaphore 的示例： Semaphore semaphore = new Semaphore(1, true); 更多方法 java.util.concurrent.Semaphore 类还有很多方法，比如： availablePermits()acquireUninterruptibly()drainPermits()hasQueuedThreads()getQueuedThreads()tryAcquire()等等 这些方法的细节请参考 Java 文档。 @本知识本人借阅了ImportNew]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[myGitOneDay]]></title>
    <url>%2F2017%2F08%2F04%2FmyGitOneDay%2F</url>
    <content type="text"></content>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM垃圾回收算法及回收器]]></title>
    <url>%2F2016%2F09%2F01%2FJVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E5%8F%8A%E5%9B%9E%E6%94%B6%E5%99%A8%2F</url>
    <content type="text"><![CDATA[本文主要讲述JVM中几种常见的垃圾回收算法和相关的垃圾回收器，以及常见的和GC相关的性能调优参数。 GC Roots 我们先来了解一下在Java中是如何判断一个对象的生死的，有些语言比如Python是采用引用计数来统计的，但是这种做法可能会遇见循环引用的问题，在Java以及C#等语言中是采用GC Roots来解决这个问题。如果一个对象和GC Roots之间没有链接，那么这个对象也可以被视作是一个可回收的对象。 Java中可以被作为GC Roots中的对象有： 虚拟机栈中的引用的对象。方法区中的类静态属性引用的对象。方法区中的常量引用的对象。本地方法栈（jni）即一般说的Native的引用对象。 垃圾回收算法 标记清除 标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。在标记阶段首先通过根节点，标记所有从根节点开始的对象，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。标记清除算法带来的一个问题是会存在大量的空间碎片，因为回收后的空间是不连续的，这样给大对象分配内存的时候可能会提前触发full gc。 复制算法 将现有的内存空间分为两快，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。 现在的商业虚拟机都采用这种收集算法来回收新生代，IBM研究表明新生代中的对象98%是朝夕生死的，所以并不需要按照1:1的比例划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一个Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1(可以通过-SurvivorRattio来配置)，也就是每次新生代中可用内存空间为整个新生代容量的90%，只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保。 标记整理 复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活的对象较多，复制的成本也将很高。标记-压缩算法是一种老年代的回收算法，它在标记-清除算法的基础上做了一些优化。首先也需要从根节点开始对所有可达对象做一次标记，但之后，它并不简单地清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。 增量算法 增量算法的基本思想是，如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。 垃圾回收器 Serial收集器 Serial收集器是最古老的收集器，它的缺点是当Serial收集器想进行垃圾回收的时候，必须暂停用户的所有进程，即stop the world。到现在为止，它依然是虚拟机运行在client模式下的默认新生代收集器，与其他收集器相比，对于限定在单个CPU的运行环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾回收自然可以获得最高的单线程收集效率。 Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用”标记－整理“算法。这个收集器的主要意义也是被Client模式下的虚拟机使用。在Server模式下，它主要还有两大用途：一个是在JDK1.5及以前的版本中与Parallel Scanvenge收集器搭配使用，另外一个就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure的时候使用。 通过指定-UseSerialGC参数，使用Serial + Serial Old的串行收集器组合进行内存回收。 ParNew收集器 ParNew收集器是Serial收集器新生代的多线程实现，注意在进行垃圾回收的时候依然会stop the world，只是相比较Serial收集器而言它会运行多条进程进行垃圾回收。 ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百的保证能超越Serial收集器。当然，随着可以使用的CPU的数量增加，它对于GC时系统资源的利用还是很有好处的。它默认开启的收集线程数与CPU的数量相同，在CPU非常多（譬如32个，现在CPU动辄4核加超线程，服务器超过32个逻辑CPU的情况越来越多了）的环境下，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。 -UseParNewGC: 打开此开关后，使用ParNew + Serial Old的收集器组合进行内存回收，这样新生代使用并行收集器，老年代使用串行收集器。 Parallel Scavenge收集器 Parallel是采用复制算法的多线程新生代垃圾回收器，似乎和ParNew收集器有很多的相似的地方。但是Parallel Scanvenge收集器的一个特点是它所关注的目标是吞吐量(Throughput)。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)。停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能够提升用户的体验；而高吞吐量则可以最高效率地利用CPU时间，尽快地完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。 Parallel Old收集器是Parallel Scavenge收集器的老年代版本，采用多线程和”标记－整理”算法。这个收集器是在jdk1.6中才开始提供的，在此之前，新生代的Parallel Scavenge收集器一直处于比较尴尬的状态。原因是如果新生代Parallel Scavenge收集器，那么老年代除了Serial Old(PS MarkSweep)收集器外别无选择。由于单线程的老年代Serial Old收集器在服务端应用性能上的”拖累“，即使使用了Parallel Scavenge收集器也未必能在整体应用上获得吞吐量最大化的效果，又因为老年代收集中无法充分利用服务器多CPU的处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定有ParNew加CMS的组合”给力“。直到Parallel Old收集器出现后，”吞吐量优先“收集器终于有了比较名副其实的应用祝贺，在注重吞吐量及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。 -UseParallelGC: 虚拟机运行在Server模式下的默认值，打开此开关后，使用Parallel Scavenge + Serial Old的收集器组合进行内存回收。-UseParallelOldGC: 打开此开关后，使用Parallel Scavenge + Parallel Old的收集器组合进行垃圾回收 CMS收集器 CMS(Concurrent Mark Swep)收集器是一个比较重要的回收器，现在应用非常广泛，我们重点来看一下，CMS一种获取最短回收停顿时间为目标的收集器，这使得它很适合用于和用户交互的业务。从名字(Mark Swep)就可以看出，CMS收集器是基于标记清除算法实现的。它的收集过程分为四个步骤： 初始标记(initial mark)并发标记(concurrent mark)重新标记(remark)并发清除(concurrent sweep) 注意初始标记和重新标记还是会stop the world，但是在耗费时间更长的并发标记和并发清除两个阶段都可以和用户进程同时工作。 不过由于CMS收集器是基于标记清除算法实现的，会导致有大量的空间碎片产生，在为大对象分配内存的时候，往往会出现老年代还有很大的空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前开启一次Full GC。为了解决这个问题，CMS收集器默认提供了一个-XX:+UseCMSCompactAtFullCollection收集开关参数（默认就是开启的)，用于在CMS收集器进行FullGC完开启内存碎片的合并整理过程，内存整理的过程是无法并发的，这样内存碎片问题倒是没有了，不过停顿时间不得不变长。虚拟机设计者还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction参数用于设置执行多少次不压缩的FULL GC后跟着来一次带压缩的（默认值为0，表示每次进入Full GC时都进行碎片整理）。 不幸的是，它作为老年代的收集器，却无法与jdk1.4中已经存在的新生代收集器Parallel Scavenge配合工作，所以在jdk1.5中使用cms来收集老年代的时候，新生代只能选择ParNew或Serial收集器中的一个。ParNew收集器是使用-XX:+UseConcMarkSweepGC选项启用CMS收集器之后的默认新生代收集器，也可以使用-XX:+UseParNewGC选项来强制指定它。 由于CMS收集器现在比较常用，下面我们再额外了解一下CMS算法的几个常用参数： UseCMSInitatingOccupancyOnly：表示只在到达阈值的时候，才进行 CMS 回收。为了减少第二次暂停的时间，通过-XX:+CMSParallelRemarkEnabled开启并行remark。如果ramark时间还是过长的话，可以开启-XX:+CMSScavengeBeforeRemark选项，强制remark之前开启一次minor gc，减少remark的暂停时间，但是在remark之后也立即开始一次minor gc。CMS默认启动的回收线程数目是(ParallelGCThreads + 3)/4，如果你需要明确设定，可以通过-XX:+ParallelCMSThreads来设定，其中-XX:+ParallelGCThreads代表的年轻代的并发收集线程数目。CMSClassUnloadingEnabled： 允许对类元数据进行回收。CMSInitatingPermOccupancyFraction：当永久区占用率达到这一百分比后，启动 CMS 回收 (前提是-XX:+CMSClassUnloadingEnabled 激活了)。CMSIncrementalMode：使用增量模式，比较适合单 CPU。UseCMSCompactAtFullCollection参数可以使 CMS 在垃圾收集完成后，进行一次内存碎片整理。内存碎片的整理并不是并发进行的。UseFullGCsBeforeCompaction：设定进行多少次 CMS 垃圾回收后，进行一次内存压缩。 一些建议 对于Native Memory: 使用了NIO或者NIO框架（Mina/Netty）使用了DirectByteBuffer分配字节缓冲区使用了MappedByteBuffer做内存映射 由于Native Memory只能通过FullGC回收，所以除非你非常清楚这时真的有必要，否则不要轻易调用System.gc()。 另外为了防止某些框架中的System.gc调用（例如NIO框架、Java RMI），建议在启动参数中加上-XX:+DisableExplicitGC来禁用显式GC。这个参数有个巨大的坑，如果你禁用了System.gc()，那么上面的3种场景下的内存就无法回收，可能造成OOM，如果你使用了CMS GC，那么可以用这个参数替代：-XX:+ExplicitGCInvokesConcurrent。 此外除了CMS的GC，其实其他针对old gen的回收器都会在对old gen回收的同时回收young gen。 G1收集器 G1收集器是一款面向服务端应用的垃圾收集器。HotSpot团队赋予它的使命是在未来替换掉JDK1.5中发布的CMS收集器。与其他GC收集器相比，G1具备如下特点： 并行与并发：G1能更充分的利用CPU，多核环境下的硬件优势来缩短stop the world的停顿时间。分代收集：和其他收集器一样，分代的概念在G1中依然存在，不过G1不需要其他的垃圾回收器的配合就可以独自管理整个GC堆。空间整合：G1收集器有利于程序长时间运行，分配大对象时不会无法得到连续的空间而提前触发一次GC。可预测的非停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。 在使用G1收集器时，Java堆的内存布局和其他收集器有很大的差别，它将这个Java堆分为多个大小相等的独立区域，虽然还保留新生代和老年代的概念，但是新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。 虽然G1看起来有很多优点，实际上CMS还是主流。 与GC相关的常用参数 除了上面提及的一些参数，下面补充一些和GC相关的常用参数： -Xmx: 设置堆内存的最大值。-Xms: 设置堆内存的初始值。-Xmn: 设置新生代的大小。-Xss: 设置栈的大小。-PretenureSizeThreshold: 直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接在老年代分配。-MaxTenuringThrehold: 晋升到老年代的对象年龄。每个对象在坚持过一次Minor GC之后，年龄就会加1，当超过这个参数值时就进入老年代。-UseAdaptiveSizePolicy: 在这种模式下，新生代的大小、eden 和 survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。在手工调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量 (GCTimeRatio) 和停顿时间 (MaxGCPauseMills)，让虚拟机自己完成调优工作。-SurvivorRattio: 新生代Eden区域与Survivor区域的容量比值，默认为8，代表Eden: Suvivor= 8: 1。-XX:ParallelGCThreads：设置用于垃圾回收的线程数。通常情况下可以和 CPU 数量相等。但在 CPU 数量比较多的情况下，设置相对较小的数值也是合理的。-XX:MaxGCPauseMills：设置最大垃圾收集停顿时间。它的值是一个大于 0 的整数。收集器在工作时，会调整 Java 堆大小或者其他一些参数，尽可能地把停顿时间控制在 MaxGCPauseMills 以内。-XX:GCTimeRatio:设置吞吐量大小，它的值是一个 0-100 之间的整数。假设 GCTimeRatio 的值为 n，那么系统将花费不超过 1/(1+n) 的时间用于垃圾收集。]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代理模式]]></title>
    <url>%2F2016%2F08%2F25%2F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[说说 JAVA 代理模式 本文内容借阅来自ImportNew中 事例 小张是一个普普通通的码农，每天勤勤恳恳地码代码。某天中午小张刚要去吃饭，一个电话打到了他的手机上。“是XX公司的小张吗？我是YY公司的王AA”。“哦，是王总啊，有什么事情吗？”。沟通过后，小张弄明白了,原来客户有个需求，刚好负责这方面开发的是小张，客户就直接找到了他。不过小张却没有答应客户的请求，而是让客户找产品经理小李沟通。 是小张着急去吃面而甩锅吗？并不是，只是为了使故事可以套到代理模式上。我们先看一下代理模式的定义： * 为其他对象提供一种代理，以控制对这个对象的访问。(Provide a surrogate or placeholder for another object to control access to it) 对照定义，码农小张可以映射为其他对象，产品经理小李为小张的代理。我们通过JAVA代码，表述上面事例。 静态代理 1.抽象角色 基于面向对象的思想，首先定义一个码农接口,它有一个实现用户需求的方法。 public interface ICoder { public void implDemands(String demandName); } 2.真实角色 我们假设小张是JAVA程序员，定义一个JAVA码农类，他通过JAA语言实现需求。 public class JavaCoder implements ICoder{ private String name; public JavaCoder(String name){ this.name = name; } @Override public void implDemands(String demandName) { System.out.println(name + &quot; implemented demand:&quot; + demandName + &quot; in JAVA!&quot;); } } 3.代理角色 委屈一下产品经理，将其命名为码农代理类，同时让他实现ICoder接口。 public class CoderProxy implements ICoder{ private ICoder coder; public CoderProxy(ICoder coder){ this.coder = coder; } @Override public void implDemands(String demandName) { coder.implDemands(demandName); } } 上面一个接口，两个类，就实现了代理模式。Are you kidding me？这么简单？是的，就是这么简单。 我们通过一个场景类，模拟用户找产品经理增加需求。 public class Customer { public static void main(String args[]){ //定义一个java码农 ICoder coder = new JavaCoder(&quot;Zhang&quot;); //定义一个产品经理 ICoder proxy = new CoderProxy(coder); //让产品经理实现一个需求 proxy.implDemands(); } } 运行程序，结果如下： Zhang implemented demand:Add user manageMent in JAVA! 产品经理充当了程序员的代理，客户把需求告诉产品经理，并不需要和程序员接触。看到这里，有些机智的程序员发现了问题。你看，产品经理就把客户的需求转达了一下，怪不得我看产品经理这么不爽。 产品经理当然不只是转达用户需求，他还有很多事情可以做。比如，该项目决定不接受新增功能的需求了，对修CoderProxy类做一些修改： public class CoderProxy implements ICoder{ private ICoder coder; public CoderProxy(ICoder coder){ this.coder = coder; } @Override public void implDemands(String demandName) { if(demandName.startsWith(&quot;Add&quot;)){ System.out.println(&quot;No longer receive &apos;Add&apos; demand&quot;); return; } coder.implDemands(demandName); } } 这样，当客户再有增加功能的需求时，产品经理就直接回绝了，程序员无需再对这部分需求做过滤。 总结 我们对上面的事例做一个简单的抽象： 代理模式包含如下角色： Subject:抽象主题角色。可以是接口，也可以是抽象类。 RealSubject:真实主题角色。业务逻辑的具体执行者。 ProxySubject:代理主题角色。内部含有RealSubject的引用,负责对真实角色的调用，并在真实主题角色处理前后做预处理和善后工作。 代理模式优点： 职责清晰 真实角色只需关注业务逻辑的实现，非业务逻辑部分，后期通过代理类完成即可。 高扩展性 不管真实角色如何变化，由于接口是固定的，代理类无需做任何改动。 动态代理 前面讲的主要是静态代理。那么什么是动态代理呢？ 假设有这么一个需求，在方法执行前和执行完成后，打印系统时间。这很简单嘛，非业务逻辑，只要在代理类调用真实角色的方法前、后输出时间就可以了。像上例，只有一个implDemands方法，这样实现没有问题。但如果真实角色有10个方法，那么我们要写10遍完全相同的代码。有点追求的码农，肯定会对这种方法感到非常不爽。有些机智的小伙伴可能想到了用AOP解决这个问题。非常正确。莫非AOP和动态代理有什么关系？没错！AOP用的恰恰是动态代理。 代理类在程序运行时创建的代理方式被称为动态代理。也就是说，代理类并不需要在Java代码中定义，而是在运行时动态生成的。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类的函数。对于上例打印时间的需求，通过使用动态代理，我们可以做一个“统一指示”，对所有代理类的方法进行统一处理，而不用逐一修改每个方法。下面我们来具体介绍下如何使用动态代理方式实现我们的需求。 与静态代理相比，抽象角色、真实角色都没有变化。变化的只有代理类。因此，抽象角色、真实角色，参考ICoder和JavaCodr。 在使用动态代理时，我们需要定义一个位于代理类与委托类之间的中介类，也叫动态代理类，这个类被要求实现InvocationHandler接口： public class CoderDynamicProxy implements InvocationHandler{ //被代理的实例 private ICoder coder; public CoderDynamicProxy(ICoder _coder){ this.coder = _coder; } //调用被代理的方法 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(System.currentTimeMillis()); Object result = method.invoke(coder, args); System.out.println(System.currentTimeMillis()); return result; } } 当我们调用代理类对象的方法时，这个“调用”会转送到中介类的invoke方法中，参数method标识了我们具体调用的是代理类的哪个方法，args为这个方法的参数。 我们通过一个场景类，模拟用户找产品经理更改需求。 public class DynamicClient { public static void main(String args[]){ //要代理的真实对象 ICoder coder = new JavaCoder(&quot;Zhang&quot;); //创建中介类实例 InvocationHandler handler = new CoderDynamicProxy(coder); //获取类加载器 ClassLoader cl = coder.getClass().getClassLoader(); //动态产生一个代理类 ICoder proxy = (ICoder) Proxy.newProxyInstance(cl, coder.getClass().getInterfaces(), handler); //通过代理类，执行doSomething方法； proxy.implDemands(&quot;Modify user management&quot;); } } 执行结果如下： 1501728574978 Zhang implemented demand:Modify user management in JAVA! 1501728574979 通过上述代码，就实现了，在执行委托类的所有方法前、后打印时间。还是那个熟悉的小张，但我们并没有创建代理类，也没有时间ICoder接口。这就是动态代理。 总结 总结一下，一个典型的动态代理可分为以下四个步骤： 创建抽象角色 创建真实角色 通过实现InvocationHandler接口创建中介类 通过场景类，动态生成代理类 如果只是想用动态代理，看到这里就够了。但如果想知道为什么通过proxy对象，就能够执行中介类的invoke方法，以及生成的proxy对象是什么样的，可以继续往下看。 源码分析(JDK7) 看到这里的小伙伴，都是有追求的程序员。上面的场景类中，通过 //动态产生一个代理类 ICoder proxy = (ICoder) Proxy.newProxyInstance(cl, coder.getClass().getInterfaces(), handler); 动态产生了一个代理类。那么这个代理类是如何产生的呢？我们通过代码一窥究竟。 Proxy类的newProxyInstance方法，主要业务逻辑如下： //生成代理类class，并加载到jvm中 Class&lt;?&gt; cl = getProxyClass0(loader, interfaces); //获取代理类参数为InvocationHandler的构造函数 final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); //生成代理类，并返回 return newInstance(cons, ih); 上面代码做了三件事： 根据传入的参数interfaces动态生成一个类，它实现interfaces中的接口，该例中即ICoder接口的implDemands方法。假设动态生成的类为$Proxy0。 通过传入的classloder,将刚生成的$Proxy0类加载到jvm中。 利用中介类，调用$Proxy0的$Proxy0(InvocationHandler)构造函数，创建$Proxy0类的实例，其InvocationHandler属性，为我们创建的中介类。 上面的核心，就在于getProxyClass0方法： private static Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) { if (interfaces.length &gt; 65535) { throw new IllegalArgumentException(&quot;interface limit exceeded&quot;); } // If the proxy class defined by the given loader implementing // the given interfaces exists, this will simply return the cached copy; // otherwise, it will create the proxy class via the ProxyClassFactory return proxyClassCache.get(loader, interfaces); } 在Proxy类中有个属性proxyClassCache，这是一个WeakCache类型的静态变量。它指示了类加载器和代理类之间的映射。所以proxyClassCache的get方法用于根据类加载器来获取Proxy类，如果已经存在则直接从cache中返回，如果没有则创建一个映射并更新cache表。 我们跟一下代理类的创建流程： 调用Factory类的get方法，而它又调用了ProxyClassFactory类的apply方法，最终找到下面一行代码： //Generate the specified proxy class. byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces); 就是它，生成了代理类。 查看动态生成的代理类 通过上面的分析，我们已经知道Proxy类动态创建代理类的流程。那创建出来的代理类到底是什么样子的呢？我们可以通过下面的代码，手动生成： public class CodeUtil { public static void main(String[] args) throws IOException { byte[] classFile = ProxyGenerator.generateProxyClass(&quot;TestProxyGen&quot;, JavaCoder.class.getInterfaces()); File file = new File(&quot;D:/aaa/TestProxyGen.class&quot;); FileOutputStream fos = new FileOutputStream(file); fos.write(classFile); fos.flush(); fos.close(); } } 通过反编译工具查看生成的class文件: import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import java.lang.reflect.UndeclaredThrowableException; import model.proxy.ICoder; public final class TestProxyGen extends Proxy implements ICoder { private static Method m1; private static Method m0; private static Method m3; private static Method m2; public TestProxyGen(InvocationHandler paramInvocationHandler) throws { super(paramInvocationHandler); } public final boolean equals(Object paramObject) throws { try { return ((Boolean)this.h.invoke(this, m1, new Object[] { paramObject })).booleanValue(); } catch (RuntimeException localRuntimeException) { throw localRuntimeException; } catch (Throwable localThrowable) { } throw new UndeclaredThrowableException(localThrowable); } public final int hashCode() throws { try { return ((Integer)this.h.invoke(this, m0, null)).intValue(); } catch (RuntimeException localRuntimeException) { throw localRuntimeException; } catch (Throwable localThrowable) { } throw new UndeclaredThrowableException(localThrowable); } public final void implDemands(String paramString) throws { try { this.h.invoke(this, m3, new Object[] { paramString }); return; } catch (RuntimeException localRuntimeException) { throw localRuntimeException; } catch (Throwable localThrowable) { } throw new UndeclaredThrowableException(localThrowable); } public final String toString() throws { try { return (String)this.h.invoke(this, m2, null); } catch (RuntimeException localRuntimeException) { throw localRuntimeException; } catch (Throwable localThrowable) { } throw new UndeclaredThrowableException(localThrowable); } static { try { m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[] { Class.forName(&quot;java.lang.Object&quot;) }); m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]); m3 = Class.forName(&quot;model.proxy.ICoder&quot;).getMethod(&quot;implDemands&quot;, new Class[] { Class.forName(&quot;java.lang.String&quot;) }); m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]); return; } catch (NoSuchMethodException localNoSuchMethodException) { throw new NoSuchMethodError(localNoSuchMethodException.getMessage()); } catch (ClassNotFoundException localClassNotFoundException) { } throw new NoClassDefFoundError(localClassNotFoundException.getMessage()); } } 这样，我们就理解，为什么调用代理类的implDemands方法，回去执行中介类的invoke方法了。 看完本文有收获？请转发分享给更多人]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊java8时间与日期]]></title>
    <url>%2F2016%2F08%2F22%2Fjava8%E6%97%B6%E9%97%B4%E4%B8%8E%E6%97%A5%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[相信大家都有这样感觉，Java操作日期和时间的时候，会有一些麻烦。你也许会通过System.currentTimeMillis() 来返回1970年1月1日到今天的毫秒数。或者使用Date类来操作日期；当遇到加减月份、天数的时候 你又需要用到Calendar类；当需要格式化日期的时候需要使用java.text.DateFormat类。所以说在Java中操作日期不是很方便，以至于很多开发者不得不使用第三方库。 JAVA8以的API前存在的问题： 线程安全: Date和Calendar不是线程安全的，你需要编写额外的代码处理线程安全问题 API设计和易用性: 由于Date和Calendar的设计不当你无法完成日常的日期操作 ZonedDate和Time: 你必须编写额外的逻辑处理时区和那些旧的逻辑 好在JSR 310规范中为Java8添加了新的API， 在java.time包中，新的API纠正了过去的缺陷， 新的日期API ZoneId: 时区ID，用来确定Instant和LocalDateTime互相转换的规则 Instant: 用来表示时间线上的一个点 LocalDate: 表示没有时区的日期, LocalDate是不可变并且线程安全的 LocalTime: 表示没有时区的时间, LocalTime是不可变并且线程安全的 LocalDateTime: 表示没有时区的日期时间, LocalDateTime是不可变并且线程安全的 Clock: 用于访问当前时刻、日期、时间，用到时区 Duration: 用秒和纳秒表示时间的数量 最常用的就是LocalDate、LocalTime、LocalDateTime了，从它们的名字就可以看出是操作日期 和时间的。这些类是主要用于当时区不需要显式地指定的上下文。在本章节中我们将讨论最常用的api。 LocalDate LocalDate代表一个IOS格式(yyyy-MM-dd)的日期，可以存储 生日、纪念日等日期。 获取当前的日期： LocalDate localDate = LocalDate.now(); System.out.println(“localDate: “ + localDate); localDate: 2017-07-20 LocalDate可以指定特定的日期，调用of或parse方法返回该实例： LocalDate.of(2017, 07, 20); LocalDate.parse(“2017-07-20”); 当然它还有一些其他方法，我们一起来看看： 为今天添加一天，也就是获取明天 LocalDate tomorrow = LocalDate.now().plusDays(1); 从今天减去一个月 LocalDate prevMonth = LocalDate.now().minus(1, ChronoUnit.MONTHS); 下面写两个例子，分别解析日期 2017-07-20，获取每周中的星期和每月中的日： DayOfWeek thursday = LocalDate.parse(“2017-07-20”).getDayOfWeek(); System.out.println(“周四: “ + thursday); int twenty = LocalDate.parse(“2017-07-20”).getDayOfMonth(); System.out.println(“twenty: “ + twenty); 试试今年是不是闰年: boolean leapYear = LocalDate.now().isLeapYear(); System.out.println(“是否闰年: “ + leapYear); 判断是否在日期之前或之后: boolean notBefore = LocalDate.parse(“2017-07-20”) .isBefore(LocalDate.parse(&quot;2017-07-22&quot;)); System.out.println(“notBefore: “ + notBefore); boolean isAfter = LocalDate.parse(“2017-07-20”).isAfter(LocalDate.parse(“2017-07-22”)); System.out.println(“isAfter: “ + isAfter); 获取这个月的第一天: LocalDate firstDayOfMonth = LocalDate.parse(“2017-07-20”) .with(TemporalAdjusters.firstDayOfMonth()); System.out.println(“这个月的第一天: “ + firstDayOfMonth); firstDayOfMonth = firstDayOfMonth.withDayOfMonth(1); System.out.println(“这个月的第一天: “ + firstDayOfMonth); 判断今天是否是我的生日，例如我的生日是 2009-07-20 LocalDate birthday = LocalDate.of(2009, 07, 20); MonthDay birthdayMd = MonthDay.of(birthday.getMonth(), birthday.getDayOfMonth()); MonthDay today = MonthDay.from(LocalDate.now()); System.out.println(“今天是否是我的生日: “ + today.equals(birthdayMd)); LocalTime LocalTime表示一个时间，而不是日期，下面介绍一下它的使用方法。 获取现在的时间，输出15:01:22.144 LocalTime now = LocalTime.now(); System.out.println(“现在的时间: “ + now); 将一个字符串时间解析为LocalTime，输出15:02 LocalTime nowTime = LocalTime.parse(“15:02”); System.out.println(“时间是: “ + nowTime); 使用静态方法of创建一个时间 LocalTime nowTime = LocalTime.of(15, 02); System.out.println(“时间是: “ + nowTime); 使用解析字符串的方式并添加一小时，输出16:02 LocalTime nextHour = LocalTime.parse(“15:02”).plus(1, ChronoUnit.HOURS); System.out.println(“下一个小时: “ + nextHour); 获取时间的小时、分钟 int hour = LocalTime.parse(“15:02”).getHour(); System.out.println(“小时: “ + hour); int minute = LocalTime.parse(“15:02”).getMinute(); System.out.println(“分钟: “ + minute); 我们也可以通过之前类似的API检查一个时间是否在另一个时间之前、之后 boolean isBefore = LocalTime.parse(“15:02”).isBefore(LocalTime.parse(“16:02”)); boolean isAfter = LocalTime.parse(“15:02”).isAfter(LocalTime.parse(“16:02”)); System.out.println(“isBefore: “ + isBefore); System.out.println(“isAfter: “ + isAfter); 输出 isBefore: true, isAfter: false。 在LocalTime类中也将每天的开始和结束作为常量供我们使用: System.out.println(LocalTime.MAX); System.out.println(LocalTime.MIN); 输出: 23:59:59.999999999 00:00 LocalTime就这些了，下面我们来了解一下LocalDateTime LocalDateTime LocalDateTime是用来表示日期和时间的，这是一个最常用的类之一。 获取当前的日期和时间: LocalDateTime now = LocalDateTime.now(); System.out.println(“现在: “ + now); 输出 现在: 2017-07-20T15:17:19.926 下面使用静态方法和字符串的方式分别创建LocalDateTime对象 LocalDateTime.of(2017, Month.JULY, 20, 15, 18); LocalDateTime.parse(“2017-07-20T15:18:00”); `` 同时LocalDateTime也提供了相关API来对日期和时间进行增减操作: ```java LocalDateTime tomorrow = now.plusDays(1); System.out.println(“明天的这个时间: “ + tomorrow); LocalDateTime minusTowHour = now.minusHours(2); System.out.println(“两小时前: “ + minusTowHour); 这个类也提供一系列的get方法来获取特定单位: Month month = now.getMonth(); System.out.println(“当前月份: “ + month); 日期格式化 在日常开发中我们用到最多的也许就是日期、时间的格式化了，那在Java8种该如何操作呢？ LocalDateTime now = LocalDateTime.now(); DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(“yyyy-MM-dd HH:mm:ss”); System.out.println(“默认格式化: “ + now); System.out.println(“自定义格式化: “ + now.format(dateTimeFormatter)); LocalDateTime localDateTime = LocalDateTime.parse(“2017-07-20 15:27:44”, dateTimeFormatter); System.out.println(“字符串转LocalDateTime: “ + localDateTime); 也可以使用DateTimeFormatter的format方法将日期、时间格式化为字符串 DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(“yyyy-MM-dd”); String dateString = dateTimeFormatter.format(LocalDate.now()); System.out.println(“日期转字符串: “ + dateString); 日期周期 Period类用于修改给定日期或获得的两个日期之间的区别。 给初始化的日期添加5天: LocalDate initialDate = LocalDate.parse(“2017-07-20”); LocalDate finalDate = initialDate.plus(Period.ofDays(5)); System.out.println(“初始化日期: “ + initialDate); System.out.println(“加日期之后: “ + finalDate); 周期API中提供给我们可以比较两个日期的差别，像下面这样获取差距天数: long between = ChronoUnit.DAYS.between(initialDate, finalDate); System.out.println(“差距天数: “ + between); 上面的代码会返回5，当然你想获取两个日期相差多少小时也是简单的。 与遗留代码转换 在之前的代码中你可能出现了大量的Date类，如何将它转换为Java8种的时间类呢？ Date和Instant互相转换 Date date = Date.from(Instant.now()); Instant instant = date.toInstant(); Date转换为LocalDateTime LocalDateTime localDateTime = LocalDateTime.from(new Date()); System.out.println(localDateTime); LocalDateTime转Date Date date = Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant()); LocalDate转Date Date date = Date.from(LocalDate.now().atStartOfDay().atZone(ZoneId.systemDefault()).toInstant]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反射实践]]></title>
    <url>%2F2016%2F07%2F01%2FJava%E5%8F%8D%E5%B0%84%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[Java 反射机制应用实践 Java反射机制是一个非常强大的功能，在很多大型项目比如Spring, Mybatis中都可以看见反射的身影。通过反射机制我们可以在运行期间获取对象的类型信息，利用这一特性我们可以实现工厂模式和代理模式等设计模式，同时也可以解决Java泛型擦除等令人苦恼的问题。本文我们就从实际应用的角度出发，来应用一下Java的反射机制。 反射基础 p.s: 本文需要读者对反射机制的API有一定程度的了解，如果之前没有接触过的话，建议先看一下官方文档的Quick Start。 在应用反射机制之前，首先我们先来看一下如何获取一个对象对应的反射类Class，在Java中我们有三种方法可以获取一个对象的反射类。 通过getClass方法 在Java中，每一个Object都有一个getClass()方法，通过getClass方法我们可以获取到这个对象对应的反射类： String s = “http://www.ziwenxie.site“;Class&lt;?&gt; c = s.getClass(); 通过forName方法 我们也可以调用Class类的静态方法forName()： Class&lt;?&gt; c = Class.forName(“java.lang.String”); 使用.class 或者我们也可以直接使用.class： Class&lt;?&gt; c = String.class; 获取类型信息 在文章开头我们就提到反射的一大好处就是可以允许我们在运行期间获取对象的类型信息，下面我们通过一个例子来具体看一下。 首先我们在typeinfo.interfacea包下面新建一个接口A： package typeinfo.interfacea;public interface A { void f(); } 接着我们在typeinfo.packageaccess包下面新建一个类C，类C实现了接口A，并且我们还另外创建了几个用于测试的方法，注意下面几个方法的权限都是不同的。 package typeinfo.packageaccess;import typeinfo.interfacea.A;class C implements A { public void f() { System.out.println(“public C.f()”); } public void g() { System.out.println(“public C.g()”); } protected void v () { System.out.println(“protected C.v()”); } void u() { System.out.println(“package C.u()”); } private void w() { System.out.println(“private C.w()”); }}public class HiddenC { public static A makeA() { return new C(); }} 在callHiddenMethod()方法中我们用到了几个新的API，其中getDeclaredMethod()根据方法名用于获取Class类指代对象自己声明的某个方法，然后我们通过调用invoke()方法就可以触发对象的相关方法： package typeinfo;import typeinfo.interfacea.A;import typeinfo.packageaccess.HiddenC;import java.lang.reflect.Method;public class HiddenImplementation { public static void main(String[] args) throws Exception { A a = HiddenC.makeA(); a.f(); System.out.println(a.getClass().getName()); // Oops! Reflection still allows us to call g(): callHiddenMethod(a, “g”); // And even methods that are less accessible! callHiddenMethod(a, “u”); callHiddenMethod(a, “v”); callHiddenMethod(a, “w”); } static void callHiddenMethod(Object a, String methodName) throws Exception { Method g = a.getClass().getDeclaredMethod(methodName); g.setAccessible(true); g.invoke(a); }} 从输出结果我们可以看出来，不管是public，default，protect还是private方法，通过反射类我们都可以自由调用。当然这里我们只是为了显示反射的强大威力，在实际开发中这种技巧还是不提倡。 public C.f()typeinfo.packageaccess.Cpublic C.g()package C.u()protected C.v()private C.w() 上面我们只是测试了Method对象，感兴趣的读者在熟悉了反射的API之后，不妨测试一下Filed，这里我们就不重复了。 利用动态代理实现面向切面编程 AOP是Spring提供的一个强大特性之一，AOP的意思是面向切面编程，就是说要分离和业务不相关的代码，当我们需要新增相关的事务的时候，我们不想要对业务本身做修改。面向切面编程和面向对象变成相比到底有什么好处呢，我们通过一个例子来看一下，对于新手来说，常常会写出下面这样的代码： public class Example1 { public void execute() { // 记录日志 Logger logger = Logger.getLog(…); // 进行性能统计 PerformanceUtil.startTimer(…); // 权限检查 if (!user.hasPrevilege()) { // 抛出异常 } // 执行真正的业务 executeTransaction(); PerformanceUtil.endTimer(); }} 虽然我们上面真正要执行的业务只有executeTransaction()，但是日志，性能，权限相关的代码差不多要将真正的业务代码掩盖了。而且以后如果我们还有一个Example2，它同样需要实现相同的日志，性能，权限代码。这样当以后我们需要新增相关的逻辑检查的时候，我们需要所有Example进行重构，这显然不符合面向对象的一个基本原则-封装变化。 上面这个场景利用模板方法和装饰器模式都可以解决，在Spring中是通过动态代理来实现的，下面我们通过一个例子来模拟一下Spring中的AOP实现。 我们要实现的业务时，统计程序统计员工工资所执行的时间以及检查用户的权限。首先先来实现的Salary类，它里面包含一些实现统计员工工资的业务逻辑： public interface SalaryInterface { public void doSalary();} public class Salary implements SalaryInterface { public void doSalary() { … }} 通过InvocationHandler我们来实现动态代理，以后当我们调用obj的相关方法之前，都会通过invoke方法进行代理，而不会直接调用obj方法。 public class SimpleProxy implements InvocationHandler { private Object obj; private Object advice; // 绑定代理对象 public Object bind(Object obj, Advice advice) { this.obj = obj; this.advice = advice; return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), this) } // 实现代理 public Object invoke(Object proxy, Method method, Object[] args) throws Throwalbe { Object result = null; try { advice.before(); result = method.invoke(obj, args); advice.after(); } catch(Exception e) { e.printStackTrace(); } return result }} 模拟Spring中的Advice接口： public interface Advice { public void before(); public void after();} 实现TimeAdvice用于统计程序的执行时间： public class TimeAdvice implements Advice { long startTime; long endTime; @Override public void before() { startTime = System.nanoTime(); // 获取开始时间 } @Override public void after() { endTime = System.nanoTime(); // 获取结束时间 }} 客户端调用代码如下： public class Client { public static void main(String[] args) { SimpleProxy = new SimpleProxy(); SalaryInterface salaryInterface = (SalaryInterface) simpleProxy.bind(new Salary(), new TimeAdvice()); salaryInterface.doSalary(); }} 如果我们现在需要新增权限控制，我们来实现ControlAdvie类： public class ControlAdvice implements Advice { @Override public void before() { if (…) { … } else { … } } @Override public void after() { … }} 而我们客户端的代码只需要改成simpleProxy.bind(new Salary(), new ControlAdvie)就行了，而SimpleProxy本身不需要做任何的修改。 与注解相结合 在单元测试框架比如Junit中反射机制也得到了广泛的应用，即通过注解的方式。下面我们简单地来了解一下如何通过反射机制来获取相关方法的注解信息，比如说我们有下面这样一个业务场景，当用户在修改自己密码的时候，为了保证密码的安全性，我们要求用户的新密码要满足一些条件，比如说至少要包含一个非数字字符，不能与以前的密码相同之类的条件等。 import java.lang.annotation.*@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface UserCase { public int id(); public String description() default “no description”;} 下面是我们检测密码的工具类的实现： public class PasswordUtils { @UserCase(id=47, description=”Password must contain at least one numeric”) public boolean validatePassword(String password) { return (password.matches(“\w\d\w“)); } @UserCase(id=48) public String encryptPassword(String password) { return new StringBuilder(password).reverse().toString(); } @UserCase(id=49, description=”New passwords can’t equal previously used ones”) public boolean checkForNewPassword(List prevPasswords, String password) { return !prevPasswords.contains(password); }} 利用反射我们可以写出更加清晰的测试代码，其中getDeclaredMethods()方法可以获取相关对象自己声明的相关方法，而getAnnotation()则可以获取Method对象的指定注解。 public class UseCaseTracker { public static void trackUseCases(List useCases, Class&lt;?&gt; cl) { for(Method m : cl.getDeclaredMethods()) { UseCase uc = m.getAnnotation(UseCase.class); if(uc != null) { System.out.println(“Found Use Case: “ + uc.id() + “ “ + uc.description()); useCases.remove(new Integer(uc.id())); } } for(int i : useCases) { System.out.println(“Warning: Missing use case-“ + i); } } public static void main(String[] args) { List useCases = new ArrayList(); Collections.addAll(useCases, 47, 48, 49, 50); trackUseCases(userCases, PasswordUtils.class); }} 解决泛型擦除 现在有下面这样一个业务场景，我们有一个泛型集合类List]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新的经济周期已经到来]]></title>
    <url>%2F2015%2F09%2F02%2F%E6%96%B0%E7%9A%84%E7%BB%8F%E6%B5%8E%E5%91%A8%E6%9C%9F%E5%B7%B2%E7%BB%8F%E5%88%B0%E6%9D%A5%2F</url>
    <content type="text"><![CDATA[新的经济周期已经到来，这个周期的“房地产、金融、互联网”是谁？ 创业者的核心是找准趋势提前布局深耕细作，时机成熟风自然会来。 一、慌和丧时代 前些日子，李文星事件爆发，Boss直聘一夜之间成了众矢之的。媒体人、自媒体、网友纷纷声讨，呼吁对招聘平台展开严查。这件事情的背后，是招聘app们为了快速爆发、野蛮生长，而大大降低了审核和互动门槛，对平台上涌入的各种虚假可疑公司熟视无睹，是一种监管的不作为。 对招聘领域来说，这当然不是个好消息。可没有好消息的，又岂止招聘行业？ 慌和丧，这两种情绪互相交织，横亘了整个上半年的互联网创投圈。 慌。前些日子，风头正劲的付费社群产品“小密圈”忽然被传下架。尽管公司一再声称这只是“技术性升级”，并且在朋友圈征得新名“知识星球”。但产品“涉及色情和敏感信息”的传言还是甚嚣尘上。一时间满城风雨，同类产品们风声鹤唳、噤若寒蝉。 这不是先例。在此之前，已经有多个被资本们吹上天的“风口”，在政策监管的铁腕面前烟消云散。在国家意志面前，资本的投机炒作不堪一击。 滴滴火了，但是很快最严厉的网约车管制接踵而至，而来自国家的反垄断调查一直在继续。 直播火了，国家一句必须要有试听节目许可证，就让200家直播公司转眼倒下或即将倒下，而诸如黄鳝门等事件打击力度之快之大超出预期。 p2p火了，互金最严整顿也来了，破产跑路无数，从红岭清盘到陆金所传言，现在你还敢进吗，进得了吗？ 内容领域火了，但是自媒体当家花旦咪蒙都可以关进黑屋30天，更何况毒舌电影这些热门号一夜倒下，一时间人人都在猜测、下一个被关的会是谁？ 游戏火了，王者荣耀火遍全中国，于是官媒的联合声讨也来了…… 在这样一种诚惶诚恐的局面下，很多人的情绪已经开始转为“丧”。 当然，也有人根本没把风险放在眼里，先捞到钱再说，能捞到多少是多少。这边互联网金融风声鹤唳，那边他玩ico6得飞起，虚拟货币的暴富神话一时又让人看不明白了。 很多人在问，2017年的风口究竟是什么？在我看来，不论风口是什么，最大的关注点应该是十九大。因为只有十九大开了，国家定了调，我们才知道什么能做、什么不能做，什么国家倡导，什么即便暂时没有禁止、长远来看也一定会面临系统性风险。 而很多人的关注点，已经开始从“究竟做什么赚钱”，转向“什么即使赚钱，长远来看也绝不能做”。 二、上一个周期的逻辑 凛冬将至，上述苦恼绝不仅仅只在互联网一家。 有人说，一个人赚了很多钱是能力问题，但是一个人赚了很多很多很多很多很多……钱，就是时代的问题，是踩准了风口，享受了大趋势带来的红利和泡沫。 回顾这一个经济周期，这样的“红利”非常明显有三个：金融、房地产和互联网。 再往细一点儿说，是金融的“宽松和创新”，是房地产的“投机和炒作”，是互联网的“泡沫和野蛮生长”。本质上说，很多人吃的都是“监管红利”，是在政策宽松或滞后的情况下，通过“钻空子”斩获了史无前例的巨大红利。中国的市场是全球最大的市场，稍微漏出一点风，乘以13亿人，成就的都是亿万资产。 但是今天，全国金融工作会议的召开，金融全面进入“规范和整肃”的时代；伴随着房市严控、租售同权等一系列政策的推出，国家已经给出了信号：这次是动真格的，中国的钱有大用、不能统统吸进楼市黑洞。 而在互联网领域，最严厉高效的监管正在步步走来，以前野蛮生长的方式可能行不通了。 野蛮生长就是互联网的原罪，怎么个野蛮法？ 三、互联网原罪的十字口诀 有人说，在中国最挣钱的方法，其实都写在《刑法》里。这句话虽然过于夸张，但反映在互联网上很明显的一点是：创业者们要想异军突起、迅速逆袭，老老实实一般是行不通的，往往要行走在“灰色地带”，打下三路和擦边球。 可以说，过去几年互联网产品的快速爆发，除了日常刚需工具，其他多半是迎合人性的黑暗面，做多巴胺、伏隔核、心流机制的操控家，简言之就是十字口诀：黄毒假抄懒，斗贴装谣灰。 1、黄 黄，就是色情的力量。性的威力永远是不言而喻的，从传说中的草榴，到约炮神器的横行，从直播平台上晃动的乳沟，到cj上看不尽的大腿……互联网产品即使没有明确的制黄贩黄，也常常作出大量的性暗示和感官刺激。遗憾的是，这一点对于我们这个习惯了故作清高的民族却是异常奏效的，特别是对大多数的底层屌丝用户、几乎立竿见影。这从约炮神器上一度惊人的用户数据和色流诈骗吓人的成功率中可以得证。 2、毒 毒，就是利用各种类似赌博的上瘾机制、让用户沉迷其中。这一点在游戏领域极其明显，网上一直有传言，《王者荣耀》的团队一个重要的研究是，如何在5分钟内让你上瘾。 3、假 假，电商平台相对传统商家，往往可以给出惊人优惠的价格，但其中一些却可能是假冒伪劣。特别在发展的早期，往往成为重灾区，价格便宜往往以品质掺水为代价。 4、抄 抄，擅长抄袭、美其名曰“改良式创新”几乎是中国互联网公司的通病，或者盗版、打着信息公开分享的名义侵犯创作者权益。截至今日，中国的互联网公司已经几乎抄袭了西方所有流行或不流行的产品和商业模式，甚至连综艺、内容和包装设计都能抄即抄、拿来主义。即便本土偶有创新，好不容易从0到1的新创公司只要稍有成就，也会转眼被大公司和资本裹挟的对手们（背景优越的团队）“抄死”。尽管国家一直喊着万众创新，但实际创投圈完全在失控的丛林状态，对创新的不友好到达了史上最严酷的程度。 5、懒 懒，即利用用户的懒惰，提供更加简单高效、可以依赖的解决方案。这是大多数工具性产品的出发点，只要用户对工具产生依赖离不开，就成了任人宰割的羔羊。为什么迅雷、暴风越改版越让人受不了，广告繁多、界面复杂？说到底还是商业诉求在作祟，一开始是用户体验第一，等用户依赖了就翻身做主人、商业诉求力压用户体验。 6、斗 斗，发动群众斗群众，利用各种矛盾造热点、搏眼球、吸流量。从微博的围观到贴吧的爆吧，从知乎的撕逼到网易的评论，从直男癌与田园女权的征战，到地图炮、阶层炮、年龄炮、行业炮的炮火连天……各大平台可谓谙熟了中国人喜好站队互踩、在与人斗其乐无穷中发泄无聊和寻求优越感的心理，网路暴力伴随群体潜意识四处横行。 7、贴 贴，简言之就是补贴。互联网经济总想制造“价格优势”，从低价到特惠到免费到倒贴钱，背后是资本们的人傻钱多、一掷千金、烧钱补贴抢市场。 8、装 装，利用人们的装逼心理，满足用户的虚荣心。从脸萌到足记，从“你的思维更接近东方、西方”到“你是欢乐颂中的谁”，从星座解读的横行到各种心理测试题，无不抓住中国用户的一种心理：想要装逼又必需表面低调、所以借你产品来释放一下。 9、谣 谣，好事不出门、坏事传千里，中国人对各种谣言八卦总是具有特殊的癖好。早年微博的各种曝光、匿名社交平台的横行、各种八卦号的一度爆火，都论证来这一点，窥私欲具有着不可阻挡的诱惑。 10、灰 灰，就是将各种灰色产业合法化。滴滴刚开始，很多时候就是把“黑车”合法化；p2p的横行，很多是给过去的民间高利贷披上了合法外衣。 往细里看，那些面对c端取得大小成就的互联网公司们，谁敢拍着胸脯，说自己的爆发和以上10条没有一点干系？ 四、红利的褪尽 在阶层日益固化的今天，人们越来越关注所谓“红利”。因为只有时代的红利，才能让底层和中产们挣脱可怕的宿命，获得进入“上流城堡”的最后通道。没有这样的红利，你就算赚得还不错，也永远都是做生意、给人打工、挣辛苦钱，富人们早就在“食利”了。 但是很遗憾，在互联网领域，传统意义的红利都在褪尽，而且是从2015年下半年就开始了。 1、人口红利消失了 中国人基本上已经人手一部智能机了，新增手机用户上涨进入了瓶颈期，同时换机的频率也逐步降低，整个移动互联网市场进入了存量时代。新的装机用户越来越少了，谁去应用市场下载你的app呢？于是，获客成本开始激增，互联网创业“低成本起步”的优势消失了。 2、心智瓜分大势确定 打开应用市场，从工具到娱乐到本地商务，所有显而易见的通用需求，都已经有一堆产品堵在那里了，特别是其中的“头部产品”往往已经牢牢占据了用户的心智空间，即便体验已经不是最好，其地位也很难撼动。围绕不同场景、需求和习惯的心智空间已经被瓜分完毕了，互联网创业进入了需求稀缺难寻的时代。此种情况下作出来的产品，要么需求是yy出来的，要么需求不通约天花板太低，要么即便体验确实更好，却沉没在头部产品投射的阴影中，养在深闺人不知，获客成本比头部高出许多倍（没他钱多，还比他获客贵）。 3、寡头垄断局面已经形成 过去是BAT，现在是AT，过去是2vc，现在是2at，腾讯和阿里已经开始成为中国互联网中无处不在的巨力。每一条赛道，只要稍微火，很快就会有他们的身影，要么果断跟进抄抄抄，要么砸钱投资买买买。而新公司们赖以生存的流量管道，也多数被他们把在手里，想造反？先让你的产品分享不到朋友圈，先让你的支付接不上。 4、资本“疯投”破坏生态 很多事情一开始是绝对赚钱的，财务模型也很清晰，比如共享单车、共享充电宝、部分o2o甚至刚开始的团购。可惜的是，这都是在良性竞争的理想状态下。中国的问题是，一个领域稍微有一点儿赚钱，资本就可能带着抄袭者们疯狂进场，从千团大战到百播大战到千车大战，现在甚至狼人杀领域都开始千狼混战。这种情况屡屡发生，蓝海转眼变红海，好好的产品创新转眼变成烧钱补贴抢用户的资本修罗场，创业者成了资本的傀儡。于是，一个红利满满的市场转眼做滥做臭做死，各种同质化恶性竞争甚嚣尘上，要不了多久，一拥而上就会变成一哄而上，创业者纷纷倒下，资本收割了速度离场。不要小看这一点，这世上到处是背景优越、团队豪华、被资本看好却没有方向的团队，资本美其名曰“我就是投人”，如果没背景的你不小心发现了一块沃土，他们就像苍蝇闻着肉香一样扑过来了。 5、最关键的是，十字口诀不灵了。 五、新机会 新的经济周期已经到来，这个周期的“房地产、金融、互联网”是谁？ 在《未来5年大机会——从实用到娱乐，“国民总时间”的结构性变局》中，笔者已经指出：在经济下行的大背景下，我们迎来了一个“口红经济”和“奶嘴乐”的时代，消费和娱乐会上扬。 对于无法在技术领域取得巨大突破、抑或是在线下无法拥有巨大资本资源的草根玩家们来说，这里确实就是机会：产品和商业模式创新，收割娱乐时间和消费升级（相对上流社会是降级）。 说起来容易做起来难，我们又要注意几个点： 1、必须是健康和正面的 不要以为娱乐的崛起就是多巴胺与荷尔蒙的狂欢，就是软色情、暴力、游戏的乐土。《王者荣耀》被围攻和直播管制的例子已经表明：互联网正处在十多个政府部门最严厉的管制之下，更有朝阳群众随时监督，你简单粗暴只怕越来越走不通。 所以，未来能够做大做强的娱乐一定是健康益智、寓教于乐的，像象棋、健身一样远离红线、不易被指摘。那些一味引人沉迷、荒废正业、低俗色情的娱乐模式，会和过去一样容易速火，但只怕死也死得更快。健康积极的娱乐将贯穿在我们的整个社会生活中，内容、培训、商务等各个方面。 但健康积极的娱乐谈何容易，在处处是“一夜暴富”神话的今天，又有多少创业者和投资人经得起慢工细活的忍耐？ 2、警惕潮流性 娱乐爆发也好，消费升级也罢，需要警惕的是其潮流性，即往往“火一把就死”，而不能从流行到经典，这样的速生速死是不可能支撑起一个新时代大公司的。所以，你应该去做“标准化”的产品，要设法抢占心智成为头部，甚至有可能成为未来人们娱乐消费生活方式的档次标准或基础设施。 3、越高端，流量越分散 很多人喜欢说服务中高端人群、做消费升级，但是很遗憾，我们发现在中国，越是做“下三路”接近底层的需求，往往用户流量越集中，约炮、打车、便宜货、傻瓜型游戏……但是越往中高端做，越是作用于人性的优点和人们的自我提升，这个流量就越分散。因为越是底层的需求越是相似，越容易成为人们的最大公约数，也越容易平台化。但越是向上的需求就越分散，不同人眼中有不同的情怀兴致，不同人眼中有不同的逼格档次，不同人眼中有不同的健康品味，不同人眼中有不同的充电方式……越是向上的需求就越是小圈子化，所以你很容易触到人群的天花板，如何精准捕获分散的目标客群，如何做高毛利，这些都会非常重要。 4、中产的钱不好赚 很多人认为，屌丝就是免费，中产就是消费升级，消费升级就是人傻钱多有钱任性。但是实践中，中产的消费可能更加理性和谨慎，更善于精打细算，一方面他们有足够的信息源来做这样的“计算”，另一方面中产面临着“向上上不去、向下却随时可能滑落底层”的困境，很多人都是接近上流的精致外表、接近屌丝的可支配收入。所以如何征服他们的心，可没有那么容易。 5、做小弟的思想准备 在这样的情势下，真的不要天天想着做大平台、想着颠覆BAT、想着改变世界了，高筑墙、广积粮、缓称王，先学会容易腾讯和阿里的体系中、老老实实从小弟做起比较重要。想想看，牛如乔布斯，当年不也一样不得不暂时对盖茨“称臣”？创业首先是生意，找到现金活下去才有勃勃野心。 6、快速变现，轻资本依赖 过去几年，大量公司的衰落，其实是因为创业者把大多数时间都放在了融资上，和投资人觥筹交错四处周旋，却始终没有功夫聚焦在产品、员工和市场一线上，而后者才是真正的重要。这样的结果也造成了一种逆淘汰，谁背景好会融资，谁就能一直跑下去，哪怕产品和商业模式很多和一坨屎一样，大不了直接抄袭做的好的就行了。这样的逆淘汰到最后，走出来的公司都是重度资本依赖型公司，都是资本家们的提线木偶。没有显赫背景的草根创业者们显然不能这么玩儿，所以拜托你不要讲“先烧钱、做免费大平台、流量成规模了再变现”的故事，这个故事太奢侈不属于你。 你要做的是简化商业模型、缩短盈利链条，尽快地闷声赚钱，这样哪怕有大家伙进场，只要有钱赚至少你活得下去。不要在想什么“英雄不问出身”了，那都是投资人套你点子之前的说辞，人家心里可都是对你的背景明码标价着呢。 7、创新和壁垒更重要 时至今日，从0到1的创新的重要变得史无前例，因为玩“模仿加微创新”，你不仅玩不过BAT，玩不过TMD，恐怕一个陌陌也能把你抄死。草根玩家在别人主场的赛道上再怎么创新，别人只要稍稍动一动产品、玩一玩资本、分分钟就能把你弄死。 所以，两种思维会比较重要： 一是第一性原理，不比照市面上已经有的产品，而是回归用户需求本初；二是破坏性创新，减少主流对手长期专注、持续发展以至效率过分的部分，把关注点放到其他价值诉求上，并且不断深耕，由于双方基础理念结构不同，强敌不大可能转而追随。但即便这样我也要说，中国现在最关键的是专利制度，是创新保护，否则我苦心孤诣好不容易找到一个杀手锏，申请专利用了一年半，你凭着资本人傻钱多分分钟把我干了，这个局还有什么意义，以后还会有人创新吗？ 保护中小创业者，从保护创新开始，救救创业救救创新！ 8、找趋势，不追风口 喜马拉雅上卫哲老师一句话非常好： 要寻找未来的趋势，而不是追风口。趋势是长期的必然的，而风口则是可以通过短期炒作、资本哄抬制造出来的“热点”。截至今天，相当多的风口已经被证明是“伪需求泡沫”，根本不是未来趋势，你去追不是送死吗？更何况，当一个领域成为风口的时候，往往之前已经有几十家企业在那里深耕了半年一年，主流投资人估计都进去过了一遍，这个时候你才反应过来要追，还来得及吗？当一个事情已经成为风口时，它多半已经和你无关了。 所以，创业者的核心是找准趋势提前布局深耕细作，时机成熟风自然会来。只不过，很多人是心理还没过断奶期，没有融资就不敢创业，所以一定要2vc，一定要追风口。 六、未必是坏事 总结一句，对于大多数草根玩家来说，可以融入大公司生态、具有创新壁垒、围绕年轻一代（准）中产阶级、盈利路径短、现金流清晰、低资本依赖、健康积极可持续的娱乐和消费，或者大公司体系下的2b服务，会存在越来越多的机会，甚至存在平台级大机遇的可能。 但是回到开头，今年是创业者尤其需要“讲政治”的一年，只有一个最重要的背景，19大的召开。毕竟，经历了前景如此混沌不明、几乎看不到多少大机会的16年，我们迫切地需要知道，这个国家下一个重要的棋子将落在何方？ 科技趋势，政治走向，市场规律，社会思潮，这四大合力的系统性结果，才能让我们看清新一个周期下“时代的红利”究竟为何。 过去的路都不灵了，但这未必是坏事。大争之世，英雄方能崛起于草莽之间。 对于新来者来说，最大的优点或许是“没有包袱、没有惯性、没有原罪”，因为上个周期能走得通的模式现在都不灵了，你轻装上阵，很多事情从头开始，这带来了宝贵的重新洗牌的机会。 不要怕寒冬，因为生来就在寒冬中，没有什么可以失去，除了“思维的锁链”。 祝好运，再过个五年，我们看谁是新经济周期中的马云、马化腾、王健林。 #专栏作家#]]></content>
      <categories>
        <category>创业知识</category>
      </categories>
      <tags>
        <tag>创业</tag>
      </tags>
  </entry>
</search>