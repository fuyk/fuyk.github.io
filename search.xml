<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[代理模式]]></title>
    <url>%2F2017%2F08%2F25%2F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[说说 JAVA 代理模式 本文内容借阅来自ImportNew中 事例 小张是一个普普通通的码农，每天勤勤恳恳地码代码。某天中午小张刚要去吃饭，一个电话打到了他的手机上。“是XX公司的小张吗？我是YY公司的王AA”。“哦，是王总啊，有什么事情吗？”。沟通过后，小张弄明白了,原来客户有个需求，刚好负责这方面开发的是小张，客户就直接找到了他。不过小张却没有答应客户的请求，而是让客户找产品经理小李沟通。 是小张着急去吃面而甩锅吗？并不是，只是为了使故事可以套到代理模式上。我们先看一下代理模式的定义： * 为其他对象提供一种代理，以控制对这个对象的访问。(Provide a surrogate or placeholder for another object to control access to it) 对照定义，码农小张可以映射为其他对象，产品经理小李为小张的代理。我们通过JAVA代码，表述上面事例。 静态代理 1.抽象角色 基于面向对象的思想，首先定义一个码农接口,它有一个实现用户需求的方法。 public interface ICoder { public void implDemands(String demandName); } 2.真实角色 我们假设小张是JAVA程序员，定义一个JAVA码农类，他通过JAA语言实现需求。 public class JavaCoder implements ICoder{ private String name; public JavaCoder(String name){ this.name = name; } @Override public void implDemands(String demandName) { System.out.println(name + &quot; implemented demand:&quot; + demandName + &quot; in JAVA!&quot;); } } 3.代理角色 委屈一下产品经理，将其命名为码农代理类，同时让他实现ICoder接口。 public class CoderProxy implements ICoder{ private ICoder coder; public CoderProxy(ICoder coder){ this.coder = coder; } @Override public void implDemands(String demandName) { coder.implDemands(demandName); } } 上面一个接口，两个类，就实现了代理模式。Are you kidding me？这么简单？是的，就是这么简单。 我们通过一个场景类，模拟用户找产品经理增加需求。 public class Customer { public static void main(String args[]){ //定义一个java码农 ICoder coder = new JavaCoder(&quot;Zhang&quot;); //定义一个产品经理 ICoder proxy = new CoderProxy(coder); //让产品经理实现一个需求 proxy.implDemands(); } } 运行程序，结果如下： Zhang implemented demand:Add user manageMent in JAVA! 产品经理充当了程序员的代理，客户把需求告诉产品经理，并不需要和程序员接触。看到这里，有些机智的程序员发现了问题。你看，产品经理就把客户的需求转达了一下，怪不得我看产品经理这么不爽。 产品经理当然不只是转达用户需求，他还有很多事情可以做。比如，该项目决定不接受新增功能的需求了，对修CoderProxy类做一些修改： public class CoderProxy implements ICoder{ private ICoder coder; public CoderProxy(ICoder coder){ this.coder = coder; } @Override public void implDemands(String demandName) { if(demandName.startsWith(&quot;Add&quot;)){ System.out.println(&quot;No longer receive &apos;Add&apos; demand&quot;); return; } coder.implDemands(demandName); } } 这样，当客户再有增加功能的需求时，产品经理就直接回绝了，程序员无需再对这部分需求做过滤。 总结 我们对上面的事例做一个简单的抽象： 代理模式包含如下角色： Subject:抽象主题角色。可以是接口，也可以是抽象类。 RealSubject:真实主题角色。业务逻辑的具体执行者。 ProxySubject:代理主题角色。内部含有RealSubject的引用,负责对真实角色的调用，并在真实主题角色处理前后做预处理和善后工作。 代理模式优点： 职责清晰 真实角色只需关注业务逻辑的实现，非业务逻辑部分，后期通过代理类完成即可。 高扩展性 不管真实角色如何变化，由于接口是固定的，代理类无需做任何改动。 动态代理 前面讲的主要是静态代理。那么什么是动态代理呢？ 假设有这么一个需求，在方法执行前和执行完成后，打印系统时间。这很简单嘛，非业务逻辑，只要在代理类调用真实角色的方法前、后输出时间就可以了。像上例，只有一个implDemands方法，这样实现没有问题。但如果真实角色有10个方法，那么我们要写10遍完全相同的代码。有点追求的码农，肯定会对这种方法感到非常不爽。有些机智的小伙伴可能想到了用AOP解决这个问题。非常正确。莫非AOP和动态代理有什么关系？没错！AOP用的恰恰是动态代理。 代理类在程序运行时创建的代理方式被称为动态代理。也就是说，代理类并不需要在Java代码中定义，而是在运行时动态生成的。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类的函数。对于上例打印时间的需求，通过使用动态代理，我们可以做一个“统一指示”，对所有代理类的方法进行统一处理，而不用逐一修改每个方法。下面我们来具体介绍下如何使用动态代理方式实现我们的需求。 与静态代理相比，抽象角色、真实角色都没有变化。变化的只有代理类。因此，抽象角色、真实角色，参考ICoder和JavaCodr。 在使用动态代理时，我们需要定义一个位于代理类与委托类之间的中介类，也叫动态代理类，这个类被要求实现InvocationHandler接口： public class CoderDynamicProxy implements InvocationHandler{ //被代理的实例 private ICoder coder; public CoderDynamicProxy(ICoder _coder){ this.coder = _coder; } //调用被代理的方法 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(System.currentTimeMillis()); Object result = method.invoke(coder, args); System.out.println(System.currentTimeMillis()); return result; } } 当我们调用代理类对象的方法时，这个“调用”会转送到中介类的invoke方法中，参数method标识了我们具体调用的是代理类的哪个方法，args为这个方法的参数。 我们通过一个场景类，模拟用户找产品经理更改需求。 public class DynamicClient { public static void main(String args[]){ //要代理的真实对象 ICoder coder = new JavaCoder(&quot;Zhang&quot;); //创建中介类实例 InvocationHandler handler = new CoderDynamicProxy(coder); //获取类加载器 ClassLoader cl = coder.getClass().getClassLoader(); //动态产生一个代理类 ICoder proxy = (ICoder) Proxy.newProxyInstance(cl, coder.getClass().getInterfaces(), handler); //通过代理类，执行doSomething方法； proxy.implDemands(&quot;Modify user management&quot;); } } 执行结果如下： 1501728574978 Zhang implemented demand:Modify user management in JAVA! 1501728574979 通过上述代码，就实现了，在执行委托类的所有方法前、后打印时间。还是那个熟悉的小张，但我们并没有创建代理类，也没有时间ICoder接口。这就是动态代理。 总结 总结一下，一个典型的动态代理可分为以下四个步骤： 创建抽象角色 创建真实角色 通过实现InvocationHandler接口创建中介类 通过场景类，动态生成代理类 如果只是想用动态代理，看到这里就够了。但如果想知道为什么通过proxy对象，就能够执行中介类的invoke方法，以及生成的proxy对象是什么样的，可以继续往下看。 源码分析(JDK7) 看到这里的小伙伴，都是有追求的程序员。上面的场景类中，通过 //动态产生一个代理类 ICoder proxy = (ICoder) Proxy.newProxyInstance(cl, coder.getClass().getInterfaces(), handler); 动态产生了一个代理类。那么这个代理类是如何产生的呢？我们通过代码一窥究竟。 Proxy类的newProxyInstance方法，主要业务逻辑如下： //生成代理类class，并加载到jvm中 Class&lt;?&gt; cl = getProxyClass0(loader, interfaces); //获取代理类参数为InvocationHandler的构造函数 final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); //生成代理类，并返回 return newInstance(cons, ih); 上面代码做了三件事： 根据传入的参数interfaces动态生成一个类，它实现interfaces中的接口，该例中即ICoder接口的implDemands方法。假设动态生成的类为$Proxy0。 通过传入的classloder,将刚生成的$Proxy0类加载到jvm中。 利用中介类，调用$Proxy0的$Proxy0(InvocationHandler)构造函数，创建$Proxy0类的实例，其InvocationHandler属性，为我们创建的中介类。 上面的核心，就在于getProxyClass0方法： private static Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) { if (interfaces.length &gt; 65535) { throw new IllegalArgumentException(&quot;interface limit exceeded&quot;); } // If the proxy class defined by the given loader implementing // the given interfaces exists, this will simply return the cached copy; // otherwise, it will create the proxy class via the ProxyClassFactory return proxyClassCache.get(loader, interfaces); } 在Proxy类中有个属性proxyClassCache，这是一个WeakCache类型的静态变量。它指示了类加载器和代理类之间的映射。所以proxyClassCache的get方法用于根据类加载器来获取Proxy类，如果已经存在则直接从cache中返回，如果没有则创建一个映射并更新cache表。 我们跟一下代理类的创建流程： 调用Factory类的get方法，而它又调用了ProxyClassFactory类的apply方法，最终找到下面一行代码： //Generate the specified proxy class. byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces); 就是它，生成了代理类。 查看动态生成的代理类 通过上面的分析，我们已经知道Proxy类动态创建代理类的流程。那创建出来的代理类到底是什么样子的呢？我们可以通过下面的代码，手动生成： public class CodeUtil { public static void main(String[] args) throws IOException { byte[] classFile = ProxyGenerator.generateProxyClass(&quot;TestProxyGen&quot;, JavaCoder.class.getInterfaces()); File file = new File(&quot;D:/aaa/TestProxyGen.class&quot;); FileOutputStream fos = new FileOutputStream(file); fos.write(classFile); fos.flush(); fos.close(); } } 通过反编译工具查看生成的class文件: import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import java.lang.reflect.UndeclaredThrowableException; import model.proxy.ICoder; public final class TestProxyGen extends Proxy implements ICoder { private static Method m1; private static Method m0; private static Method m3; private static Method m2; public TestProxyGen(InvocationHandler paramInvocationHandler) throws { super(paramInvocationHandler); } public final boolean equals(Object paramObject) throws { try { return ((Boolean)this.h.invoke(this, m1, new Object[] { paramObject })).booleanValue(); } catch (RuntimeException localRuntimeException) { throw localRuntimeException; } catch (Throwable localThrowable) { } throw new UndeclaredThrowableException(localThrowable); } public final int hashCode() throws { try { return ((Integer)this.h.invoke(this, m0, null)).intValue(); } catch (RuntimeException localRuntimeException) { throw localRuntimeException; } catch (Throwable localThrowable) { } throw new UndeclaredThrowableException(localThrowable); } public final void implDemands(String paramString) throws { try { this.h.invoke(this, m3, new Object[] { paramString }); return; } catch (RuntimeException localRuntimeException) { throw localRuntimeException; } catch (Throwable localThrowable) { } throw new UndeclaredThrowableException(localThrowable); } public final String toString() throws { try { return (String)this.h.invoke(this, m2, null); } catch (RuntimeException localRuntimeException) { throw localRuntimeException; } catch (Throwable localThrowable) { } throw new UndeclaredThrowableException(localThrowable); } static { try { m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[] { Class.forName(&quot;java.lang.Object&quot;) }); m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]); m3 = Class.forName(&quot;model.proxy.ICoder&quot;).getMethod(&quot;implDemands&quot;, new Class[] { Class.forName(&quot;java.lang.String&quot;) }); m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]); return; } catch (NoSuchMethodException localNoSuchMethodException) { throw new NoSuchMethodError(localNoSuchMethodException.getMessage()); } catch (ClassNotFoundException localClassNotFoundException) { } throw new NoClassDefFoundError(localClassNotFoundException.getMessage()); } } 这样，我们就理解，为什么调用代理类的implDemands方法，回去执行中介类的invoke方法了。 看完本文有收获？请转发分享给更多人]]></content>
      <categories>
        <category>代理模式</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[whystudyIT]]></title>
    <url>%2F2017%2F08%2F07%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B5%B0%E4%B8%8A%E8%BF%99%E8%B7%AF%2F</url>
    <content type="text"></content>
      <categories>
        <category>关于我</category>
      </categories>
      <tags>
        <tag>story</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexoStudy]]></title>
    <url>%2F2017%2F08%2F05%2FhexoStudy%2F</url>
    <content type="text"><![CDATA[前提准备 NodeJSgit确保安装这两个才可以继续。 安装Hexo打开git $ npm install -g hexo部署Hexo在任何想要放置Hexo的文件夹下建立名为Hexo的文件夹，在此文件夹中右键打开Git Bash $ hexo initHexo会自动建立所有博客需要的文件 $ hexo g$ hexo s输入上面的命令就可以在本地看到初始化的博客啦，浏览器中输入localhost:4000以上就完成了博客的本地调试了，下面需要将本地的博客放到github中去，利用github pages 的免费空间存放你的博客，而且别人也可以访问你的博客。 配置和使用github首先需要注册github（废话。。划掉），然后登录github，点击右上角你的头像，再点击Settings，进入设置页面。点击侧栏的SSH and GPG keys,可以查看你是否有本机的SSH密匙。如果没有，说明并没有设置SSH密匙。 检查SSH keys的设置先不管github的网页，回到本机，打开Git Bash。输入： $ cd ~/. ssh 检查本机的ssh密钥如果提示：No such file or directory 说明你是第一次使用git。 生成新的SSH Key：继续输入： $ ssh-keygen -t rsa -C “邮件地址@youremail.com”Generating public/private rsa key pair.Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt;系统会要求你输入密码，输入就好，只是这里的输入是不显示占位符的。 Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;Enter same passphrase again:&lt;再次输入加密串&gt;完成后就会提示你的密匙文件所在的位置，打开id_rsa.pub文件，复制所有，回到github网页，点击New SSH key,粘贴到key文本框中，点击add key就可以了。 测试SSH连接输入下面的命令，git@github.com不用修改。 $ ssh -T git@github.com会有这样的反馈： The authenticity of host ‘github.com (207.97.227.239)’ can’t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)?输入yes，就会看到： Hi Dulmcat! You’ve successfully authenticated, but GitHub does not provide shell access.到这里就代表已经正确的连接到github了。 设置用户信息但还有一些个人信息还是需要继续完善下的，Git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的。 $ git config –global user.name “cnfeat”//用户名$ git config –global user.email “cnfeat@gmail.com”//填写自己的邮箱若有问题，从头再来一遍，或者到GitHub help中寻找解决方案。 使用GitHub pages 建立网页与GitHub建立好链接之后，就可以方便的使用它提供的Pages服务。但pages服务每个ID只有一个，大小也只有300M，但作为博客站，已经足够了。 建立仓库登录GitHub后，点击那个大大的绿色New repository按钮，新建一个仓库：Repository name：dulmcat.github.ioDescription (optional): 嗯。。括号里都说了是可选的，就随便吧，可填可不填。注意！！ 这里的Repository name必须是你的github用户名.github.io，否则就不是一个github pages而只是单纯的一个仓库了。点击Create Repository 完成创建。 上传hexo到github pages上传前，需要将Hexo和github想关联起来，在Hexo的配置文件_config.yml文件中,拉到最下面，修改配置文件： deploy: type: git repository: https://github.com/Dulmcat/Dulmcat.github.io branch: master这里的repository填写的是你的github pages所在库（就是上面刚建好的那个）的地址。这里有个坑，关于type的填写，有说应该是github的，有说是git的，我在两个月前的配置文件type写的github，写这篇文章时发现出错了，这才发现好像是作者在3.0之后改为了git，大家在安装Hexo时可以输入命令hexo-v查看Hexo的版本。在3.0之后需要另外安装hexo-deployer-git。 $ npm install hexo-deployer-git –save然后 $ hexo d这里可能会要求填写密码，填了就好。然后在浏览器中输入https://dulmcat.github.io 就可以看到你的博客啦一个在线的博客就这样建好了当然这是我的…要输入 你的github用户名.github.io]]></content>
      <categories>
        <category>hexo建博小结</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[studyHexo-1]]></title>
    <url>%2F2017%2F08%2F05%2FstudyHexo-1%2F</url>
    <content type="text"></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Hexo和Github搭建博客]]></title>
    <url>%2F2017%2F08%2F04%2Fcategories%2F</url>
    <content type="text"></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[myGitOneDay]]></title>
    <url>%2F2017%2F08%2F04%2FmyGitOneDay%2F</url>
    <content type="text"></content>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F08%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>