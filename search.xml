<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux（一）]]></title>
    <url>%2F2017%2F08%2F25%2FLinux%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[先说明本文：图片没有贴出，大家认真阅读不影响 一 ：为什么学Linux Linux的历史发展大家可以百度一些，了解了解就ok,学利用一切可以利用的资源； 1.Linux的特点： 第一： 免费开源，了解它的发展就知道为什么开源了，一款完全的免费的操作系统，都可以下载它的源码，没有什么限制。 第二： 模块化程度高。 Linux 的 内核 设计 分成 进程 管理、 内存 管理、进程 间 通信、 虚拟 文件 系统、 网络 5 部分， 其 采用 的 模块 机制 使得 用户 可以 根据 实际 需要， 在 内核 中 插入 或 移走 模块， 这使 得 内核 可以 被 高度 的 剪裁 定制， 以 方便 在 不同 的 场景 下 使用。 . 第三： 广泛 的 硬件 支持。 得 益于 其 免费 开源 的 特点， 有 大批 程序员 不断 地 向 Linux 社区 提供 代码， 使得 Linux 有着 异常 丰富 的 设备 驱动 资源， 对 主流 硬件 的 支持 极好， 而且 几乎 能 运行 在 所有 流行 的 处理器 上。 第四： 安全 稳定。 Linux 采取 了 很多 安全 技术 措施， 包括 读写 权限 控制、 带 保护 的 子系统、 审计 跟踪、 核心 授权 等， 这 为 网络 环境 中的 用户 提供 了 安全保障。 实际 上有 很多 运行 Linux 的 服务器 可以 持续 运行 长达 数年 而 无须 重 启， 依然 可以 性能 良好 地 提供 服务， 其 安全 稳定性 已经 在各 个领域 得到 了 广泛 的 证实。 第五： 多用户， 多任务。 多用户 是指 系统 资源 可以 同时 被 不同 的 用户 使用， 每个 用户 对 自己的 资源 有 特定 的 权限， 互不 影响。 多任务 是 现代化 计算机的 主要 特点， 指的 是 计算 机能 同时 运行 多个 程序， 且 程序 之间 彼此 独立， Linux 内核 负责 调度 每个 进程， 使之 平等 地 访问 处理器。 由于 CPU 处理 速度 极快， 从 用户 的 角度 来看 所有 的 进程 好像 在 并行 运行。 第六： 良好 的 可移植性。 Linux 中 95% 以上 的 代码 都是 用 C 语言 编写 的， 由于 C 语言 是一 种 机器 无关 的 高级 语言， 是 可 移植 的， 因此 Linux 系统 也是 移植的 1.2Linux优点： 稳定、免费或者花费少 安全性高 多任务，多用户 耗资源少 由于内核小，所以它可以支持多种电子产品，如：Android手机、PDA等 1.3安装（建议初学者可以以下） 在安装Linux系统之前，先来了解windows系统结构，windows系统一般是安装在C盘系统盘，同样Linux也有类似的系统盘（/根分区），Linux通常分区为（根分区/、swap分区），Linux系统以文件的存储方式，所有的文件都是存储在某个目录下的，类似于windows的文件夹。对于文件系统的属性来说，windows文件系统类型一般是ntfs、fat32等，而Linux文件系统类型则为ext2、ext3、ext4等（文件系统：是操作系统用于明确磁盘或分区上的文件的方法和数据结构，文件系统由三部分组成：与文件管理有关软件、被管理文件以及实施文件管理所需数据结构。）安装 Linux系统是每一个初学者的第一个门槛。在这个过程中间，最大的困惑莫过于给硬盘进行分区。虽然现在各种发行版本的 Linux 已经提供了友好的图形交互界面，但是很多人还是感觉无从下手。这其中的原因主要是不清楚 Linux 的分区规定。就好比如果我们了解了windows分区的规则，系统盘C、数据盘D等，就很好分区了。在 Linux 中规定，每一个硬盘设备最多只能有 4个主分区（其中包含扩展分区）构成，任何一个扩展分区都要占用一个主分区号码，也就是在一个硬盘中，主分区和扩展分区一共最多是 4 个。下面正式来安装Linux系统，安装系统前需要准备如下软件： VMware workstation 10.0（可以百度一下）CentOS 5.8 x86_i386.i或redhat（Linux官网下载） 说明：可能随时间更新版本可能安装有一定差异，不过换汤不换药，相信我们这些IT男的头脑这so easy。 1. 3. 1 安装 前 的 规划 可能会有读者正计划学习Linux 而苦恼于 不知道 使用 哪一个 发行 版， 其实 所有 的 发行 版 不管 是 RedHat、 CentOS 还是 Ubuntu， 其内 核 都是 来自 Linux 内核 官 网（ www. kernel. org）， 不同 发行 版 之间 的 差别 在于 软件 管理 的 不同， 所以 不管 使用 哪一个 发行 版， 只要 理解 其 原理 之后， 各类 发行 版 的 区别 其实 不大。 当然 对于 初学者 来说， 拥有 广泛 的 学习 资源 也是 很重 要的。 由于 RedHat 公司 进行 了 大力 商业 推广， 且 得 益于 其 成熟 的 认证 体系， 因此 使用 RedHat 的 用户 比较 多， 同时， 它 还有 丰富 的 相关 技术 文档， 以及 活跃 的 社区， 所以 作为 入门 学习， 可以 使用 RedHat。 不过年来，CentOS 发展 也 很 迅猛， 这个 发行 版 和 RedHat 几乎 完全 一样， 而且 在 某些方面 还 比 RedHat 略胜一筹， 所以 在 本书 中 后面 的 所有 内容 中将 主要 使用 版本 为 5. 5 的 CentOS， 小部分 涉及 RedHat 的 内容 也 将 采用 5. 5 版本。 有 读者 可能 会 考虑 在 一台 计算 机上 安装 多个 操作系统， 比如说 在 自己的 家用 计算 机上 安装 Windows 用于 娱乐 和 日常 应用 或 Windows 环境 下 的 开发 等， 另外 再 安装 Linux 系统 用于 学习。 在 这种 情况下， 最简单 的 安装 方法 是 先 安装 Windows， 后 安装 Linux， 这样 开机 的 时候 就 自动 出现 操作系统 选择 条， 可以 根据 实际需要 选择 进入 不同 的 操作系统。 由于 Linux 对 系统 的 需求 并不 高， 所以 几乎 所有 计算机 都可以 安装， 但是 考虑到 入门 学习 Linux 需要 用到 图形 界面， 所以 建议 最好 不要 低于 以下 配置： CPU， P- 3 800MHz； 内存， 1GB； 硬盘， 40GB。 在 安装 Linux 的 过程中， 必须 要有 的 两个 分区 为 根 分区（/） 和 swap 分区（ 交换 分区）， 当然 还有 一些 其他 的 分区 可以 独立 出来， 比如说/ boot 分区、/ var 分区 等。 另外， 这里 介绍 几个 概念， 便于 大家 理解 后面 即将 出现 的 一些 专业 词汇。 什么 是 交换 分区？ 交换 分区 是一 个 特殊 的 分区， 它的 作用 相当于 Windows 下 的 虚拟 内存， 这个 分区 的 大小 一般 设置 为 物理 内存 的 两倍， 但是 不管 物理 内存 有 多大， 交换 分区 建议 不要 超过 8GB， 因为 大于 8GB 的 交换 分区 其实 并没有 多大 实际意义。 什么 是 Grub？ Grub 是一 个 系统 引导 工具， 通过 它可 以 加载 内核， 从而 在 安装 Linux 的 过程中， 必须 要有 的 两个 分区 为 根 分区（/） 和 swap 分区（ 交换 分区）， 当然 还有 一些 其他 的 分区 可以 独立 出来， 比如说/ boot 分区、/ var 分区 等。 另外， 这里 介绍 几个 概念， 便于 大家 理解 后面 即将 出现 的 一些 专业 词汇。 什么 是 交换 分区？ 交换 分区 是一 个 特殊 的 分区， 它的 作用 相当于 Windows 下 的 虚拟 内存， 这个 分区 的 大小 一般 设置 为 物理 内存 的 两倍， 但是 不管 物理 内存 有 多大， 交换 分区 建议 不要 超过 8GB， 因为 大于 8GB 的 交换 分区 其实 并没有 多大 实际意义。 什么 是 Grub？ Grub 是一 个 系统 引导 工具， 通过 它可 以 加载 内核， 从而 引导 系统 启动。 什么 是/ boot 分区？/ boot 分区 用于 放置 Linux 启动 所 用到 的 文件， 如 kernel 和 initrd 文件。 什么 是 DHCP？ DHCP 是 Dynamic Host Configuration Protocol 的 简写， 中文 称为 动态 主机 配置 协议。 在 TCP/ IP 网络 中， 每 台 主机 都 需要 有 IP 地址 才能 与其 他 主机 通信， 在 一个 大规模 的 网络 中， 如果 由 管理员 手动 地 对 每一 台 主机 进行 IP 地址 配置 是 不现实 的。 由此 也就 产生了 DHCP 协议， 可用 它来 2 安装 RedHat 本节 将 演示 安装 RedHat 系统 的 过程， 使 用到 的 版本 是 RedHat 5. 5。 大家 可以 先到 网上 下载 RedHat 5. 5 操作系统 的 ISO 文件， 然后 刻成 光盘 再 安装。 当然 不要 忘记 在 计算机 的 主 板 中 设置 从 光驱 启动， 也可以 使用 虚拟 机 软件 通过 安装 虚拟 机 的 方式 模拟 安装 过程。 计算机 从 光盘 启动 后， 首先 会 显示 如图 1- 1 所示 界面（ 注意 看 英文 提示）。 如果 想 使用 图形 界面 安装 直接 按 回车 键 即可， 或者 在 10 秒 之内 不做 任何 输入， 这样 也会 默认 进入 图形 安装 模式。 如果 想用 字符 模式 安装， 需要 输入 linux text， 然后 按 回车 键。 如果 计算机 的 内存 过小， 安装 程序 会 检测 到 因 内存 不足 而无 法 进入 图形 安装 模式， 转而 进入 字符 安装 模式。 安装图解如下：第一步，新建虚拟机如下图： 第二步，选择相关选项，如下图： 第三步选择“稍后安装操作系统”，如下图: 第四步，选择客户机操作系统类型如下图： 第五步，设置虚拟机硬盘大小为20G，最低不能小于5G，如下图 第六步，虚拟机新建完成，如下图： 第七步，修改虚拟机内存为512M，并添加ISO镜像，如下图： 自此，虚拟机新建完成，接下来点击“启动此虚拟机”进行Linux系统安装，Linux系统安装图解如下：第一步，进入安装界面，直接按Enter回车键即可。 第二步，光盘检测，选择SKIP跳过。 第三步，选择安装过程中的语言，初学者可以选择“简体中文”。 第四步，选择初始化整个硬盘，清除所有数据。 第五步，选择分区方式为“自定义分区“。 点击“新建“-首先创建一个swap交换分区，大小为物理内存的2倍（1024M）。 第六步，继续创建分区，选择“新建“，然后创建根分区/，如下图选择，大小为剩余所有空间即可。 第七步，默认点击下一步，同时默认DHCP配置，时钟选择上海，去掉UTC勾，点击下一步。 第八步，设置root密码，至少六位，点击下一步。 第九步，系统安装包选择，这里选择“现在定制“。 第十步，系统安装包选择，左侧选择“开发“—-右侧选择”开发工具“和“开发库”，语言选择“支持中文“，其他一概不选择。 安装完毕会提示“reboot“，直接回车即可。 .]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[whystudyIT]]></title>
    <url>%2F2017%2F08%2F07%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B5%B0%E4%B8%8A%E8%BF%99%E8%B7%AF%2F</url>
    <content type="text"></content>
      <categories>
        <category>关于我</category>
      </categories>
      <tags>
        <tag>story</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexoStudy]]></title>
    <url>%2F2017%2F08%2F05%2FhexoStudy%2F</url>
    <content type="text"><![CDATA[前提准备 NodeJSgit确保安装这两个才可以继续。 安装Hexo打开git $ npm install -g hexo部署Hexo在任何想要放置Hexo的文件夹下建立名为Hexo的文件夹，在此文件夹中右键打开Git Bash $ hexo initHexo会自动建立所有博客需要的文件 $ hexo g$ hexo s输入上面的命令就可以在本地看到初始化的博客啦，浏览器中输入localhost:4000以上就完成了博客的本地调试了，下面需要将本地的博客放到github中去，利用github pages 的免费空间存放你的博客，而且别人也可以访问你的博客。 配置和使用github首先需要注册github（废话。。划掉），然后登录github，点击右上角你的头像，再点击Settings，进入设置页面。点击侧栏的SSH and GPG keys,可以查看你是否有本机的SSH密匙。如果没有，说明并没有设置SSH密匙。 检查SSH keys的设置先不管github的网页，回到本机，打开Git Bash。输入： $ cd ~/. ssh 检查本机的ssh密钥如果提示：No such file or directory 说明你是第一次使用git。 生成新的SSH Key：继续输入： $ ssh-keygen -t rsa -C “邮件地址@youremail.com”Generating public/private rsa key pair.Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt;系统会要求你输入密码，输入就好，只是这里的输入是不显示占位符的。 Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;Enter same passphrase again:&lt;再次输入加密串&gt;完成后就会提示你的密匙文件所在的位置，打开id_rsa.pub文件，复制所有，回到github网页，点击New SSH key,粘贴到key文本框中，点击add key就可以了。 测试SSH连接输入下面的命令，git@github.com不用修改。 $ ssh -T git@github.com会有这样的反馈： The authenticity of host ‘github.com (207.97.227.239)’ can’t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)?输入yes，就会看到： Hi Dulmcat! You’ve successfully authenticated, but GitHub does not provide shell access.到这里就代表已经正确的连接到github了。 设置用户信息但还有一些个人信息还是需要继续完善下的，Git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的。 $ git config –global user.name “cnfeat”//用户名$ git config –global user.email “cnfeat@gmail.com”//填写自己的邮箱若有问题，从头再来一遍，或者到GitHub help中寻找解决方案。 使用GitHub pages 建立网页与GitHub建立好链接之后，就可以方便的使用它提供的Pages服务。但pages服务每个ID只有一个，大小也只有300M，但作为博客站，已经足够了。 建立仓库登录GitHub后，点击那个大大的绿色New repository按钮，新建一个仓库：Repository name：dulmcat.github.ioDescription (optional): 嗯。。括号里都说了是可选的，就随便吧，可填可不填。注意！！ 这里的Repository name必须是你的github用户名.github.io，否则就不是一个github pages而只是单纯的一个仓库了。点击Create Repository 完成创建。 上传hexo到github pages上传前，需要将Hexo和github想关联起来，在Hexo的配置文件_config.yml文件中,拉到最下面，修改配置文件： deploy: type: git repository: https://github.com/Dulmcat/Dulmcat.github.io branch: master这里的repository填写的是你的github pages所在库（就是上面刚建好的那个）的地址。这里有个坑，关于type的填写，有说应该是github的，有说是git的，我在两个月前的配置文件type写的github，写这篇文章时发现出错了，这才发现好像是作者在3.0之后改为了git，大家在安装Hexo时可以输入命令hexo-v查看Hexo的版本。在3.0之后需要另外安装hexo-deployer-git。 $ npm install hexo-deployer-git –save然后 $ hexo d这里可能会要求填写密码，填了就好。然后在浏览器中输入https://dulmcat.github.io 就可以看到你的博客啦一个在线的博客就这样建好了当然这是我的…要输入 你的github用户名.github.io]]></content>
      <categories>
        <category>hexo建博小结</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[studyHexo-1]]></title>
    <url>%2F2017%2F08%2F05%2FstudyHexo-1%2F</url>
    <content type="text"></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Hexo和Github搭建博客]]></title>
    <url>%2F2017%2F08%2F04%2Fcategories%2F</url>
    <content type="text"></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[myGitOneDay]]></title>
    <url>%2F2017%2F08%2F04%2FmyGitOneDay%2F</url>
    <content type="text"></content>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F08%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[代理模式]]></title>
    <url>%2F2016%2F08%2F25%2F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[说说 JAVA 代理模式 本文内容借阅来自ImportNew中 事例 小张是一个普普通通的码农，每天勤勤恳恳地码代码。某天中午小张刚要去吃饭，一个电话打到了他的手机上。“是XX公司的小张吗？我是YY公司的王AA”。“哦，是王总啊，有什么事情吗？”。沟通过后，小张弄明白了,原来客户有个需求，刚好负责这方面开发的是小张，客户就直接找到了他。不过小张却没有答应客户的请求，而是让客户找产品经理小李沟通。 是小张着急去吃面而甩锅吗？并不是，只是为了使故事可以套到代理模式上。我们先看一下代理模式的定义： * 为其他对象提供一种代理，以控制对这个对象的访问。(Provide a surrogate or placeholder for another object to control access to it) 对照定义，码农小张可以映射为其他对象，产品经理小李为小张的代理。我们通过JAVA代码，表述上面事例。 静态代理 1.抽象角色 基于面向对象的思想，首先定义一个码农接口,它有一个实现用户需求的方法。 public interface ICoder { public void implDemands(String demandName); } 2.真实角色 我们假设小张是JAVA程序员，定义一个JAVA码农类，他通过JAA语言实现需求。 public class JavaCoder implements ICoder{ private String name; public JavaCoder(String name){ this.name = name; } @Override public void implDemands(String demandName) { System.out.println(name + &quot; implemented demand:&quot; + demandName + &quot; in JAVA!&quot;); } } 3.代理角色 委屈一下产品经理，将其命名为码农代理类，同时让他实现ICoder接口。 public class CoderProxy implements ICoder{ private ICoder coder; public CoderProxy(ICoder coder){ this.coder = coder; } @Override public void implDemands(String demandName) { coder.implDemands(demandName); } } 上面一个接口，两个类，就实现了代理模式。Are you kidding me？这么简单？是的，就是这么简单。 我们通过一个场景类，模拟用户找产品经理增加需求。 public class Customer { public static void main(String args[]){ //定义一个java码农 ICoder coder = new JavaCoder(&quot;Zhang&quot;); //定义一个产品经理 ICoder proxy = new CoderProxy(coder); //让产品经理实现一个需求 proxy.implDemands(); } } 运行程序，结果如下： Zhang implemented demand:Add user manageMent in JAVA! 产品经理充当了程序员的代理，客户把需求告诉产品经理，并不需要和程序员接触。看到这里，有些机智的程序员发现了问题。你看，产品经理就把客户的需求转达了一下，怪不得我看产品经理这么不爽。 产品经理当然不只是转达用户需求，他还有很多事情可以做。比如，该项目决定不接受新增功能的需求了，对修CoderProxy类做一些修改： public class CoderProxy implements ICoder{ private ICoder coder; public CoderProxy(ICoder coder){ this.coder = coder; } @Override public void implDemands(String demandName) { if(demandName.startsWith(&quot;Add&quot;)){ System.out.println(&quot;No longer receive &apos;Add&apos; demand&quot;); return; } coder.implDemands(demandName); } } 这样，当客户再有增加功能的需求时，产品经理就直接回绝了，程序员无需再对这部分需求做过滤。 总结 我们对上面的事例做一个简单的抽象： 代理模式包含如下角色： Subject:抽象主题角色。可以是接口，也可以是抽象类。 RealSubject:真实主题角色。业务逻辑的具体执行者。 ProxySubject:代理主题角色。内部含有RealSubject的引用,负责对真实角色的调用，并在真实主题角色处理前后做预处理和善后工作。 代理模式优点： 职责清晰 真实角色只需关注业务逻辑的实现，非业务逻辑部分，后期通过代理类完成即可。 高扩展性 不管真实角色如何变化，由于接口是固定的，代理类无需做任何改动。 动态代理 前面讲的主要是静态代理。那么什么是动态代理呢？ 假设有这么一个需求，在方法执行前和执行完成后，打印系统时间。这很简单嘛，非业务逻辑，只要在代理类调用真实角色的方法前、后输出时间就可以了。像上例，只有一个implDemands方法，这样实现没有问题。但如果真实角色有10个方法，那么我们要写10遍完全相同的代码。有点追求的码农，肯定会对这种方法感到非常不爽。有些机智的小伙伴可能想到了用AOP解决这个问题。非常正确。莫非AOP和动态代理有什么关系？没错！AOP用的恰恰是动态代理。 代理类在程序运行时创建的代理方式被称为动态代理。也就是说，代理类并不需要在Java代码中定义，而是在运行时动态生成的。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类的函数。对于上例打印时间的需求，通过使用动态代理，我们可以做一个“统一指示”，对所有代理类的方法进行统一处理，而不用逐一修改每个方法。下面我们来具体介绍下如何使用动态代理方式实现我们的需求。 与静态代理相比，抽象角色、真实角色都没有变化。变化的只有代理类。因此，抽象角色、真实角色，参考ICoder和JavaCodr。 在使用动态代理时，我们需要定义一个位于代理类与委托类之间的中介类，也叫动态代理类，这个类被要求实现InvocationHandler接口： public class CoderDynamicProxy implements InvocationHandler{ //被代理的实例 private ICoder coder; public CoderDynamicProxy(ICoder _coder){ this.coder = _coder; } //调用被代理的方法 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(System.currentTimeMillis()); Object result = method.invoke(coder, args); System.out.println(System.currentTimeMillis()); return result; } } 当我们调用代理类对象的方法时，这个“调用”会转送到中介类的invoke方法中，参数method标识了我们具体调用的是代理类的哪个方法，args为这个方法的参数。 我们通过一个场景类，模拟用户找产品经理更改需求。 public class DynamicClient { public static void main(String args[]){ //要代理的真实对象 ICoder coder = new JavaCoder(&quot;Zhang&quot;); //创建中介类实例 InvocationHandler handler = new CoderDynamicProxy(coder); //获取类加载器 ClassLoader cl = coder.getClass().getClassLoader(); //动态产生一个代理类 ICoder proxy = (ICoder) Proxy.newProxyInstance(cl, coder.getClass().getInterfaces(), handler); //通过代理类，执行doSomething方法； proxy.implDemands(&quot;Modify user management&quot;); } } 执行结果如下： 1501728574978 Zhang implemented demand:Modify user management in JAVA! 1501728574979 通过上述代码，就实现了，在执行委托类的所有方法前、后打印时间。还是那个熟悉的小张，但我们并没有创建代理类，也没有时间ICoder接口。这就是动态代理。 总结 总结一下，一个典型的动态代理可分为以下四个步骤： 创建抽象角色 创建真实角色 通过实现InvocationHandler接口创建中介类 通过场景类，动态生成代理类 如果只是想用动态代理，看到这里就够了。但如果想知道为什么通过proxy对象，就能够执行中介类的invoke方法，以及生成的proxy对象是什么样的，可以继续往下看。 源码分析(JDK7) 看到这里的小伙伴，都是有追求的程序员。上面的场景类中，通过 //动态产生一个代理类 ICoder proxy = (ICoder) Proxy.newProxyInstance(cl, coder.getClass().getInterfaces(), handler); 动态产生了一个代理类。那么这个代理类是如何产生的呢？我们通过代码一窥究竟。 Proxy类的newProxyInstance方法，主要业务逻辑如下： //生成代理类class，并加载到jvm中 Class&lt;?&gt; cl = getProxyClass0(loader, interfaces); //获取代理类参数为InvocationHandler的构造函数 final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); //生成代理类，并返回 return newInstance(cons, ih); 上面代码做了三件事： 根据传入的参数interfaces动态生成一个类，它实现interfaces中的接口，该例中即ICoder接口的implDemands方法。假设动态生成的类为$Proxy0。 通过传入的classloder,将刚生成的$Proxy0类加载到jvm中。 利用中介类，调用$Proxy0的$Proxy0(InvocationHandler)构造函数，创建$Proxy0类的实例，其InvocationHandler属性，为我们创建的中介类。 上面的核心，就在于getProxyClass0方法： private static Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) { if (interfaces.length &gt; 65535) { throw new IllegalArgumentException(&quot;interface limit exceeded&quot;); } // If the proxy class defined by the given loader implementing // the given interfaces exists, this will simply return the cached copy; // otherwise, it will create the proxy class via the ProxyClassFactory return proxyClassCache.get(loader, interfaces); } 在Proxy类中有个属性proxyClassCache，这是一个WeakCache类型的静态变量。它指示了类加载器和代理类之间的映射。所以proxyClassCache的get方法用于根据类加载器来获取Proxy类，如果已经存在则直接从cache中返回，如果没有则创建一个映射并更新cache表。 我们跟一下代理类的创建流程： 调用Factory类的get方法，而它又调用了ProxyClassFactory类的apply方法，最终找到下面一行代码： //Generate the specified proxy class. byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces); 就是它，生成了代理类。 查看动态生成的代理类 通过上面的分析，我们已经知道Proxy类动态创建代理类的流程。那创建出来的代理类到底是什么样子的呢？我们可以通过下面的代码，手动生成： public class CodeUtil { public static void main(String[] args) throws IOException { byte[] classFile = ProxyGenerator.generateProxyClass(&quot;TestProxyGen&quot;, JavaCoder.class.getInterfaces()); File file = new File(&quot;D:/aaa/TestProxyGen.class&quot;); FileOutputStream fos = new FileOutputStream(file); fos.write(classFile); fos.flush(); fos.close(); } } 通过反编译工具查看生成的class文件: import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import java.lang.reflect.UndeclaredThrowableException; import model.proxy.ICoder; public final class TestProxyGen extends Proxy implements ICoder { private static Method m1; private static Method m0; private static Method m3; private static Method m2; public TestProxyGen(InvocationHandler paramInvocationHandler) throws { super(paramInvocationHandler); } public final boolean equals(Object paramObject) throws { try { return ((Boolean)this.h.invoke(this, m1, new Object[] { paramObject })).booleanValue(); } catch (RuntimeException localRuntimeException) { throw localRuntimeException; } catch (Throwable localThrowable) { } throw new UndeclaredThrowableException(localThrowable); } public final int hashCode() throws { try { return ((Integer)this.h.invoke(this, m0, null)).intValue(); } catch (RuntimeException localRuntimeException) { throw localRuntimeException; } catch (Throwable localThrowable) { } throw new UndeclaredThrowableException(localThrowable); } public final void implDemands(String paramString) throws { try { this.h.invoke(this, m3, new Object[] { paramString }); return; } catch (RuntimeException localRuntimeException) { throw localRuntimeException; } catch (Throwable localThrowable) { } throw new UndeclaredThrowableException(localThrowable); } public final String toString() throws { try { return (String)this.h.invoke(this, m2, null); } catch (RuntimeException localRuntimeException) { throw localRuntimeException; } catch (Throwable localThrowable) { } throw new UndeclaredThrowableException(localThrowable); } static { try { m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[] { Class.forName(&quot;java.lang.Object&quot;) }); m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]); m3 = Class.forName(&quot;model.proxy.ICoder&quot;).getMethod(&quot;implDemands&quot;, new Class[] { Class.forName(&quot;java.lang.String&quot;) }); m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]); return; } catch (NoSuchMethodException localNoSuchMethodException) { throw new NoSuchMethodError(localNoSuchMethodException.getMessage()); } catch (ClassNotFoundException localClassNotFoundException) { } throw new NoClassDefFoundError(localClassNotFoundException.getMessage()); } } 这样，我们就理解，为什么调用代理类的implDemands方法，回去执行中介类的invoke方法了。 看完本文有收获？请转发分享给更多人]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊java8时间与日期]]></title>
    <url>%2F2016%2F08%2F22%2Fjava8%E6%97%B6%E9%97%B4%E4%B8%8E%E6%97%A5%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[相信大家都有这样感觉，Java操作日期和时间的时候，会有一些麻烦。你也许会通过System.currentTimeMillis() 来返回1970年1月1日到今天的毫秒数。或者使用Date类来操作日期；当遇到加减月份、天数的时候 你又需要用到Calendar类；当需要格式化日期的时候需要使用java.text.DateFormat类。所以说在Java中操作日期不是很方便，以至于很多开发者不得不使用第三方库。 JAVA8以的API前存在的问题： 线程安全: Date和Calendar不是线程安全的，你需要编写额外的代码处理线程安全问题 API设计和易用性: 由于Date和Calendar的设计不当你无法完成日常的日期操作 ZonedDate和Time: 你必须编写额外的逻辑处理时区和那些旧的逻辑 好在JSR 310规范中为Java8添加了新的API， 在java.time包中，新的API纠正了过去的缺陷， 新的日期API ZoneId: 时区ID，用来确定Instant和LocalDateTime互相转换的规则 Instant: 用来表示时间线上的一个点 LocalDate: 表示没有时区的日期, LocalDate是不可变并且线程安全的 LocalTime: 表示没有时区的时间, LocalTime是不可变并且线程安全的 LocalDateTime: 表示没有时区的日期时间, LocalDateTime是不可变并且线程安全的 Clock: 用于访问当前时刻、日期、时间，用到时区 Duration: 用秒和纳秒表示时间的数量 最常用的就是LocalDate、LocalTime、LocalDateTime了，从它们的名字就可以看出是操作日期 和时间的。这些类是主要用于当时区不需要显式地指定的上下文。在本章节中我们将讨论最常用的api。 LocalDate LocalDate代表一个IOS格式(yyyy-MM-dd)的日期，可以存储 生日、纪念日等日期。 获取当前的日期： LocalDate localDate = LocalDate.now(); System.out.println(“localDate: “ + localDate); localDate: 2017-07-20 LocalDate可以指定特定的日期，调用of或parse方法返回该实例： LocalDate.of(2017, 07, 20); LocalDate.parse(“2017-07-20”); 当然它还有一些其他方法，我们一起来看看： 为今天添加一天，也就是获取明天 LocalDate tomorrow = LocalDate.now().plusDays(1); 从今天减去一个月 LocalDate prevMonth = LocalDate.now().minus(1, ChronoUnit.MONTHS); 下面写两个例子，分别解析日期 2017-07-20，获取每周中的星期和每月中的日： DayOfWeek thursday = LocalDate.parse(“2017-07-20”).getDayOfWeek(); System.out.println(“周四: “ + thursday); int twenty = LocalDate.parse(“2017-07-20”).getDayOfMonth(); System.out.println(“twenty: “ + twenty); 试试今年是不是闰年: boolean leapYear = LocalDate.now().isLeapYear(); System.out.println(“是否闰年: “ + leapYear); 判断是否在日期之前或之后: boolean notBefore = LocalDate.parse(“2017-07-20”) .isBefore(LocalDate.parse(&quot;2017-07-22&quot;)); System.out.println(“notBefore: “ + notBefore); boolean isAfter = LocalDate.parse(“2017-07-20”).isAfter(LocalDate.parse(“2017-07-22”)); System.out.println(“isAfter: “ + isAfter); 获取这个月的第一天: LocalDate firstDayOfMonth = LocalDate.parse(“2017-07-20”) .with(TemporalAdjusters.firstDayOfMonth()); System.out.println(“这个月的第一天: “ + firstDayOfMonth); firstDayOfMonth = firstDayOfMonth.withDayOfMonth(1); System.out.println(“这个月的第一天: “ + firstDayOfMonth); 判断今天是否是我的生日，例如我的生日是 2009-07-20 LocalDate birthday = LocalDate.of(2009, 07, 20); MonthDay birthdayMd = MonthDay.of(birthday.getMonth(), birthday.getDayOfMonth()); MonthDay today = MonthDay.from(LocalDate.now()); System.out.println(“今天是否是我的生日: “ + today.equals(birthdayMd)); LocalTime LocalTime表示一个时间，而不是日期，下面介绍一下它的使用方法。 获取现在的时间，输出15:01:22.144 LocalTime now = LocalTime.now(); System.out.println(“现在的时间: “ + now); 将一个字符串时间解析为LocalTime，输出15:02 LocalTime nowTime = LocalTime.parse(“15:02”); System.out.println(“时间是: “ + nowTime); 使用静态方法of创建一个时间 LocalTime nowTime = LocalTime.of(15, 02); System.out.println(“时间是: “ + nowTime); 使用解析字符串的方式并添加一小时，输出16:02 LocalTime nextHour = LocalTime.parse(“15:02”).plus(1, ChronoUnit.HOURS); System.out.println(“下一个小时: “ + nextHour); 获取时间的小时、分钟 int hour = LocalTime.parse(“15:02”).getHour(); System.out.println(“小时: “ + hour); int minute = LocalTime.parse(“15:02”).getMinute(); System.out.println(“分钟: “ + minute); 我们也可以通过之前类似的API检查一个时间是否在另一个时间之前、之后 boolean isBefore = LocalTime.parse(“15:02”).isBefore(LocalTime.parse(“16:02”)); boolean isAfter = LocalTime.parse(“15:02”).isAfter(LocalTime.parse(“16:02”)); System.out.println(“isBefore: “ + isBefore); System.out.println(“isAfter: “ + isAfter); 输出 isBefore: true, isAfter: false。 在LocalTime类中也将每天的开始和结束作为常量供我们使用: System.out.println(LocalTime.MAX); System.out.println(LocalTime.MIN); 输出: 23:59:59.999999999 00:00 LocalTime就这些了，下面我们来了解一下LocalDateTime LocalDateTime LocalDateTime是用来表示日期和时间的，这是一个最常用的类之一。 获取当前的日期和时间: LocalDateTime now = LocalDateTime.now(); System.out.println(“现在: “ + now); 输出 现在: 2017-07-20T15:17:19.926 下面使用静态方法和字符串的方式分别创建LocalDateTime对象 LocalDateTime.of(2017, Month.JULY, 20, 15, 18); LocalDateTime.parse(“2017-07-20T15:18:00”); `` 同时LocalDateTime也提供了相关API来对日期和时间进行增减操作: ```java LocalDateTime tomorrow = now.plusDays(1); System.out.println(“明天的这个时间: “ + tomorrow); LocalDateTime minusTowHour = now.minusHours(2); System.out.println(“两小时前: “ + minusTowHour); 这个类也提供一系列的get方法来获取特定单位: Month month = now.getMonth(); System.out.println(“当前月份: “ + month); 日期格式化 在日常开发中我们用到最多的也许就是日期、时间的格式化了，那在Java8种该如何操作呢？ LocalDateTime now = LocalDateTime.now(); DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(“yyyy-MM-dd HH:mm:ss”); System.out.println(“默认格式化: “ + now); System.out.println(“自定义格式化: “ + now.format(dateTimeFormatter)); LocalDateTime localDateTime = LocalDateTime.parse(“2017-07-20 15:27:44”, dateTimeFormatter); System.out.println(“字符串转LocalDateTime: “ + localDateTime); 也可以使用DateTimeFormatter的format方法将日期、时间格式化为字符串 DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(“yyyy-MM-dd”); String dateString = dateTimeFormatter.format(LocalDate.now()); System.out.println(“日期转字符串: “ + dateString); 日期周期 Period类用于修改给定日期或获得的两个日期之间的区别。 给初始化的日期添加5天: LocalDate initialDate = LocalDate.parse(“2017-07-20”); LocalDate finalDate = initialDate.plus(Period.ofDays(5)); System.out.println(“初始化日期: “ + initialDate); System.out.println(“加日期之后: “ + finalDate); 周期API中提供给我们可以比较两个日期的差别，像下面这样获取差距天数: long between = ChronoUnit.DAYS.between(initialDate, finalDate); System.out.println(“差距天数: “ + between); 上面的代码会返回5，当然你想获取两个日期相差多少小时也是简单的。 与遗留代码转换 在之前的代码中你可能出现了大量的Date类，如何将它转换为Java8种的时间类呢？ Date和Instant互相转换 Date date = Date.from(Instant.now()); Instant instant = date.toInstant(); Date转换为LocalDateTime LocalDateTime localDateTime = LocalDateTime.from(new Date()); System.out.println(localDateTime); LocalDateTime转Date Date date = Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant()); LocalDate转Date Date date = Date.from(LocalDate.now().atStartOfDay().atZone(ZoneId.systemDefault()).toInstant]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>